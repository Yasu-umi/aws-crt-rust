/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const PRInSTR: &[u8; 5] = b"%.*s\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140400;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const AWS_PACKAGE_SLOTS: u32 = 32;
pub const AWS_C_COMMON_PACKAGE_ID: u32 = 0;
pub const AWS_OP_SUCCESS: u32 = 0;
pub const AWS_OP_ERR: i32 = -1;
pub const AWS_ERROR_ENUM_STRIDE_BITS: u32 = 10;
pub const AWS_ERROR_ENUM_STRIDE: u32 = 1024;
pub const DYNAMIC_TARGETS_ENABLED: u32 = 0;
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_MACCATALYST: u32 = 0;
pub const TARGET_OS_UIKITFORMAC: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_RTKIT: u32 = 0;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_CPU_ARM64: u32 = 1;
pub const TARGET_OS_VISION: u32 = 0;
pub const TARGET_OS_DRIVERKIT: u32 = 0;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_WINDOWS: u32 = 0;
pub const TARGET_OS_LINUX: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 0;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const SIZE_BITS: u32 = 64;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const SO_RESOLVER_SIGNATURE: u32 = 4401;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const AWS_CBOR_TAG_STANDARD_TIME: u32 = 0;
pub const AWS_CBOR_TAG_EPOCH_TIME: u32 = 1;
pub const AWS_CBOR_TAG_UNSIGNED_BIGNUM: u32 = 2;
pub const AWS_CBOR_TAG_NEGATIVE_BIGNUM: u32 = 3;
pub const AWS_CBOR_TAG_DECIMAL_FRACTION: u32 = 4;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const TIME_UTC: u32 = 1;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const AWS_PATH_DELIM: u8 = 47u8;
pub const AWS_PATH_DELIM_STR: &[u8; 2] = b"/\0";
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const AWS_THREAD_NAME_RECOMMENDED_STRLEN: u32 = 15;
pub const AWS_LOG_LEVEL_NONE: u32 = 0;
pub const AWS_LOG_LEVEL_FATAL: u32 = 1;
pub const AWS_LOG_LEVEL_ERROR: u32 = 2;
pub const AWS_LOG_LEVEL_WARN: u32 = 3;
pub const AWS_LOG_LEVEL_INFO: u32 = 4;
pub const AWS_LOG_LEVEL_DEBUG: u32 = 5;
pub const AWS_LOG_LEVEL_TRACE: u32 = 6;
pub const __GNUC_VA_LIST: u32 = 1;
pub type static_assertion_at_line_60 = [::std::os::raw::c_char; 1usize];
pub type static_assertion_at_line_61 = [::std::os::raw::c_char; 1usize];
pub type static_assertion_at_line_62 = [::std::os::raw::c_char; 1usize];
pub const AWS_CACHE_LINE: _bindgen_ty_1 = _bindgen_ty_1::AWS_CACHE_LINE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    AWS_CACHE_LINE = 64,
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_fatal_assert(
        cond_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> !;
}
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_reserved: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_secure_time_in_system) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_time_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_secure_ptime_in_system) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_ptime_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
#[doc = " @deprecated Use int64_t instead for offsets in public APIs."]
pub type aws_off_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_allocator {
    pub mem_acquire: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_release: ::std::option::Option<
        unsafe extern "C" fn(allocator: *mut aws_allocator, ptr: *mut ::std::os::raw::c_void),
    >,
    pub mem_realloc: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            oldptr: *mut ::std::os::raw::c_void,
            oldsize: usize,
            newsize: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_calloc: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            num: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_allocator() {
    const UNINIT: ::std::mem::MaybeUninit<aws_allocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_allocator>(),
        40usize,
        concat!("Size of: ", stringify!(aws_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_allocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_acquire) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_acquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_realloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_calloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_calloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Inexpensive (constant time) check of data-structure invariants."]
    pub fn aws_allocator_is_valid(alloc: *const aws_allocator) -> bool;
}
extern "C" {
    pub fn aws_default_allocator() -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_aligned_allocator() -> *mut aws_allocator;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAllocator {
    _unused: [u8; 0],
}
pub type CFAllocatorRef = *const __CFAllocator;
extern "C" {
    #[doc = " Wraps a CFAllocator around aws_allocator. For Mac only. Use this anytime you need a CFAllocatorRef for interacting\n with Apple Frameworks. Unfortunately, it allocates memory so we can't make it static file scope, be sure to call\n aws_wrapped_cf_allocator_destroy when finished."]
    pub fn aws_wrapped_cf_allocator_new(allocator: *mut aws_allocator) -> CFAllocatorRef;
}
extern "C" {
    #[doc = " Cleans up any resources alloced in aws_wrapped_cf_allocator_new."]
    pub fn aws_wrapped_cf_allocator_destroy(allocator: CFAllocatorRef);
}
extern "C" {
    #[doc = " Returns at least `size` of memory ready for usage. In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_acquire(
        allocator: *mut aws_allocator,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits\n to zero. In versions v0.6.8 and prior, this function was allowed to return NULL.\n In later versions, if allocator->mem_calloc() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_calloc() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_calloc(
        allocator: *mut aws_allocator,
        num: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocates many chunks of bytes into a single block. Expects to be called with alternating void ** (dest), size_t\n (size). The first void ** will be set to the root of the allocation. Alignment is assumed to be sizeof(intmax_t).\n\n This is useful for allocating structs using the pimpl pattern, as you may allocate the public object and impl object\n in the same contiguous block of memory.\n\n Returns a pointer to the allocation.\n\n In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_acquire_many(
        allocator: *mut aws_allocator,
        count: usize,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Releases ptr back to whatever allocated it.\n Nothing happens if ptr is NULL."]
    pub fn aws_mem_release(allocator: *mut aws_allocator, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Attempts to adjust the size of the pointed-to memory buffer from oldsize to\n newsize. The pointer (*ptr) may be changed if the memory needs to be\n reallocated.\n\n In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_realloc() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_realloc() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_realloc(
        allocator: *mut aws_allocator,
        ptr: *mut *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_mem_trace_level {
    AWS_MEMTRACE_NONE = 0,
    AWS_MEMTRACE_BYTES = 1,
    AWS_MEMTRACE_STACKS = 2,
}
extern "C" {
    pub fn aws_mem_tracer_new(
        allocator: *mut aws_allocator,
        deprecated: *mut aws_allocator,
        level: aws_mem_trace_level,
        frames_per_stack: usize,
    ) -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_mem_tracer_destroy(trace_allocator: *mut aws_allocator) -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_mem_tracer_dump(trace_allocator: *mut aws_allocator);
}
extern "C" {
    pub fn aws_mem_tracer_bytes(trace_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_mem_tracer_count(trace_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_new(
        allocator: *mut aws_allocator,
        multi_threaded: bool,
    ) -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_small_block_allocator_destroy(sba_allocator: *mut aws_allocator);
}
extern "C" {
    pub fn aws_small_block_allocator_bytes_active(sba_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_bytes_reserved(sba_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_page_size(sba_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_page_size_available(
        sba_allocator: *mut aws_allocator,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_error_info {
    pub error_code: ::std::os::raw::c_int,
    pub literal_name: *const ::std::os::raw::c_char,
    pub error_str: *const ::std::os::raw::c_char,
    pub lib_name: *const ::std::os::raw::c_char,
    pub formatted_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aws_error_info() {
    const UNINIT: ::std::mem::MaybeUninit<aws_error_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_error_info>(),
        40usize,
        concat!("Size of: ", stringify!(aws_error_info))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_error_info>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_error_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).literal_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(literal_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_str) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(error_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lib_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(lib_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatted_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(formatted_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_error_info_list {
    pub error_list: *const aws_error_info,
    pub count: u16,
}
#[test]
fn bindgen_test_layout_aws_error_info_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_error_info_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_error_info_list>(),
        16usize,
        concat!("Size of: ", stringify!(aws_error_info_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_error_info_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_error_info_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info_list),
            "::",
            stringify!(error_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info_list),
            "::",
            stringify!(count)
        )
    );
}
pub type aws_error_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(err: ::std::os::raw::c_int, ctx: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn aws_last_error() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_error_str(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_error_name(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_error_lib_name(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_error_debug_str(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_raise_error_private(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn aws_reset_error();
}
extern "C" {
    pub fn aws_restore_error(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn aws_set_global_error_handler_fn(
        handler: aws_error_handler_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> aws_error_handler_fn;
}
extern "C" {
    pub fn aws_set_thread_local_error_handler_fn(
        handler: aws_error_handler_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> aws_error_handler_fn;
}
extern "C" {
    #[doc = " TODO: this needs to be a private function (wait till we have the cmake story\n better before moving it though). It should be external for the purpose of\n other libs we own, but customers should not be able to hit it without going\n out of their way to do so."]
    pub fn aws_register_error_info(error_info: *const aws_error_info_list);
}
extern "C" {
    pub fn aws_unregister_error_info(error_info: *const aws_error_info_list);
}
extern "C" {
    #[doc = " Convert a c library io error into an aws error, and raise it.\n If no conversion is found, fallback_aws_error_code is raised.\n Always returns AWS_OP_ERR."]
    pub fn aws_translate_and_raise_io_error_or(
        error_no: ::std::os::raw::c_int,
        fallback_aws_error_code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a c library io error into an aws error, and raise it.\n If no conversion is found, AWS_ERROR_SYS_CALL_FAILURE is raised.\n Always returns AWS_OP_ERR."]
    pub fn aws_translate_and_raise_io_error(
        error_no: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_common_error {
    AWS_ERROR_SUCCESS = 0,
    AWS_ERROR_OOM = 1,
    AWS_ERROR_NO_SPACE = 2,
    AWS_ERROR_UNKNOWN = 3,
    AWS_ERROR_SHORT_BUFFER = 4,
    AWS_ERROR_OVERFLOW_DETECTED = 5,
    AWS_ERROR_UNSUPPORTED_OPERATION = 6,
    AWS_ERROR_INVALID_BUFFER_SIZE = 7,
    AWS_ERROR_INVALID_HEX_STR = 8,
    AWS_ERROR_INVALID_BASE64_STR = 9,
    AWS_ERROR_INVALID_INDEX = 10,
    AWS_ERROR_THREAD_INVALID_SETTINGS = 11,
    AWS_ERROR_THREAD_INSUFFICIENT_RESOURCE = 12,
    AWS_ERROR_THREAD_NO_PERMISSIONS = 13,
    AWS_ERROR_THREAD_NOT_JOINABLE = 14,
    AWS_ERROR_THREAD_NO_SUCH_THREAD_ID = 15,
    AWS_ERROR_THREAD_DEADLOCK_DETECTED = 16,
    AWS_ERROR_MUTEX_NOT_INIT = 17,
    AWS_ERROR_MUTEX_TIMEOUT = 18,
    AWS_ERROR_MUTEX_CALLER_NOT_OWNER = 19,
    AWS_ERROR_MUTEX_FAILED = 20,
    AWS_ERROR_COND_VARIABLE_INIT_FAILED = 21,
    AWS_ERROR_COND_VARIABLE_TIMED_OUT = 22,
    AWS_ERROR_COND_VARIABLE_ERROR_UNKNOWN = 23,
    AWS_ERROR_CLOCK_FAILURE = 24,
    AWS_ERROR_LIST_EMPTY = 25,
    AWS_ERROR_DEST_COPY_TOO_SMALL = 26,
    AWS_ERROR_LIST_EXCEEDS_MAX_SIZE = 27,
    AWS_ERROR_LIST_STATIC_MODE_CANT_SHRINK = 28,
    AWS_ERROR_PRIORITY_QUEUE_FULL = 29,
    AWS_ERROR_PRIORITY_QUEUE_EMPTY = 30,
    AWS_ERROR_PRIORITY_QUEUE_BAD_NODE = 31,
    AWS_ERROR_HASHTBL_ITEM_NOT_FOUND = 32,
    AWS_ERROR_INVALID_DATE_STR = 33,
    AWS_ERROR_INVALID_ARGUMENT = 34,
    AWS_ERROR_RANDOM_GEN_FAILED = 35,
    AWS_ERROR_MALFORMED_INPUT_STRING = 36,
    AWS_ERROR_UNIMPLEMENTED = 37,
    AWS_ERROR_INVALID_STATE = 38,
    AWS_ERROR_ENVIRONMENT_GET = 39,
    AWS_ERROR_ENVIRONMENT_SET = 40,
    AWS_ERROR_ENVIRONMENT_UNSET = 41,
    AWS_ERROR_STREAM_UNSEEKABLE = 42,
    AWS_ERROR_NO_PERMISSION = 43,
    AWS_ERROR_FILE_INVALID_PATH = 44,
    AWS_ERROR_MAX_FDS_EXCEEDED = 45,
    AWS_ERROR_SYS_CALL_FAILURE = 46,
    AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED = 47,
    AWS_ERROR_STRING_MATCH_NOT_FOUND = 48,
    AWS_ERROR_DIVIDE_BY_ZERO = 49,
    AWS_ERROR_INVALID_FILE_HANDLE = 50,
    AWS_ERROR_OPERATION_INTERUPTED = 51,
    AWS_ERROR_DIRECTORY_NOT_EMPTY = 52,
    AWS_ERROR_PLATFORM_NOT_SUPPORTED = 53,
    AWS_ERROR_INVALID_UTF8 = 54,
    AWS_ERROR_GET_HOME_DIRECTORY_FAILED = 55,
    AWS_ERROR_INVALID_XML = 56,
    AWS_ERROR_FILE_OPEN_FAILURE = 57,
    AWS_ERROR_FILE_READ_FAILURE = 58,
    AWS_ERROR_FILE_WRITE_FAILURE = 59,
    AWS_ERROR_INVALID_CBOR = 60,
    AWS_ERROR_CBOR_UNEXPECTED_TYPE = 61,
    AWS_ERROR_END_COMMON_RANGE = 1023,
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Securely zeroes a memory buffer. This function will attempt to ensure that\n the compiler will not optimize away this zeroing operation."]
    pub fn aws_secure_zero(pBuf: *mut ::std::os::raw::c_void, bufsize: usize);
}
extern "C" {
    #[doc = " Initializes internal data structures used by aws-c-common.\n Must be called before using any functionality in aws-c-common."]
    pub fn aws_common_library_init(allocator: *mut aws_allocator);
}
extern "C" {
    #[doc = " Shuts down the internal data structures used by aws-c-common."]
    pub fn aws_common_library_clean_up();
}
extern "C" {
    pub fn aws_common_fatal_assert_library_initialized();
}
extern "C" {
    #[doc = " Adds [num] arguments (expected to be of size_t), and returns the result in *r.\n If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS."]
    pub fn aws_add_size_checked_varargs(num: usize, r: *mut usize, ...) -> ::std::os::raw::c_int;
}
pub const AWS_ARRAY_LIST_DEBUG_FILL: _bindgen_ty_2 = _bindgen_ty_2::AWS_ARRAY_LIST_DEBUG_FILL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    AWS_ARRAY_LIST_DEBUG_FILL = 221,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_array_list {
    pub alloc: *mut aws_allocator,
    pub current_size: usize,
    pub length: usize,
    pub item_size: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_array_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_array_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_array_list>(),
        40usize,
        concat!("Size of: ", stringify!(aws_array_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_array_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_array_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(current_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(item_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Prototype for a comparator function for sorting elements.\n\n a and b should be cast to pointers to the element type held in the list\n before being dereferenced. The function should compare the elements and\n return a positive number if a > b, zero if a = b, and a negative number\n if a < b."]
pub type aws_array_list_comparator_fn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " If in dynamic mode, shrinks the allocated array size to the minimum amount necessary to store its elements."]
    pub fn aws_array_list_shrink_to_fit(list: *mut aws_array_list) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the elements from from to to. If to is in static mode, it must at least be the same length as from. Any data\n in to will be overwritten in this copy."]
    pub fn aws_array_list_copy(
        from: *const aws_array_list,
        to: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensures that the array list has enough capacity to store a value at the specified index. If there is not already\n enough capacity, and the list is in dynamic mode, this function will attempt to allocate more memory, expanding the\n list. In static mode, if 'index' is beyond the maximum index, AWS_ERROR_INVALID_INDEX will be raised."]
    pub fn aws_array_list_ensure_capacity(
        list: *mut aws_array_list,
        index: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Swap elements at the specified indices, which must be within the bounds of the array."]
    pub fn aws_array_list_swap(list: *mut aws_array_list, a: usize, b: usize);
}
extern "C" {
    #[doc = " Sort elements in the list in-place according to the comparator function."]
    pub fn aws_array_list_sort(list: *mut aws_array_list, compare_fn: aws_array_list_comparator_fn);
}
#[doc = " struct aws_atomic_var represents an atomic variable - a value which can hold an integer or pointer\n that can be manipulated atomically. struct aws_atomic_vars should normally only be manipulated\n with atomics methods defined in this header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_atomic_var {
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_atomic_var() {
    const UNINIT: ::std::mem::MaybeUninit<aws_atomic_var> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_atomic_var>(),
        8usize,
        concat!("Size of: ", stringify!(aws_atomic_var))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_atomic_var>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_atomic_var))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_atomic_var),
            "::",
            stringify!(value)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_memory_order {
    #[doc = " No particular ordering constraints are guaranteed relative to other\n operations at all; we merely ensure that the operation itself is atomic."]
    aws_memory_order_relaxed = 0,
    #[doc = " Specifies acquire ordering. No reads or writes on the current thread can be\n reordered to happen before this operation. This is typically paired with a release\n ordering; any writes that happened on the releasing operation will be visible\n after the paired acquire operation.\n\n Acquire ordering is only meaningful on load or load-store operations."]
    aws_memory_order_acquire = 2,
    #[doc = " Specifies release order. No reads or writes can be reordered to come after this\n operation. Typically paired with an acquire operation.\n\n Release ordering is only meaningful on store or load-store operations."]
    aws_memory_order_release = 3,
    #[doc = " Specifies acquire-release order; if this operation acts as a load, it acts as an\n acquire operation; if it acts as a store, it acts as a release operation; if it's\n a load-store, it does both."]
    aws_memory_order_acq_rel = 4,
    #[doc = " Specifies acquire-release order; if this operation acts as a load, it acts as an\n acquire operation; if it acts as a store, it acts as a release operation; if it's\n a load-store, it does both."]
    aws_memory_order_seq_cst = 5,
}
pub type aws_atomic_impl_int_t = usize;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    const UNINIT: ::std::mem::MaybeUninit<sa_endpoints> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcif) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddrlen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    const UNINIT: ::std::mem::MaybeUninit<so_np_extensions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sockaddr_header {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
}
#[test]
fn bindgen_test_layout___sockaddr_header() {
    const UNINIT: ::std::mem::MaybeUninit<__sockaddr_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sockaddr_header>(),
        2usize,
        concat!("Size of: ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        ::std::mem::align_of::<__sockaddr_header>(),
        1usize,
        concat!("Alignment of ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_family)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    const UNINIT: ::std::mem::MaybeUninit<sockproto> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_protocol) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    const UNINIT: ::std::mem::MaybeUninit<sf_hdtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trl_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    const UNINIT: ::std::mem::MaybeUninit<__msfilterreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_fmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_nsrcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_nsrcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__msfr_align) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(__msfr_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_srcs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_srcs)
        )
    );
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in6_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_mtuinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Represents a length-delimited binary string or buffer. If byte buffer points\n to constant memory or memory that should otherwise not be freed by this\n struct, set allocator to NULL and free function will be a no-op.\n\n This structure used to define the output for all functions that write to a buffer.\n\n Note that this structure allocates memory at the buffer pointer only. The\n struct itself does not get dynamically allocated and must be either\n maintained or copied to avoid losing access to the memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_byte_buf {
    pub len: usize,
    pub buffer: *mut u8,
    pub capacity: usize,
    pub allocator: *mut aws_allocator,
}
#[test]
fn bindgen_test_layout_aws_byte_buf() {
    const UNINIT: ::std::mem::MaybeUninit<aws_byte_buf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_byte_buf>(),
        32usize,
        concat!("Size of: ", stringify!(aws_byte_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_byte_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_byte_buf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Represents a movable pointer within a larger binary string or buffer.\n\n This structure is used to define buffers for reading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_byte_cursor {
    pub len: usize,
    pub ptr: *mut u8,
}
#[test]
fn bindgen_test_layout_aws_byte_cursor() {
    const UNINIT: ::std::mem::MaybeUninit<aws_byte_cursor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_byte_cursor>(),
        16usize,
        concat!("Size of: ", stringify!(aws_byte_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_byte_cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_byte_cursor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_cursor),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_cursor),
            "::",
            stringify!(ptr)
        )
    );
}
#[doc = " Signature for function argument to trim APIs"]
pub type aws_byte_predicate_fn = ::std::option::Option<unsafe extern "C" fn(value: u8) -> bool>;
extern "C" {
    #[doc = " Compare two arrays.\n Return whether their contents are equivalent.\n NULL may be passed as the array pointer if its length is declared to be 0."]
    pub fn aws_array_eq(
        array_a: *const ::std::os::raw::c_void,
        len_a: usize,
        array_b: *const ::std::os::raw::c_void,
        len_b: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of two arrays.\n Return whether their contents are equivalent.\n NULL may be passed as the array pointer if its length is declared to be 0.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_array_eq_ignore_case(
        array_a: *const ::std::os::raw::c_void,
        len_a: usize,
        array_b: *const ::std::os::raw::c_void,
        len_b: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Compare an array and a null-terminated string.\n Returns true if their contents are equivalent.\n The array should NOT contain a null-terminator, or the comparison will always return false.\n NULL may be passed as the array pointer if its length is declared to be 0."]
    pub fn aws_array_eq_c_str(
        array: *const ::std::os::raw::c_void,
        array_len: usize,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an array and a null-terminated string.\n Return whether their contents are equivalent.\n The array should NOT contain a null-terminator, or the comparison will always return false.\n NULL may be passed as the array pointer if its length is declared to be 0.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_array_eq_c_str_ignore_case(
        array: *const ::std::os::raw::c_void,
        array_len: usize,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn aws_byte_buf_init(
        buf: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes an aws_byte_buf structure base on another valid one.\n Requires: *src and *allocator are valid objects.\n Ensures: *dest is a valid aws_byte_buf with a new backing array dest->buffer\n which is a copy of the elements from src->buffer."]
    pub fn aws_byte_buf_init_copy(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        src: *const aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads 'filename' into 'out_buf'. If successful, 'out_buf' is allocated and filled with the data;\n It is your responsibility to call 'aws_byte_buf_clean_up()' on it. Otherwise, 'out_buf' remains\n unused. In the very unfortunate case where some API needs to treat out_buf as a c_string, a null terminator\n is appended, but is not included as part of the length field."]
    pub fn aws_byte_buf_init_from_file(
        out_buf: *mut aws_byte_buf,
        alloc: *mut aws_allocator,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as aws_byte_buf_init_from_file(), but for reading \"special files\" like /proc/cpuinfo.\n These files don't accurately report their size, so size_hint is used as initial buffer size,\n and the buffer grows until the while file is read."]
    pub fn aws_byte_buf_init_from_file_with_size_hint(
        out_buf: *mut aws_byte_buf,
        alloc: *mut aws_allocator,
        filename: *const ::std::os::raw::c_char,
        size_hint: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Evaluates the set of properties that define the shape of all valid aws_byte_buf structures.\n It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion)."]
    pub fn aws_byte_buf_is_valid(buf: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Evaluates the set of properties that define the shape of all valid aws_byte_cursor structures.\n It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion)."]
    pub fn aws_byte_cursor_is_valid(cursor: *const aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Copies src buffer into dest and sets the correct len and capacity.\n A new memory zone is allocated for dest->buffer. When dest is no longer needed it will have to be cleaned-up using\n aws_byte_buf_clean_up(dest).\n Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator.\n If src buffer is null the dest will have a null buffer with a len and a capacity of 0\n Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated."]
    pub fn aws_byte_buf_init_copy_from_cursor(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        src: aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Init buffer with contents of multiple cursors, and update cursors to reference the memory stored in the buffer.\n Each cursor arg must be an `struct aws_byte_cursor *`. NULL must be passed as the final arg.\n NOTE: Do not append/grow/resize buffers initialized this way, or the cursors will end up referencing invalid memory.\n Returns AWS_OP_SUCCESS in case of success.\n AWS_OP_ERR is returned if memory can't be allocated or the total cursor length exceeds SIZE_MAX."]
    pub fn aws_byte_buf_init_cache_and_update_cursors(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_byte_buf_clean_up(buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Equivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up\n on the buffer."]
    pub fn aws_byte_buf_clean_up_secure(buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Resets the len of the buffer to 0, but does not free the memory. The buffer can then be reused.\n Optionally zeroes the contents, if the \"zero_contents\" flag is true."]
    pub fn aws_byte_buf_reset(buf: *mut aws_byte_buf, zero_contents: bool);
}
extern "C" {
    #[doc = " Sets all bytes of buffer to zero and resets len to zero."]
    pub fn aws_byte_buf_secure_zero(buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Compare two aws_byte_buf structures.\n Return whether their contents are equivalent."]
    pub fn aws_byte_buf_eq(a: *const aws_byte_buf, b: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of two aws_byte_buf structures.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_buf_eq_ignore_case(a: *const aws_byte_buf, b: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Compare an aws_byte_buf and a null-terminated string.\n Returns true if their contents are equivalent.\n The buffer should NOT contain a null-terminator, or the comparison will always return false."]
    pub fn aws_byte_buf_eq_c_str(
        buf: *const aws_byte_buf,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_buf and a null-terminated string.\n Return whether their contents are equivalent.\n The buffer should NOT contain a null-terminator, or the comparison will always return false.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_buf_eq_c_str_ignore_case(
        buf: *const aws_byte_buf,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " No copies, no buffer allocations. Iterates over input_str, and returns the\n next substring between split_on instances relative to previous substr.\n Behaves similar to strtok with substr being used as state for next split.\n\n Returns true each time substr is set and false when there is no more splits\n (substr is set to empty in that case).\n\n Example usage.\n struct aws_byte_cursor substr = {0};\n while (aws_byte_cursor_next_split(&input_str, ';', &substr)) {\n   // ...use substr...\n }\n\n Note: It is the user's responsibility zero-initialize substr before the first call.\n\n Edge case rules are as follows:\n empty input will have single empty split. ex. \"\" splits into \"\"\n if input starts with split_on then first split is empty. ex \";A\" splits into \"\", \"A\"\n adjacent split tokens result in empty split. ex \"A;;B\" splits into \"A\", \"\", \"B\"\n If the input ends with split_on, last split is empty. ex. \"A;\" splits into \"A\", \"\"\n\n It is the user's responsibility to make sure the input buffer stays in memory\n long enough to use the results."]
    pub fn aws_byte_cursor_next_split(
        input_str: *const aws_byte_cursor,
        split_on: ::std::os::raw::c_char,
        substr: *mut aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " No copies, no buffer allocations. Fills in output with a list of\n aws_byte_cursor instances where buffer is an offset into the input_str and\n len is the length of that string in the original buffer.\n\n Edge case rules are as follows:\n if the input begins with split_on, an empty cursor will be the first entry in\n output. if the input has two adjacent split_on tokens, an empty cursor will\n be inserted into the output. if the input ends with split_on, an empty cursor\n will be appended to the output.\n\n It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from\n output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\n The type that will be stored in output is struct aws_byte_cursor (you'll need\n this for the item size param).\n\n It is the user's responsibility to make sure the input buffer stays in memory\n long enough to use the results."]
    pub fn aws_byte_cursor_split_on_char(
        input_str: *const aws_byte_cursor,
        split_on: ::std::os::raw::c_char,
        output: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " No copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is\n an offset into the input_str and len is the length of that string in the original buffer. N is the max number of\n splits, if this value is zero, it will add all splits to the output.\n\n Edge case rules are as follows:\n if the input begins with split_on, an empty cursor will be the first entry in output\n if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output.\n if the input ends with split_on, an empty cursor will be appended to the output.\n\n It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from\n output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\n If the output array is not large enough, input_str will be updated to point to the first character after the last\n processed split_on instance.\n\n The type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\n It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results."]
    pub fn aws_byte_cursor_split_on_char_n(
        input_str: *const aws_byte_cursor,
        split_on: ::std::os::raw::c_char,
        n: usize,
        output: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS\n on successful match and first_find will be set to the offset in input_str, and length will be the remaining length\n from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and\n AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised."]
    pub fn aws_byte_cursor_find_exact(
        input_str: *const aws_byte_cursor,
        to_find: *const aws_byte_cursor,
        first_find: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shrinks a byte cursor from the right for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_right_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Shrinks a byte cursor from the left for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_left_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Shrinks a byte cursor from both sides for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns true if the byte cursor's range of bytes all satisfy the predicate"]
    pub fn aws_byte_cursor_satisfies_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> bool;
}
extern "C" {
    #[doc = " Copies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be\n returned. dest->len will contain the amount of data actually copied to dest.\n\n from and to may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies from to to while converting bytes via the passed in lookup table.\n If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be\n returned. to->len will contain its original size plus the amount of data actually copied to to.\n\n from and to should not be the same buffer (overlap is not handled)\n lookup_table must be at least 256 bytes"]
    pub fn aws_byte_buf_append_with_lookup(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
        lookup_table: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies from to to. If to is too small, the buffer will be grown appropriately and\n the old contents copied to, before the new contents are appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n from and to may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append_dynamic(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies `from` to `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the new contents are appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n If the buffer is grown, the old buffer will be securely cleared before getting freed.\n\n `from` and `to` may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append_dynamic_secure(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the byte is appended.\n\n If the grow fails (overflow or OOM), then an error will be returned."]
    pub fn aws_byte_buf_append_byte_dynamic(
        buffer: *mut aws_byte_buf,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the byte is appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n If the buffer is grown, the old buffer will be securely cleared before getting freed."]
    pub fn aws_byte_buf_append_byte_dynamic_secure(
        buffer: *mut aws_byte_buf,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer.\n If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.\n\n The cursor is permitted to reference memory from earlier in the buffer."]
    pub fn aws_byte_buf_append_and_update(
        to: *mut aws_byte_buf,
        from_and_update: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Appends '\\0' at the end of the buffer."]
    pub fn aws_byte_buf_append_null_terminator(buf: *mut aws_byte_buf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to increase the capacity of a buffer to the requested capacity\n\n If the the buffer's capacity is currently larger than the request capacity, the\n function does nothing (no shrink is performed)."]
    pub fn aws_byte_buf_reserve(
        buffer: *mut aws_byte_buf,
        requested_capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function that attempts to increase the capacity of a buffer relative to the current\n length.\n\n  aws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf->len + x)\n"]
    pub fn aws_byte_buf_reserve_relative(
        buffer: *mut aws_byte_buf,
        additional_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Concatenates a variable number of struct aws_byte_buf * into destination.\n Number of args must be greater than 1. If dest is too small,\n AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest->len will contain the\n amount of data actually copied to dest."]
    pub fn aws_byte_buf_cat(
        dest: *mut aws_byte_buf,
        number_of_args: usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two aws_byte_cursor structures.\n Return whether their contents are equivalent."]
    pub fn aws_byte_cursor_eq(a: *const aws_byte_cursor, b: *const aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of two aws_byte_cursor structures.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_ignore_case(
        a: *const aws_byte_cursor,
        b: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Compare an aws_byte_cursor and an aws_byte_buf.\n Return whether their contents are equivalent."]
    pub fn aws_byte_cursor_eq_byte_buf(a: *const aws_byte_cursor, b: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_cursor and an aws_byte_buf.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_byte_buf_ignore_case(
        a: *const aws_byte_cursor,
        b: *const aws_byte_buf,
    ) -> bool;
}
extern "C" {
    #[doc = " Compare an aws_byte_cursor and a null-terminated string.\n Returns true if their contents are equivalent.\n The cursor should NOT contain a null-terminator, or the comparison will always return false."]
    pub fn aws_byte_cursor_eq_c_str(
        cursor: *const aws_byte_cursor,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_cursor and a null-terminated string.\n Return whether their contents are equivalent.\n The cursor should NOT contain a null-terminator, or the comparison will always return false.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_c_str_ignore_case(
        cursor: *const aws_byte_cursor,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the input starts with the prefix (exact byte comparison)."]
    pub fn aws_byte_cursor_starts_with(
        input: *const aws_byte_cursor,
        prefix: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the input starts with the prefix (case-insensitive).\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_starts_with_ignore_case(
        input: *const aws_byte_cursor,
        prefix: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Case-insensitive hash function for array containing ASCII or UTF-8 text."]
    pub fn aws_hash_array_ignore_case(array: *const ::std::os::raw::c_void, len: usize) -> u64;
}
extern "C" {
    #[doc = " Case-insensitive hash function for aws_byte_cursors stored in an aws_hash_table.\n For case-sensitive hashing, use aws_hash_byte_cursor_ptr()."]
    pub fn aws_hash_byte_cursor_ptr_ignore_case(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Returns a lookup table for bytes that is the identity transformation with the exception\n of uppercase ascii characters getting replaced with lowercase characters.  Used in\n caseless comparisons."]
    pub fn aws_lookup_table_to_lower_get() -> *const u8;
}
extern "C" {
    #[doc = " Returns lookup table to go from ASCII/UTF-8 hex character to a number (0-15).\n Non-hex characters map to 255.\n Valid examples:\n '0' -> 0\n 'F' -> 15\n 'f' -> 15\n Invalid examples:\n ' ' -> 255\n 'Z' -> 255\n '\\0' -> 255"]
    pub fn aws_lookup_table_hex_to_num_get() -> *const u8;
}
extern "C" {
    #[doc = " Lexical (byte value) comparison of two byte cursors"]
    pub fn aws_byte_cursor_compare_lexical(
        lhs: *const aws_byte_cursor,
        rhs: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first"]
    pub fn aws_byte_cursor_compare_lookup(
        lhs: *const aws_byte_cursor,
        rhs: *const aws_byte_cursor,
        lookup_table: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For creating a byte buffer from a null-terminated string literal."]
    pub fn aws_byte_buf_from_c_str(c_str: *const ::std::os::raw::c_char) -> aws_byte_buf;
}
extern "C" {
    pub fn aws_byte_buf_from_array(
        bytes: *const ::std::os::raw::c_void,
        len: usize,
    ) -> aws_byte_buf;
}
extern "C" {
    pub fn aws_byte_buf_from_empty_array(
        bytes: *const ::std::os::raw::c_void,
        capacity: usize,
    ) -> aws_byte_buf;
}
extern "C" {
    pub fn aws_byte_cursor_from_buf(buf: *const aws_byte_buf) -> aws_byte_cursor;
}
extern "C" {
    pub fn aws_byte_cursor_from_c_str(c_str: *const ::std::os::raw::c_char) -> aws_byte_cursor;
}
extern "C" {
    pub fn aws_byte_cursor_from_array(
        bytes: *const ::std::os::raw::c_void,
        len: usize,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Tests if the given aws_byte_cursor has at least len bytes remaining. If so,\n *buf is advanced by len bytes (incrementing ->ptr and decrementing ->len),\n and an aws_byte_cursor referring to the first len bytes of the original *buf\n is returned. Otherwise, an aws_byte_cursor with ->ptr = NULL, ->len = 0 is\n returned.\n\n Note that if len is above (SIZE_MAX / 2), this function will also treat it as\n a buffer overflow, and return NULL without changing *buf."]
    pub fn aws_byte_cursor_advance(cursor: *mut aws_byte_cursor, len: usize) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Behaves identically to aws_byte_cursor_advance, but avoids speculative\n execution potentially reading out-of-bounds pointers (by returning an\n empty ptr in such speculated paths).\n\n This should generally be done when using an untrusted or\n data-dependent value for 'len', to avoid speculating into a path where\n cursor->ptr points outside the true ptr length."]
    pub fn aws_byte_cursor_advance_nospec(
        cursor: *mut aws_byte_cursor,
        len: usize,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Reads specified length of data from byte cursor and copies it to the\n destination array.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read(
        cur: *mut aws_byte_cursor,
        dest: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Reads as many bytes from cursor as size of buffer, and copies them to buffer.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_and_fill_buffer(
        cur: *mut aws_byte_cursor,
        dest: *mut aws_byte_buf,
    ) -> bool;
}
extern "C" {
    #[doc = " Reads a single byte from cursor, placing it in *var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_u8(cur: *mut aws_byte_cursor, var: *mut u8) -> bool;
}
extern "C" {
    #[doc = " Reads a 16-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be16(cur: *mut aws_byte_cursor, var: *mut u16) -> bool;
}
extern "C" {
    #[doc = " Reads an unsigned 24-bit value (3 bytes) in network byte order from cur,\n and places it in host byte order into 32-bit var.\n Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be24(cur: *mut aws_byte_cursor, var: *mut u32) -> bool;
}
extern "C" {
    #[doc = " Reads a 32-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be32(cur: *mut aws_byte_cursor, var: *mut u32) -> bool;
}
extern "C" {
    #[doc = " Reads a 64-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be64(cur: *mut aws_byte_cursor, var: *mut u64) -> bool;
}
extern "C" {
    #[doc = " Reads a 32-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_float_be32(cur: *mut aws_byte_cursor, var: *mut f32) -> bool;
}
extern "C" {
    #[doc = " Reads a 64-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_float_be64(cur: *mut aws_byte_cursor, var: *mut f64) -> bool;
}
extern "C" {
    #[doc = " Reads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number.\n Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'.\n For example: \"0F\" produces 15.\n\n On success, returns true and advances the cursor by 2.\n If there is insufficient space in the cursor or an invalid character\n is encountered, returns false, leaving the cursor unchanged."]
    pub fn aws_byte_cursor_read_hex_u8(cur: *mut aws_byte_cursor, var: *mut u8) -> bool;
}
extern "C" {
    #[doc = " Appends a sub-buffer to the specified buffer.\n\n If the buffer has at least `len' bytes remaining (buffer->capacity - buffer->len >= len),\n then buffer->len is incremented by len, and an aws_byte_buf is assigned to *output corresponding\n to the last len bytes of the input buffer. The aws_byte_buf at *output will have a null\n allocator, a zero initial length, and a capacity of 'len'. The function then returns true.\n\n If there is insufficient space, then this function nulls all fields in *output and returns\n false."]
    pub fn aws_byte_buf_advance(
        buffer: *mut aws_byte_buf,
        output: *mut aws_byte_buf,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Write specified number of bytes from array to byte buffer.\n\n On success, returns true and updates the buffer length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write(buf: *mut aws_byte_buf, src: *const u8, len: usize) -> bool;
}
extern "C" {
    #[doc = " Copies all bytes from buffer to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_from_whole_buffer(buf: *mut aws_byte_buf, src: aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Copies all bytes from buffer to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_from_whole_cursor(
        buf: *mut aws_byte_buf,
        src: aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Without increasing buf's capacity, write as much as possible from advancing_cursor into buf.\n\n buf's len is updated accordingly.\n advancing_cursor is advanced so it contains the remaining unwritten parts.\n Returns the section of advancing_cursor which was written.\n\n This function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length,\n then buf and advancing_cursor are not altered and a cursor with 0 length is returned.\n\n Example: Given a buf with 2 bytes of space available and advancing_cursor with contents \"abc\".\n \"ab\" will be written to buf and buf->len will increase 2 and become equal to buf->capacity.\n advancing_cursor will advance so its contents become the unwritten \"c\".\n The returned cursor's contents will be the \"ab\" from the original advancing_cursor."]
    pub fn aws_byte_buf_write_to_capacity(
        buf: *mut aws_byte_buf,
        advancing_cursor: *mut aws_byte_cursor,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Copies one byte to buffer.\n\n On success, returns true and updates the cursor /length\naccordingly.\n\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_u8(buf: *mut aws_byte_buf, c: u8) -> bool;
}
extern "C" {
    #[doc = " Writes one byte repeatedly to buffer (like memset)\n\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_u8_n(buf: *mut aws_byte_buf, c: u8, count: usize) -> bool;
}
extern "C" {
    #[doc = " Writes a 16-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be16(buf: *mut aws_byte_buf, x: u16) -> bool;
}
extern "C" {
    #[doc = " Writes low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer.\n Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes,\n returns false, leaving the buffer unchanged."]
    pub fn aws_byte_buf_write_be24(buf: *mut aws_byte_buf, x: u32) -> bool;
}
extern "C" {
    #[doc = " Writes a 32-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be32(buf: *mut aws_byte_buf, x: u32) -> bool;
}
extern "C" {
    #[doc = " Writes a 32-bit float in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_float_be32(buf: *mut aws_byte_buf, x: f32) -> bool;
}
extern "C" {
    #[doc = " Writes a 64-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be64(buf: *mut aws_byte_buf, x: u64) -> bool;
}
extern "C" {
    #[doc = " Writes a 64-bit float in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_float_be64(buf: *mut aws_byte_buf, x: f64) -> bool;
}
extern "C" {
    #[doc = " Like isalnum(), but ignores C locale.\n Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'."]
    pub fn aws_isalnum(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isalpha(), but ignores C locale.\n Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'."]
    pub fn aws_isalpha(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isdigit().\n Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.\n\n Note: C's built-in isdigit() is also supposed to ignore the C locale,\n but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage)\n may classify additional single-byte characters as digits\""]
    pub fn aws_isdigit(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isxdigit().\n Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.\n\n Note: C's built-in isxdigit() is also supposed to ignore the C locale,\n but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage)\n may classify additional single-byte characters as digits\""]
    pub fn aws_isxdigit(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isspace(), but ignores C locale.\n Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C),\n line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B)."]
    pub fn aws_isspace(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Read entire cursor as ASCII/UTF-8 unsigned base-10 number.\n Stricter than strtoull(), which allows whitespace and inputs that start with \"0x\"\n\n Examples:\n \"0\" -> 0\n \"123\" -> 123\n \"00004\" -> 4 // leading zeros ok\n\n Rejects things like:\n \"-1\" // negative numbers not allowed\n \"1,000\" // only characters 0-9 allowed\n \"\" // blank string not allowed\n \" 0 \" // whitespace not allowed\n \"0x0\" // hex not allowed\n \"FF\" // hex not allowed\n \"999999999999999999999999999999999999999999\" // larger than max u64"]
    pub fn aws_byte_cursor_utf8_parse_u64(
        cursor: aws_byte_cursor,
        dst: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read entire cursor as ASCII/UTF-8 unsigned base-16 number with NO \"0x\" prefix.\n\n Examples:\n \"F\" -> 15\n \"000000ff\" -> 255 // leading zeros ok\n \"Ff\" -> 255 // mixed case ok\n \"123\" -> 291\n \"FFFFFFFFFFFFFFFF\" -> 18446744073709551616 // max u64\n\n Rejects things like:\n \"0x0\" // 0x prefix not allowed\n \"\" // blank string not allowed\n \" F \" // whitespace not allowed\n \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" // larger than max u64"]
    pub fn aws_byte_cursor_utf8_parse_u64_hex(
        cursor: aws_byte_cursor,
        dst: *mut u64,
    ) -> ::std::os::raw::c_int;
}
pub const AWS_COMMON_HASH_TABLE_ITER_CONTINUE: _bindgen_ty_3 =
    _bindgen_ty_3::AWS_COMMON_HASH_TABLE_ITER_CONTINUE;
pub const AWS_COMMON_HASH_TABLE_ITER_DELETE: _bindgen_ty_3 =
    _bindgen_ty_3::AWS_COMMON_HASH_TABLE_ITER_DELETE;
pub const AWS_COMMON_HASH_TABLE_ITER_ERROR: _bindgen_ty_3 =
    _bindgen_ty_3::AWS_COMMON_HASH_TABLE_ITER_ERROR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    AWS_COMMON_HASH_TABLE_ITER_CONTINUE = 1,
    AWS_COMMON_HASH_TABLE_ITER_DELETE = 2,
    AWS_COMMON_HASH_TABLE_ITER_ERROR = 4,
}
#[doc = " Hash table data structure. This module provides an automatically resizing\n hash table implementation for general purpose use. The hash table stores a\n mapping between void * keys and values; it is expected that in most cases,\n these will point to a structure elsewhere in the heap, instead of inlining a\n key or value into the hash table element itself.\n\n Currently, this hash table implements a variant of robin hood hashing, but\n we do not guarantee that this won't change in the future.\n\n Associated with each hash function are four callbacks:\n\n   hash_fn - A hash function from the keys to a uint64_t. It is critical that\n      the hash function for a key does not change while the key is in the hash\n      table; violating this results in undefined behavior. Collisions are\n      tolerated, though naturally with reduced performance.\n\n   equals_fn - An equality comparison function. This function must be\n      reflexive and consistent with hash_fn.\n\n   destroy_key_fn, destroy_value_fn - Optional callbacks invoked when the\n      table is cleared or cleaned up and at the caller's option when an element\n      is removed from the table. Either or both may be set to NULL, which\n      has the same effect as a no-op destroy function.\n\n This datastructure can be safely moved between threads, subject to the\n requirements of the underlying allocator. It is also safe to invoke\n non-mutating operations on the hash table from multiple threads. A suitable\n memory barrier must be used when transitioning from single-threaded mutating\n usage to multithreaded usage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_table_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_table {
    pub p_impl: *mut hash_table_state,
}
#[test]
fn bindgen_test_layout_aws_hash_table() {
    const UNINIT: ::std::mem::MaybeUninit<aws_hash_table> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_hash_table>(),
        8usize,
        concat!("Size of: ", stringify!(aws_hash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_hash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_hash_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_impl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_table),
            "::",
            stringify!(p_impl)
        )
    );
}
#[doc = " Represents an element in the hash table. Various operations on the hash\n table may provide pointers to elements stored within the hash table;\n generally, calling code may alter value, but must not alter key (or any\n information used to compute key's hash code).\n\n Pointers to elements within the hash are invalidated whenever an operation\n which may change the number of elements in the hash is invoked (i.e. put,\n delete, clear, and clean_up), regardless of whether the number of elements\n actually changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_element {
    pub key: *const ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_hash_element() {
    const UNINIT: ::std::mem::MaybeUninit<aws_hash_element> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_hash_element>(),
        16usize,
        concat!("Size of: ", stringify!(aws_hash_element))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_hash_element>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_hash_element))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_element),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_element),
            "::",
            stringify!(value)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_hash_iter_status {
    AWS_HASH_ITER_STATUS_DONE = 0,
    AWS_HASH_ITER_STATUS_DELETE_CALLED = 1,
    AWS_HASH_ITER_STATUS_READY_FOR_USE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_iter {
    pub map: *const aws_hash_table,
    pub element: aws_hash_element,
    pub slot: usize,
    pub limit: usize,
    pub status: aws_hash_iter_status,
    pub unused_0: ::std::os::raw::c_int,
    pub unused_1: *mut ::std::os::raw::c_void,
    pub unused_2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_hash_iter() {
    const UNINIT: ::std::mem::MaybeUninit<aws_hash_iter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_hash_iter>(),
        64usize,
        concat!("Size of: ", stringify!(aws_hash_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_hash_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_hash_iter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused_0) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(unused_0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused_1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(unused_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused_2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(unused_2)
        )
    );
}
#[doc = " Prototype for a key hashing function pointer."]
pub type aws_hash_fn =
    ::std::option::Option<unsafe extern "C" fn(key: *const ::std::os::raw::c_void) -> u64>;
#[doc = " Prototype for a hash table equality check function pointer.\n\n This type is usually used for a function that compares two hash table\n keys, but note that the same type is used for a function that compares\n two hash table values in aws_hash_table_eq.\n\n Equality functions used in a hash table must be be reflexive (a == a),\n symmetric (a == b => b == a), transitive (a == b, b == c => a == c)\n and consistent (result does not change with time)."]
pub type aws_hash_callback_eq_fn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Prototype for a hash table key or value destructor function pointer.\n\n This function is used to destroy elements in the hash table when the\n table is cleared or cleaned up.\n\n Note that functions which remove individual elements from the hash\n table provide options of whether or not to invoke the destructors\n on the key and value of a removed element."]
pub type aws_hash_callback_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(key_or_value: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Initializes a hash map with initial capacity for 'size' elements\n without resizing. Uses hash_fn to compute the hash of each element.\n equals_fn to compute equality of two keys.  Whenever an element is\n removed without being returned, destroy_key_fn is run on the pointer\n to the key and destroy_value_fn is run on the pointer to the value.\n Either or both may be NULL if a callback is not desired in this case."]
    pub fn aws_hash_table_init(
        map: *mut aws_hash_table,
        alloc: *mut aws_allocator,
        size: usize,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deletes every element from map and frees all associated memory.\n destroy_fn will be called for each element.  aws_hash_table_init\n must be called before reusing the hash table.\n\n This method is idempotent."]
    pub fn aws_hash_table_clean_up(map: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Safely swaps two hash tables. Note that we swap the entirety of the hash\n table, including which allocator is associated.\n\n Neither hash table is required to be initialized; if one or both is\n uninitialized, then the uninitialized state is also swapped."]
    pub fn aws_hash_table_swap(a: *mut aws_hash_table, b: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Moves the hash table in 'from' to 'to'. After this move, 'from' will\n be identical to the state of the original 'to' hash table, and 'to'\n will be in the same state as if it had been passed to aws_hash_table_clean_up\n (that is, it will have no memory allocated, and it will be safe to\n either discard it or call aws_hash_table_clean_up again).\n\n Note that 'to' will not be cleaned up. You should make sure that 'to'\n is either uninitialized or cleaned up before moving a hashtable into\n it."]
    pub fn aws_hash_table_move(to: *mut aws_hash_table, from: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Returns the current number of entries in the table."]
    pub fn aws_hash_table_get_entry_count(map: *const aws_hash_table) -> usize;
}
extern "C" {
    #[doc = " Returns an iterator to be used for iterating through a hash table.\n Iterator will already point to the first element of the table it finds,\n which can be accessed as iter.element.\n\n This function cannot fail, but if there are no elements in the table,\n the returned iterator will return true for aws_hash_iter_done(&iter)."]
    pub fn aws_hash_iter_begin(map: *const aws_hash_table) -> aws_hash_iter;
}
extern "C" {
    #[doc = " Returns true if iterator is done iterating through table, false otherwise.\n If this is true, the iterator will not include an element of the table."]
    pub fn aws_hash_iter_done(iter: *const aws_hash_iter) -> bool;
}
extern "C" {
    #[doc = " Updates iterator so that it points to next element of hash table.\n\n This and the two previous functions are designed to be used together with\n the following idiom:\n\n for (struct aws_hash_iter iter = aws_hash_iter_begin(&map);\n      !aws_hash_iter_done(&iter); aws_hash_iter_next(&iter)) {\n     const key_type key = *(const key_type *)iter.element.key;\n     value_type value = *(value_type *)iter.element.value;\n     // etc.\n }\n\n Note that calling this on an iter which is \"done\" is idempotent:\n i.e. it will return another iter which is \"done\"."]
    pub fn aws_hash_iter_next(iter: *mut aws_hash_iter);
}
extern "C" {
    #[doc = " Deletes the element currently pointed-to by the hash iterator.\n After calling this method, the element member of the iterator\n should not be accessed until the next call to aws_hash_iter_next.\n\n @param destroy_contents If true, the destructors for the key and value\n  will be called."]
    pub fn aws_hash_iter_delete(iter: *mut aws_hash_iter, destroy_contents: bool);
}
extern "C" {
    #[doc = " Attempts to locate an element at key.  If the element is found, a\n pointer to the value is placed in *p_elem; if it is not found,\n *pElem is set to NULL. Either way, AWS_OP_SUCCESS is returned.\n\n This method does not change the state of the hash table. Therefore, it\n is safe to call _find from multiple threads on the same hash table,\n provided no mutating operations happen in parallel.\n\n Calling code may update the value in the hash table by modifying **pElem\n after a successful find. However, this pointer is not guaranteed to\n remain usable after a subsequent call to _put, _delete, _clear, or\n _clean_up."]
    pub fn aws_hash_table_find(
        map: *const aws_hash_table,
        key: *const ::std::os::raw::c_void,
        p_elem: *mut *mut aws_hash_element,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to locate an element at key. If no such element was found,\n creates a new element, with value initialized to NULL. In either case, a\n pointer to the element is placed in *p_elem.\n\n If was_created is non-NULL, *was_created is set to 0 if an existing\n element was found, or 1 is a new element was created.\n\n Returns AWS_OP_SUCCESS if an item was found or created.\n Raises AWS_ERROR_OOM if hash table expansion was required and memory\n allocation failed."]
    pub fn aws_hash_table_create(
        map: *mut aws_hash_table,
        key: *const ::std::os::raw::c_void,
        p_elem: *mut *mut aws_hash_element,
        was_created: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts a new element at key, with the given value. If another element\n exists at that key, the old element will be overwritten; both old key and\n value objects will be destroyed.\n\n If was_created is non-NULL, *was_created is set to 0 if an existing\n element was found, or 1 is a new element was created.\n\n Returns AWS_OP_SUCCESS if an item was found or created.\n Raises AWS_ERROR_OOM if hash table expansion was required and memory\n allocation failed."]
    pub fn aws_hash_table_put(
        map: *mut aws_hash_table,
        key: *const ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
        was_created: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes element at key. Always returns AWS_OP_SUCCESS.\n\n If pValue is non-NULL, the existing value (if any) is moved into\n (*value) before removing from the table, and destroy_fn is _not_\n invoked. If pValue is NULL, then (if the element existed) destroy_fn\n will be invoked on the element being removed.\n\n If was_present is non-NULL, it is set to 0 if the element was\n not present, or 1 if it was present (and is now removed)."]
    pub fn aws_hash_table_remove(
        map: *mut aws_hash_table,
        key: *const ::std::os::raw::c_void,
        p_value: *mut aws_hash_element,
        was_present: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes element already known (typically by find()).\n\n p_value should point to a valid element returned by create() or find().\n\n NOTE: DO NOT call this method from inside of a aws_hash_table_foreach callback, return\n AWS_COMMON_HASH_TABLE_ITER_DELETE instead."]
    pub fn aws_hash_table_remove_element(
        map: *mut aws_hash_table,
        p_value: *mut aws_hash_element,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterates through every element in the map and invokes the callback on\n that item. Iteration is performed in an arbitrary, implementation-defined\n order, and is not guaranteed to be consistent across invocations.\n\n The callback may change the value associated with the key by overwriting\n the value pointed-to by value. In this case, the on_element_removed\n callback will not be invoked, unless the callback invokes\n AWS_COMMON_HASH_TABLE_ITER_DELETE (in which case the on_element_removed\n is given the updated value).\n\n The callback must return a bitmask of zero or more of the following values\n ORed together:\n\n # AWS_COMMON_HASH_TABLE_ITER_CONTINUE - Continues iteration to the next\n     element (if not set, iteration stops)\n # AWS_COMMON_HASH_TABLE_ITER_DELETE   - Deletes the current value and\n     continues iteration.  destroy_fn will NOT be invoked.\n # AWS_COMMON_HASH_TABLE_ITER_ERROR   - Stop iteration with error.\n     No action will be taken for the current value and the value before this.\n     No rolling back. The deleted value before will NOT be back.\n     aws_hash_table_foreach returns AWS_OP_ERR after stropping the iteration.\n\n Invoking any method which may change the contents of the hashtable\n during iteration results in undefined behavior. However, you may safely\n invoke non-mutating operations during an iteration.\n\n This operation is mutating only if AWS_COMMON_HASH_TABLE_ITER_DELETE\n is returned at some point during iteration. Otherwise, it is non-mutating\n and is safe to invoke in parallel with other non-mutating operations."]
    pub fn aws_hash_table_foreach(
        map: *mut aws_hash_table,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut ::std::os::raw::c_void,
                p_element: *mut aws_hash_element,
            ) -> ::std::os::raw::c_int,
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two hash tables for equality. Both hash tables must have equivalent\n key comparators; values will be compared using the comparator passed into this\n function. The key hash function does not need to be equivalent between the\n two hash tables."]
    pub fn aws_hash_table_eq(
        a: *const aws_hash_table,
        b: *const aws_hash_table,
        value_eq: aws_hash_callback_eq_fn,
    ) -> bool;
}
extern "C" {
    #[doc = " Removes every element from the hash map. destroy_fn will be called for\n each element."]
    pub fn aws_hash_table_clear(map: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Convenience hash function for NULL-terminated C-strings"]
    pub fn aws_hash_c_string(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Convenience hash function for struct aws_strings.\n Hash is same as used on the string bytes by aws_hash_c_string."]
    pub fn aws_hash_string(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Convenience hash function for struct aws_byte_cursor.\n Hash is same as used on the string bytes by aws_hash_c_string."]
    pub fn aws_hash_byte_cursor_ptr(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Convenience hash function which hashes the pointer value directly,\n without dereferencing.  This can be used in cases where pointer identity\n is desired, or where a uintptr_t is encoded into a const void *."]
    pub fn aws_hash_ptr(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    pub fn aws_hash_combine(item1: u64, item2: u64) -> u64;
}
extern "C" {
    #[doc = " Convenience eq callback for NULL-terminated C-strings"]
    pub fn aws_hash_callback_c_str_eq(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience eq callback for AWS strings"]
    pub fn aws_hash_callback_string_eq(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience destroy callback for AWS strings"]
    pub fn aws_hash_callback_string_destroy(a: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Equality function which compares pointer equality."]
    pub fn aws_ptr_eq(a: *const ::std::os::raw::c_void, b: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Best-effort check of hash_table_state data-structure invariants"]
    pub fn aws_hash_table_is_valid(map: *const aws_hash_table) -> bool;
}
extern "C" {
    #[doc = " Given a pointer to a hash_iter, checks that it is well-formed, with all data-structure invariants."]
    pub fn aws_hash_iter_is_valid(iter: *const aws_hash_iter) -> bool;
}
extern "C" {
    #[doc = " Helper function to hash keys that are uint64_t values.\n\n The function is not a strong hash function in any sense; it merely reflects\n the uint64 value back.  Do not use this function as a hash if you need\n the properties of a strong hash function."]
    pub fn aws_hash_uint64_t_by_identity(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Helper function to compare hash keys that are uint64_t values."]
    pub fn aws_hash_compare_uint64_t_eq(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_list_node {
    pub next: *mut aws_linked_list_node,
    pub prev: *mut aws_linked_list_node,
}
#[test]
fn bindgen_test_layout_aws_linked_list_node() {
    const UNINIT: ::std::mem::MaybeUninit<aws_linked_list_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_linked_list_node>(),
        16usize,
        concat!("Size of: ", stringify!(aws_linked_list_node))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_linked_list_node>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_linked_list_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list_node),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_list {
    pub head: aws_linked_list_node,
    pub tail: aws_linked_list_node,
}
#[test]
fn bindgen_test_layout_aws_linked_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_linked_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_linked_list>(),
        32usize,
        concat!("Size of: ", stringify!(aws_linked_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_linked_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_linked_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list),
            "::",
            stringify!(tail)
        )
    );
}
#[doc = " Simple linked hash table. Preserves insertion order, and can be iterated in insertion order.\n\n You can also change the order safely without altering the shape of the underlying hash table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_hash_table {
    pub allocator: *mut aws_allocator,
    pub list: aws_linked_list,
    pub table: aws_hash_table,
    pub user_on_value_destroy: aws_hash_callback_destroy_fn,
    pub user_on_key_destroy: aws_hash_callback_destroy_fn,
}
#[test]
fn bindgen_test_layout_aws_linked_hash_table() {
    const UNINIT: ::std::mem::MaybeUninit<aws_linked_hash_table> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_linked_hash_table>(),
        64usize,
        concat!("Size of: ", stringify!(aws_linked_hash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_linked_hash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_linked_hash_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_on_value_destroy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table),
            "::",
            stringify!(user_on_value_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_on_key_destroy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table),
            "::",
            stringify!(user_on_key_destroy)
        )
    );
}
#[doc = " Linked-List node stored in the table. This is the node type that will be returned in\n aws_linked_hash_table_get_iteration_list()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_hash_table_node {
    pub node: aws_linked_list_node,
    pub table: *mut aws_linked_hash_table,
    pub key: *const ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_linked_hash_table_node() {
    const UNINIT: ::std::mem::MaybeUninit<aws_linked_hash_table_node> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_linked_hash_table_node>(),
        40usize,
        concat!("Size of: ", stringify!(aws_linked_hash_table_node))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_linked_hash_table_node>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_linked_hash_table_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table_node),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table_node),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_hash_table_node),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Initializes the table. Sets up the underlying hash table and linked list.\n For the other parameters, see aws/common/hash_table.h. Hash table\n semantics of these arguments are preserved."]
    pub fn aws_linked_hash_table_init(
        table: *mut aws_linked_hash_table,
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        initial_item_count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up the table. Elements in the table will be evicted and cleanup\n callbacks will be invoked."]
    pub fn aws_linked_hash_table_clean_up(table: *mut aws_linked_hash_table);
}
extern "C" {
    #[doc = " Finds element in the table by key. If found, AWS_OP_SUCCESS will be\n returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be\n NULL.\n\n If any errors occur AWS_OP_ERR will be returned."]
    pub fn aws_linked_hash_table_find(
        table: *mut aws_linked_hash_table,
        key: *const ::std::os::raw::c_void,
        p_value: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finds element in the table by key. If found, AWS_OP_SUCCESS will be returned and the item will be moved to the back\n of the list.\n If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\n Note: this will change the order of elements"]
    pub fn aws_linked_hash_table_find_and_move_to_back(
        table: *mut aws_linked_hash_table,
        key: *const ::std::os::raw::c_void,
        p_value: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Puts `p_value` at `key`. If an element is already stored at `key` it will be replaced."]
    pub fn aws_linked_hash_table_put(
        table: *mut aws_linked_hash_table,
        key: *const ::std::os::raw::c_void,
        p_value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes item at `key` from the table."]
    pub fn aws_linked_hash_table_remove(
        table: *mut aws_linked_hash_table,
        key: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clears all items from the table."]
    pub fn aws_linked_hash_table_clear(table: *mut aws_linked_hash_table);
}
extern "C" {
    #[doc = " returns number of elements in the table."]
    pub fn aws_linked_hash_table_get_element_count(table: *const aws_linked_hash_table) -> usize;
}
extern "C" {
    #[doc = " Move the aws_linked_hash_table_node to the end of the list.\n\n Note: this will change the order of elements"]
    pub fn aws_linked_hash_table_move_node_to_end_of_list(
        table: *mut aws_linked_hash_table,
        node: *mut aws_linked_hash_table_node,
    );
}
extern "C" {
    #[doc = " returns the underlying linked list for iteration.\n\n The returned list has nodes of the type: aws_linked_hash_table_node. Use AWS_CONTAINER_OF for access to the element."]
    pub fn aws_linked_hash_table_get_iteration_list(
        table: *const aws_linked_hash_table,
    ) -> *const aws_linked_list;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cache_vtable {
    pub destroy: ::std::option::Option<unsafe extern "C" fn(cache: *mut aws_cache)>,
    pub find: ::std::option::Option<
        unsafe extern "C" fn(
            cache: *mut aws_cache,
            key: *const ::std::os::raw::c_void,
            p_value: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub put: ::std::option::Option<
        unsafe extern "C" fn(
            cache: *mut aws_cache,
            key: *const ::std::os::raw::c_void,
            p_value: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(
            cache: *mut aws_cache,
            key: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub clear: ::std::option::Option<unsafe extern "C" fn(cache: *mut aws_cache)>,
    pub get_element_count:
        ::std::option::Option<unsafe extern "C" fn(cache: *const aws_cache) -> usize>,
}
#[test]
fn bindgen_test_layout_aws_cache_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_cache_vtable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_cache_vtable>(),
        48usize,
        concat!("Size of: ", stringify!(aws_cache_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_cache_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_cache_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache_vtable),
            "::",
            stringify!(find)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).put) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache_vtable),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache_vtable),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache_vtable),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_element_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache_vtable),
            "::",
            stringify!(get_element_count)
        )
    );
}
#[doc = " Base stucture for caches, used the linked hash table implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cache {
    pub allocator: *mut aws_allocator,
    pub vtable: *const aws_cache_vtable,
    pub table: aws_linked_hash_table,
    pub max_items: usize,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_cache() {
    const UNINIT: ::std::mem::MaybeUninit<aws_cache> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_cache>(),
        96usize,
        concat!("Size of: ", stringify!(aws_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_cache))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_items) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache),
            "::",
            stringify!(max_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cache),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    pub fn aws_cache_base_default_destroy(cache: *mut aws_cache);
}
extern "C" {
    pub fn aws_cache_base_default_find(
        cache: *mut aws_cache,
        key: *const ::std::os::raw::c_void,
        p_value: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cache_base_default_remove(
        cache: *mut aws_cache,
        key: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cache_base_default_clear(cache: *mut aws_cache);
}
extern "C" {
    pub fn aws_cache_base_default_get_element_count(cache: *const aws_cache) -> usize;
}
extern "C" {
    #[doc = " Cleans up the cache. Elements in the cache will be evicted and cleanup\n callbacks will be invoked."]
    pub fn aws_cache_destroy(cache: *mut aws_cache);
}
extern "C" {
    #[doc = " Finds element in the cache by key. If found, *p_value will hold the stored value, and AWS_OP_SUCCESS will be\n returned. If not found, AWS_OP_SUCCESS will be returned and *p_value will be NULL.\n\n If any errors occur AWS_OP_ERR will be returned."]
    pub fn aws_cache_find(
        cache: *mut aws_cache,
        key: *const ::std::os::raw::c_void,
        p_value: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Puts `p_value` at `key`. If an element is already stored at `key` it will be replaced. If the cache is already full,\n an item will be removed based on the cache policy."]
    pub fn aws_cache_put(
        cache: *mut aws_cache,
        key: *const ::std::os::raw::c_void,
        p_value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes item at `key` from the cache."]
    pub fn aws_cache_remove(
        cache: *mut aws_cache,
        key: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clears all items from the cache."]
    pub fn aws_cache_clear(cache: *mut aws_cache);
}
extern "C" {
    #[doc = " Returns the number of elements in the cache."]
    pub fn aws_cache_get_element_count(cache: *const aws_cache) -> usize;
}
#[repr(u32)]
#[doc = " The types use by APIs, not 1:1 with major type.\n It's an extension for cbor major type in RFC8949 section 3.1\n Major type 0 - AWS_CBOR_TYPE_UINT\n Major type 1 - AWS_CBOR_TYPE_NEGINT\n Major type 2 - AWS_CBOR_TYPE_BYTES/AWS_CBOR_TYPE_INDEF_BYTES_START\n Major type 3 - AWS_CBOR_TYPE_TEXT/AWS_CBOR_TYPE_INDEF_TEXT_START\n Major type 4 - AWS_CBOR_TYPE_ARRAY_START/AWS_CBOR_TYPE_INDEF_ARRAY_START\n Major type 5 - AWS_CBOR_TYPE_MAP_START/AWS_CBOR_TYPE_INDEF_MAP_START\n Major type 6 - AWS_CBOR_TYPE_TAG\n Major type 7\n  - 20/21 - AWS_CBOR_TYPE_BOOL\n  - 22 - AWS_CBOR_TYPE_NULL\n  - 23 - AWS_CBOR_TYPE_UNDEFINED\n  - 25/26/27 - AWS_CBOR_TYPE_FLOAT\n  - 31 - AWS_CBOR_TYPE_BREAK\n  - rest of value are not supported."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_cbor_type {
    AWS_CBOR_TYPE_UNKNOWN = 0,
    AWS_CBOR_TYPE_UINT = 1,
    AWS_CBOR_TYPE_NEGINT = 2,
    AWS_CBOR_TYPE_FLOAT = 3,
    AWS_CBOR_TYPE_BYTES = 4,
    AWS_CBOR_TYPE_TEXT = 5,
    AWS_CBOR_TYPE_ARRAY_START = 6,
    AWS_CBOR_TYPE_MAP_START = 7,
    AWS_CBOR_TYPE_TAG = 8,
    AWS_CBOR_TYPE_BOOL = 9,
    AWS_CBOR_TYPE_NULL = 10,
    AWS_CBOR_TYPE_UNDEFINED = 11,
    AWS_CBOR_TYPE_BREAK = 12,
    AWS_CBOR_TYPE_INDEF_BYTES_START = 13,
    AWS_CBOR_TYPE_INDEF_TEXT_START = 14,
    AWS_CBOR_TYPE_INDEF_ARRAY_START = 15,
    AWS_CBOR_TYPE_INDEF_MAP_START = 16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cbor_encoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cbor_decoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " ENCODE"]
    pub fn aws_cbor_type_cstr(type_: aws_cbor_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create a new cbor encoder. Creating a encoder with a temporay buffer.\n Every aws_cbor_encoder_write_* will encode directly into the buffer to follow the encoded data.\n\n @param allocator\n @return aws_cbor_encoder"]
    pub fn aws_cbor_encoder_new(allocator: *mut aws_allocator) -> *mut aws_cbor_encoder;
}
extern "C" {
    pub fn aws_cbor_encoder_destroy(encoder: *mut aws_cbor_encoder) -> *mut aws_cbor_encoder;
}
extern "C" {
    #[doc = " @brief Get the current encoded data from encoder. The encoded data has the same lifetime as the encoder, and once\n any other function call invoked for the encoder, the encoded data is no longer valid.\n\n @param encoder\n @return struct aws_byte_cursor from the encoder buffer."]
    pub fn aws_cbor_encoder_get_encoded_data(encoder: *const aws_cbor_encoder) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " @brief Clear the current encoded buffer from encoder.\n\n @param encoder"]
    pub fn aws_cbor_encoder_reset(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_UINT value to \"smallest possible\" in encoder's buffer.\n  Referring to RFC8949 section 4.2.1\n\n TODO: maybe add a width of the encoded value.\n\n @param encoder\n @param value value to encode."]
    pub fn aws_cbor_encoder_write_uint(encoder: *mut aws_cbor_encoder, value: u64);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_NEGINT value to \"smallest possible\" in encoder's buffer.\n It represents (-1 - value).\n  Referring to RFC8949 section 4.2.1\n\n\n @param encoder\n @param value The argument to encode to negative integer, which is (-1 - expected_val)"]
    pub fn aws_cbor_encoder_write_negint(encoder: *mut aws_cbor_encoder, value: u64);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_FLOAT value to \"smallest possible\", but will not be encoded into half-precision float,\n as it's not well supported cross languages.\n\n To be more specific, it will be encoded into integer/negative/float\n (Order with priority) when the conversation will not cause precision loss.\n\n @param encoder\n @param value value to encode."]
    pub fn aws_cbor_encoder_write_float(encoder: *mut aws_cbor_encoder, value: f64);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_BYTES value to \"smallest possible\" in encoder's buffer.\n  Referring to RFC8949 section 4.2.1, the length of \"from\" will be encoded first and then the value of \"from\" will\n be followed.\n\n @param encoder\n @param from value to encode."]
    pub fn aws_cbor_encoder_write_bytes(encoder: *mut aws_cbor_encoder, from: aws_byte_cursor);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_TEXT value to \"smallest possible\" in encoder's buffer.\n  Referring to RFC8949 section 4.2.1, the length of \"from\" will be encoded first and then the value of \"from\" will\n be followed.\n\n @param encoder\n @param from value to encode."]
    pub fn aws_cbor_encoder_write_text(encoder: *mut aws_cbor_encoder, from: aws_byte_cursor);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_ARRAY_START value to \"smallest possible\" in encoder's buffer.\n  Referring to RFC8949 section 4.2.1\n  The \"number_entries\" is the cbor data items should be followed as the content of the array.\n Notes: it's user's responsibility to keep the integrity of the array to be encoded.\n\n @param encoder\n @param number_entries The number of data item in array."]
    pub fn aws_cbor_encoder_write_array_start(
        encoder: *mut aws_cbor_encoder,
        number_entries: usize,
    );
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_MAP_START value to \"smallest possible\" in encoder's buffer.\n  Referring to RFC8949 section 4.2.1\n  The \"number_entries\" is the number of pair of cbor data items as key and value should be followed as the content of\n the map.\n\n Notes: it's user's responsibility to keep the integrity of the map to be encoded.\n\n @param encoder\n @param number_entries The number of data item in map."]
    pub fn aws_cbor_encoder_write_map_start(encoder: *mut aws_cbor_encoder, number_entries: usize);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_TAG value to \"smallest possible\" in encoder's buffer.\n  Referring to RFC8949 section 4.2.1\n The following cbor data item will be the content of the tagged value.\n Notes: it's user's responsibility to keep the integrity of the tagged value to follow the RFC8949 section 3.4\n\n @param encoder\n @param tag_number The tag value to encode."]
    pub fn aws_cbor_encoder_write_tag(encoder: *mut aws_cbor_encoder, tag_number: u64);
}
extern "C" {
    #[doc = " @brief Encode a simple value AWS_CBOR_TYPE_NULL\n\n @param encoder"]
    pub fn aws_cbor_encoder_write_null(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a simple value AWS_CBOR_TYPE_UNDEFINED\n\n @param encoder"]
    pub fn aws_cbor_encoder_write_undefined(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a simple value AWS_CBOR_TYPE_BOOL\n\n @param encoder"]
    pub fn aws_cbor_encoder_write_bool(encoder: *mut aws_cbor_encoder, value: bool);
}
extern "C" {
    #[doc = " @brief Encode a simple value AWS_CBOR_TYPE_BREAK\n\n Notes: no error checking, it's user's responsibility to track the break\n to close the corresponding indef_start"]
    pub fn aws_cbor_encoder_write_break(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_INDEF_BYTES_START\n\n Notes: no error checking, it's user's responsibility to add corresponding data and the break\n to close the indef_start"]
    pub fn aws_cbor_encoder_write_indef_bytes_start(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_INDEF_TEXT_START\n\n Notes: no error checking, it's user's responsibility to add corresponding data\n and the break to close the indef_start"]
    pub fn aws_cbor_encoder_write_indef_text_start(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_INDEF_ARRAY_START\n\n Notes: no error checking, it's user's responsibility to add corresponding data\n and the break to close the indef_start"]
    pub fn aws_cbor_encoder_write_indef_array_start(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Encode a AWS_CBOR_TYPE_INDEF_MAP_START\n\n Notes: no error checking, it's user's responsibility to add corresponding data\n and the break to close the indef_start"]
    pub fn aws_cbor_encoder_write_indef_map_start(encoder: *mut aws_cbor_encoder);
}
extern "C" {
    #[doc = " @brief Create a cbor decoder to take src to decode.\n The typical usage of decoder will be:\n - If the next element type only accept what expected, `aws_cbor_decoder_pop_next_*`\n - If the next element type accept different type, invoke `aws_cbor_decoder_peek_type` first, then based on the type\n to invoke corresponding `aws_cbor_decoder_pop_next_*`\n - If the next element type doesn't have corrsponding value, specifically: AWS_CBOR_TYPE_NULL,\n AWS_CBOR_TYPE_UNDEFINED, AWS_CBOR_TYPE_INF_*_START, AWS_CBOR_TYPE_BREAK, call\n `aws_cbor_decoder_consume_next_single_element` to consume it and continues for further decoding.\n - To ignore the next data item (the element and the content of it), `aws_cbor_decoder_consume_next_whole_data_item`\n\n Note: it's caller's responsibilty to keep the src outlive the decoder.\n\n @param allocator\n @param src   The src data to decode from.\n @return decoder"]
    pub fn aws_cbor_decoder_new(
        allocator: *mut aws_allocator,
        src: aws_byte_cursor,
    ) -> *mut aws_cbor_decoder;
}
extern "C" {
    pub fn aws_cbor_decoder_destroy(decoder: *mut aws_cbor_decoder) -> *mut aws_cbor_decoder;
}
extern "C" {
    #[doc = " @brief  Get the length of the remaining bytes of the source. Once the source was decoded, it will be consumed,\n and result in decrease of the remaining length of bytes.\n\n @param decoder\n @return The length of bytes remaining of the decoder source."]
    pub fn aws_cbor_decoder_get_remaining_length(decoder: *const aws_cbor_decoder) -> usize;
}
extern "C" {
    #[doc = " @brief Decode the next element and store it in the decoder cache if there was no element cached.\n If there was element cached, just return the type of the cached element.\n\n @param decoder\n @param out_type\n @return AWS_OP_SUCCESS if succeed, AWS_OP_ERR for any decoding error and corresponding error code will be raised."]
    pub fn aws_cbor_decoder_peek_type(
        decoder: *mut aws_cbor_decoder,
        out_type: *mut aws_cbor_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Consume the next data item, includes all the content within the data item.\n\n As an example for the following cbor, this function will consume all the data\n as it's only one cbor data item, an indefinite map with 2 key, value pair:\n 0xbf6346756ef563416d7421ff\n BF           -- Start indefinite-length map\n   63        -- First key, UTF-8 string length 3\n      46756e --   \"Fun\"\n   F5        -- First value, true\n   63        -- Second key, UTF-8 string length 3\n      416d74 --   \"Amt\"\n   21        -- Second value, -2\n   FF        -- \"break\"\n\n Notes: this function will not ensure the data item is well-formed.\n\n @param src The src to parse data from\n @return AWS_OP_SUCCESS successfully consumed the next data item, otherwise AWS_OP_ERR."]
    pub fn aws_cbor_decoder_consume_next_whole_data_item(
        decoder: *mut aws_cbor_decoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Consume the next single element, without the content followed by the element.\n\n As an example for the following cbor, this function will only consume the\n 0xBF, \"Start indefinite-length map\", not any content of the map represented.\n The next element to decode will start from 0x63\n 0xbf6346756ef563416d7421ff\n BF           -- Start indefinite-length map\n   63        -- First key, UTF-8 string length 3\n      46756e --   \"Fun\"\n   F5        -- First value, true\n   63        -- Second key, UTF-8 string length 3\n      416d74 --   \"Amt\"\n   21        -- Second value, -2\n   FF        -- \"break\"\n\n @param decoder The decoder to parse data from\n @return AWS_OP_SUCCESS successfully consumed the next element, otherwise AWS_OP_ERR."]
    pub fn aws_cbor_decoder_consume_next_single_element(
        decoder: *mut aws_cbor_decoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the next element based on the type. If the next element doesn't match the expected type. Error will be\n raised. If the next element already been cached, it will consume the cached item when no error was returned.\n Specifically:\n  AWS_CBOR_TYPE_UINT - aws_cbor_decoder_pop_next_unsigned_int_val\n  AWS_CBOR_TYPE_NEGINT - aws_cbor_decoder_pop_next_negative_int_val, it represents (-1 - *out)\n  AWS_CBOR_TYPE_FLOAT - aws_cbor_decoder_pop_next_double_val\n  AWS_CBOR_TYPE_BYTES - aws_cbor_decoder_pop_next_bytes_val\n  AWS_CBOR_TYPE_TEXT - aws_cbor_decoder_pop_next_text_val\n\n @param decoder\n @param out\n @return AWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR."]
    pub fn aws_cbor_decoder_pop_next_unsigned_int_val(
        decoder: *mut aws_cbor_decoder,
        out: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cbor_decoder_pop_next_negative_int_val(
        decoder: *mut aws_cbor_decoder,
        out: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cbor_decoder_pop_next_float_val(
        decoder: *mut aws_cbor_decoder,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cbor_decoder_pop_next_boolean_val(
        decoder: *mut aws_cbor_decoder,
        out: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cbor_decoder_pop_next_bytes_val(
        decoder: *mut aws_cbor_decoder,
        out: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_cbor_decoder_pop_next_text_val(
        decoder: *mut aws_cbor_decoder,
        out: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the next AWS_CBOR_TYPE_ARRAY_START element. Only consume the AWS_CBOR_TYPE_ARRAY_START element and set the\n size of array to *out_size, not the content of the array. The next *out_size cbor data items will be the content of\n the array for a valid cbor data,\n\n Notes: For indefinite-length, this function will fail with \"AWS_ERROR_CBOR_UNEXPECTED_TYPE\". The designed way to\n handle indefinite-length is:\n - Get AWS_CBOR_TYPE_INDEF_ARRAY_START from _peek_type\n - call `aws_cbor_decoder_consume_next_single_element` to pop the indefinite-length start.\n - Decode the next data item until AWS_CBOR_TYPE_BREAK read.\n\n @param decoder\n @param out_size store the size of array if succeed.\n @return AWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR."]
    pub fn aws_cbor_decoder_pop_next_array_start(
        decoder: *mut aws_cbor_decoder,
        out_size: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the next AWS_CBOR_TYPE_MAP_START element. Only consume the AWS_CBOR_TYPE_MAP_START element and set the\n size of array to *out_size, not the content of the map. The next *out_size pair of cbor data items as key and value\n will be the content of the array for a valid cbor data,\n\n Notes: For indefinite-length, this function will fail with \"AWS_ERROR_CBOR_UNEXPECTED_TYPE\". The designed way to\n handle indefinite-length is:\n - Get AWS_CBOR_TYPE_INDEF_MAP_START from _peek_type\n - call `aws_cbor_decoder_consume_next_single_element` to pop the indefinite-length start.\n - Decode the next data item until AWS_CBOR_TYPE_BREAK read.\n\n @param decoder\n @param out_size store the size of map if succeed.\n @return AWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR."]
    pub fn aws_cbor_decoder_pop_next_map_start(
        decoder: *mut aws_cbor_decoder,
        out_size: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the next AWS_CBOR_TYPE_TAG element. Only consume the AWS_CBOR_TYPE_TAG element and set the\n tag value to *out_tag_val, not the content of the tagged. The next cbor data item will be the content of the tagged\n value for a valid cbor data.\n\n @param decoder\n @param out_size store the size of map if succeed.\n @return AWS_OP_SUCCESS successfully consumed the next element and get the result, otherwise AWS_OP_ERR."]
    pub fn aws_cbor_decoder_pop_next_tag_val(
        decoder: *mut aws_cbor_decoder,
        out_tag_val: *mut u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_timestamp_unit {
    AWS_TIMESTAMP_SECS = 1,
    AWS_TIMESTAMP_MILLIS = 1000,
    AWS_TIMESTAMP_MICROS = 1000000,
    AWS_TIMESTAMP_NANOS = 1000000000,
}
extern "C" {
    #[doc = " Get ticks in nanoseconds (usually 100 nanosecond precision) on the high resolution clock (most-likely TSC). This\n clock has no bearing on the actual system time. On success, timestamp will be set."]
    pub fn aws_high_res_clock_get_ticks(timestamp: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get ticks in nanoseconds (usually 100 nanosecond precision) on the system clock. Reflects actual system time via\n nanoseconds since unix epoch. Use with care since an inaccurately set clock will probably cause bugs. On success,\n timestamp will be set."]
    pub fn aws_sys_clock_get_ticks(timestamp: *mut u64) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_cli_options_has_arg {
    AWS_CLI_OPTIONS_NO_ARGUMENT = 0,
    AWS_CLI_OPTIONS_REQUIRED_ARGUMENT = 1,
    AWS_CLI_OPTIONS_OPTIONAL_ARGUMENT = 2,
}
#[doc = " Invoked when a subcommand is encountered. argc and argv[] begins at the command encountered.\n command_name is the name of the command being handled."]
pub type aws_cli_options_subcommand_fn = ::std::option::Option<
    unsafe extern "C" fn(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        command_name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dispatch table to dispatch cli commands from.\n command_name should be the exact string for the command you want to handle from the command line."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cli_subcommand_dispatch {
    pub subcommand_fn: aws_cli_options_subcommand_fn,
    pub command_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aws_cli_subcommand_dispatch() {
    const UNINIT: ::std::mem::MaybeUninit<aws_cli_subcommand_dispatch> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_cli_subcommand_dispatch>(),
        16usize,
        concat!("Size of: ", stringify!(aws_cli_subcommand_dispatch))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_cli_subcommand_dispatch>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_cli_subcommand_dispatch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subcommand_fn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cli_subcommand_dispatch),
            "::",
            stringify!(subcommand_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cli_subcommand_dispatch),
            "::",
            stringify!(command_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cli_option {
    pub name: *const ::std::os::raw::c_char,
    pub has_arg: aws_cli_options_has_arg,
    pub flag: *mut ::std::os::raw::c_int,
    pub val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_aws_cli_option() {
    const UNINIT: ::std::mem::MaybeUninit<aws_cli_option> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_cli_option>(),
        32usize,
        concat!("Size of: ", stringify!(aws_cli_option))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_cli_option>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_cli_option))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cli_option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cli_option),
            "::",
            stringify!(has_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cli_option),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cli_option),
            "::",
            stringify!(val)
        )
    );
}
extern "C" {
    #[doc = " Initialized to 1 (for where the first argument would be). As arguments are parsed, this number is the index\n of the next argument to parse. Reset this to 1 to parse another set of arguments, or to rerun the parser."]
    pub static mut aws_cli_optind: ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If an option has an argument, when the option is encountered, this will be set to the argument portion."]
    pub static mut aws_cli_optarg: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " If 0x02 was returned by aws_cli_getopt_long(), this value will be set to the argument encountered."]
    pub static mut aws_cli_positional_arg: *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " A mostly compliant implementation of posix getopt_long(). Parses command-line arguments. argc is the number of\n command line arguments passed in argv. optstring contains the legitimate option characters. The option characters\n correspond to aws_cli_option::val. If the character is followed by a :, the option requires an argument. If it is\n followed by '::', the argument is optional (not implemented yet).\n\n  longopts, is an array of struct aws_cli_option. These are the allowed options for the program.\n  The last member of the array must be zero initialized.\n\n  If longindex is non-null, it will be set to the index in longopts, for the found option.\n\n  Returns option val if it was found, '?' if an option was encountered that was not specified in the option string,\n 0x02 (START_OF_TEXT) will be returned if a positional argument was encountered. returns -1 when all arguments that\n can be parsed have been parsed."]
    pub fn aws_cli_getopt_long(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        optstring: *const ::std::os::raw::c_char,
        longopts: *const aws_cli_option,
        longindex: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resets global parser state for use in another parser run for the application."]
    pub fn aws_cli_reset_state();
}
extern "C" {
    #[doc = " Dispatches the current command line arguments with a subcommand from the second input argument in argv[], if\n dispatch table contains a command that matches the argument. When the command is dispatched, argc and argv will be\n updated to reflect the new argument count. The cli options are required to come after the subcommand. If either, no\n dispatch was found or there was no argument passed to the program, this function will return AWS_OP_ERR. Check\n aws_last_error() for details on the error.\n @param argc number of arguments passed to int main()\n @param argv the arguments passed to int main()\n @param parse_cb, optional, specify NULL if you don't want to handle this. This argument is for parsing \"meta\"\n commands from the command line options prior to dispatch occurring.\n @param dispatch_table table containing functions and command name to dispatch on.\n @param table_length number of entries in dispatch_table.\n @return AWS_OP_SUCCESS(0) on success, AWS_OP_ERR(-1) on failure"]
    pub fn aws_cli_dispatch_on_subcommand(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        dispatch_table: *mut aws_cli_subcommand_dispatch,
        table_length: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_4 = _bindgen_ty_4::QOS_CLASS_USER_INTERACTIVE;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_4 = _bindgen_ty_4::QOS_CLASS_USER_INITIATED;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_4 = _bindgen_ty_4::QOS_CLASS_DEFAULT;
pub const QOS_CLASS_UTILITY: _bindgen_ty_4 = _bindgen_ty_4::QOS_CLASS_UTILITY;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_4 = _bindgen_ty_4::QOS_CLASS_BACKGROUND;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_4 = _bindgen_ty_4::QOS_CLASS_UNSPECIFIED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    QOS_CLASS_USER_INTERACTIVE = 33,
    QOS_CLASS_USER_INITIATED = 25,
    QOS_CLASS_DEFAULT = 21,
    QOS_CLASS_UTILITY = 17,
    QOS_CLASS_BACKGROUND = 9,
    QOS_CLASS_UNSPECIFIED = 0,
}
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut usize) -> ::std::os::raw::c_int;
}
pub type aws_condition_predicate_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_condition_variable {
    pub condition_handle: pthread_cond_t,
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_aws_condition_variable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_condition_variable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_condition_variable>(),
        56usize,
        concat!("Size of: ", stringify!(aws_condition_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_condition_variable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_condition_variable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).condition_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_condition_variable),
            "::",
            stringify!(condition_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_condition_variable),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " Initializes a condition variable."]
    pub fn aws_condition_variable_init(
        condition_variable: *mut aws_condition_variable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up a condition variable."]
    pub fn aws_condition_variable_clean_up(condition_variable: *mut aws_condition_variable);
}
extern "C" {
    #[doc = " Notifies/Wakes one waiting thread"]
    pub fn aws_condition_variable_notify_one(
        condition_variable: *mut aws_condition_variable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Notifies/Wakes all waiting threads."]
    pub fn aws_condition_variable_notify_all(
        condition_variable: *mut aws_condition_variable,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits the calling thread on a notification from another thread."]
    pub fn aws_condition_variable_wait(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits the calling thread on a notification from another thread. If predicate returns false, the wait is reentered,\n otherwise control returns to the caller."]
    pub fn aws_condition_variable_wait_pred(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
        pred: aws_condition_predicate_fn,
        pred_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in\n nanoseconds."]
    pub fn aws_condition_variable_wait_for(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
        time_to_wait: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits the calling thread on a notification from another thread. Times out after time_to_wait. time_to_wait is in\n nanoseconds. If predicate returns false, the wait is reentered, otherwise control returns to the caller."]
    pub fn aws_condition_variable_wait_for_pred(
        condition_variable: *mut aws_condition_variable,
        mutex: *mut aws_mutex,
        time_to_wait: i64,
        pred: aws_condition_predicate_fn,
        pred_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_cpu_feature_name {
    AWS_CPU_FEATURE_CLMUL = 0,
    AWS_CPU_FEATURE_SSE_4_1 = 1,
    AWS_CPU_FEATURE_SSE_4_2 = 2,
    AWS_CPU_FEATURE_AVX2 = 3,
    AWS_CPU_FEATURE_AVX512 = 4,
    AWS_CPU_FEATURE_ARM_CRC = 5,
    AWS_CPU_FEATURE_BMI2 = 6,
    AWS_CPU_FEATURE_VPCLMULQDQ = 7,
    AWS_CPU_FEATURE_ARM_PMULL = 8,
    AWS_CPU_FEATURE_ARM_CRYPTO = 9,
    AWS_CPU_FEATURE_COUNT = 10,
}
extern "C" {
    #[doc = " Returns true if a cpu feature is supported, false otherwise."]
    pub fn aws_cpu_has_feature(feature_name: aws_cpu_feature_name) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cross_process_lock {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Attempts to acquire a system-wide (not per process or per user) lock scoped by instance_nonce.\n For any given unique nonce, a lock will be returned by the first caller. Subsequent calls will\n return NULL and raise AWS_ERROR_MUTEX_CALLER_NOT_OWNER\n until the either the process owning the lock exits or the program owning the lock\n calls aws_cross_process_lock_release() explicitly.\n\n If the process exits before the lock is released, the kernel will unlock it for the next consumer."]
    pub fn aws_cross_process_lock_try_acquire(
        allocator: *mut aws_allocator,
        instance_nonce: aws_byte_cursor,
    ) -> *mut aws_cross_process_lock;
}
extern "C" {
    #[doc = " Releases the lock so the next caller (may be another process) can get an instance of the lock."]
    pub fn aws_cross_process_lock_release(instance_lock: *mut aws_cross_process_lock);
}
pub const AWS_DATE_TIME_STR_MAX_LEN: _bindgen_ty_5 = _bindgen_ty_5::AWS_DATE_TIME_STR_MAX_LEN;
pub const AWS_DATE_TIME_STR_MAX_BASIC_LEN: _bindgen_ty_5 =
    _bindgen_ty_5::AWS_DATE_TIME_STR_MAX_BASIC_LEN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    AWS_DATE_TIME_STR_MAX_LEN = 100,
    AWS_DATE_TIME_STR_MAX_BASIC_LEN = 20,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_date_format {
    AWS_DATE_FORMAT_RFC822 = 0,
    AWS_DATE_FORMAT_ISO_8601 = 1,
    AWS_DATE_FORMAT_ISO_8601_BASIC = 2,
    AWS_DATE_FORMAT_AUTO_DETECT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_date_month {
    AWS_DATE_MONTH_JANUARY = 0,
    AWS_DATE_MONTH_FEBRUARY = 1,
    AWS_DATE_MONTH_MARCH = 2,
    AWS_DATE_MONTH_APRIL = 3,
    AWS_DATE_MONTH_MAY = 4,
    AWS_DATE_MONTH_JUNE = 5,
    AWS_DATE_MONTH_JULY = 6,
    AWS_DATE_MONTH_AUGUST = 7,
    AWS_DATE_MONTH_SEPTEMBER = 8,
    AWS_DATE_MONTH_OCTOBER = 9,
    AWS_DATE_MONTH_NOVEMBER = 10,
    AWS_DATE_MONTH_DECEMBER = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_date_day_of_week {
    AWS_DATE_DAY_OF_WEEK_SUNDAY = 0,
    AWS_DATE_DAY_OF_WEEK_MONDAY = 1,
    AWS_DATE_DAY_OF_WEEK_TUESDAY = 2,
    AWS_DATE_DAY_OF_WEEK_WEDNESDAY = 3,
    AWS_DATE_DAY_OF_WEEK_THURSDAY = 4,
    AWS_DATE_DAY_OF_WEEK_FRIDAY = 5,
    AWS_DATE_DAY_OF_WEEK_SATURDAY = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_date_time {
    pub timestamp: time_t,
    pub milliseconds: u16,
    pub tz: [::std::os::raw::c_char; 6usize],
    pub gmt_time: tm,
    pub local_time: tm,
    pub utc_assumed: bool,
}
#[test]
fn bindgen_test_layout_aws_date_time() {
    const UNINIT: ::std::mem::MaybeUninit<aws_date_time> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_date_time>(),
        136usize,
        concat!("Size of: ", stringify!(aws_date_time))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_date_time>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_date_time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_date_time),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).milliseconds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_date_time),
            "::",
            stringify!(milliseconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_date_time),
            "::",
            stringify!(tz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gmt_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_date_time),
            "::",
            stringify!(gmt_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_time) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_date_time),
            "::",
            stringify!(local_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utc_assumed) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_date_time),
            "::",
            stringify!(utc_assumed)
        )
    );
}
extern "C" {
    #[doc = " Initializes dt to be the current system time."]
    pub fn aws_date_time_init_now(dt: *mut aws_date_time);
}
extern "C" {
    #[doc = " Initializes dt to be the time represented in milliseconds since unix epoch."]
    pub fn aws_date_time_init_epoch_millis(dt: *mut aws_date_time, ms_since_epoch: u64);
}
extern "C" {
    #[doc = " Initializes dt to be the time represented in seconds.millis since unix epoch."]
    pub fn aws_date_time_init_epoch_secs(dt: *mut aws_date_time, sec_ms: f64);
}
extern "C" {
    #[doc = " Initializes dt to be the time represented by date_str in format 'fmt'. Returns AWS_OP_SUCCESS if the\n string was successfully parsed, returns  AWS_OP_ERR if parsing failed.\n\n The parser is lenient regarding AWS_DATE_FORMAT_ISO_8601 vs AWS_DATE_FORMAT_ISO_8601_BASIC.\n Regardless of which you pass in, both \"2002-10-02T08:05:09Z\" and \"20021002T080509Z\" would be accepted.\n\n Notes for AWS_DATE_FORMAT_RFC822:\n If no time zone information is provided, it is assumed to be local time (please don't do this).\n\n Only time zones indicating Universal Time (e.g. Z, UT, UTC, or GMT),\n or offsets from UTC (e.g. +0100, -0700), are accepted.\n\n Really, it's just better if you always use Universal Time."]
    pub fn aws_date_time_init_from_str(
        dt: *mut aws_date_time,
        date_str: *const aws_byte_buf,
        fmt: aws_date_format,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " aws_date_time_init variant that takes a byte_cursor rather than a byte_buf"]
    pub fn aws_date_time_init_from_str_cursor(
        dt: *mut aws_date_time,
        date_str_cursor: *const aws_byte_cursor,
        fmt: aws_date_format,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the current time as a formatted date string in local time into output_buf. If buffer is too small, it will\n return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_local_time_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the current time as a formatted date string in utc time into output_buf. If buffer is too small, it will\n return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_utc_time_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the current time as a formatted short date string in local time into output_buf. If buffer is too small, it\n will return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_local_time_short_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the current time as a formatted short date string in utc time into output_buf. If buffer is too small, it will\n return AWS_OP_ERR. A good size suggestion is AWS_DATE_TIME_STR_MAX_LEN bytes. AWS_DATE_FORMAT_AUTO_DETECT is not\n allowed."]
    pub fn aws_date_time_to_utc_time_short_str(
        dt: *const aws_date_time,
        fmt: aws_date_format,
        output_buf: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_date_time_as_epoch_secs(dt: *const aws_date_time) -> f64;
}
extern "C" {
    pub fn aws_date_time_as_nanos(dt: *const aws_date_time) -> u64;
}
extern "C" {
    pub fn aws_date_time_as_millis(dt: *const aws_date_time) -> u64;
}
extern "C" {
    pub fn aws_date_time_year(dt: *const aws_date_time, local_time: bool) -> u16;
}
extern "C" {
    pub fn aws_date_time_month(dt: *const aws_date_time, local_time: bool) -> aws_date_month;
}
extern "C" {
    pub fn aws_date_time_month_day(dt: *const aws_date_time, local_time: bool) -> u8;
}
extern "C" {
    pub fn aws_date_time_day_of_week(
        dt: *const aws_date_time,
        local_time: bool,
    ) -> aws_date_day_of_week;
}
extern "C" {
    pub fn aws_date_time_hour(dt: *const aws_date_time, local_time: bool) -> u8;
}
extern "C" {
    pub fn aws_date_time_minute(dt: *const aws_date_time, local_time: bool) -> u8;
}
extern "C" {
    pub fn aws_date_time_second(dt: *const aws_date_time, local_time: bool) -> u8;
}
extern "C" {
    pub fn aws_date_time_dst(dt: *const aws_date_time, local_time: bool) -> bool;
}
extern "C" {
    #[doc = " returns the difference of a and b (a - b) in seconds."]
    pub fn aws_date_time_diff(a: *const aws_date_time, b: *const aws_date_time) -> time_t;
}
extern "C" {
    #[doc = " Get an unpredictably random 64bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u64(output: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an unpredictably random 32bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u32(output: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an unpredictably random 16bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u16(output: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an unpredictably random 8bit number, suitable for cryptographic use."]
    pub fn aws_device_random_u8(output: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill the rest of a buffer with unpredictably random bytes, suitable for cryptographic use."]
    pub fn aws_device_random_buffer(output: *mut aws_byte_buf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write N unpredictably random bytes to a buffer, suitable for cryptographic use.\n If there is insufficient space in the buffer, AWS_ERROR_SHORT_BUFFER is raised\n and the buffer will be unchanged."]
    pub fn aws_device_random_buffer_append(
        output: *mut aws_byte_buf,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_hex_compute_encoded_len(
        to_encode_len: usize,
        encoded_length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_hex_encode(
        to_encode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_hex_encode_append_dynamic(
        to_encode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_hex_compute_decoded_len(
        to_decode_len: usize,
        decoded_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_hex_decode(
        to_decode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_base64_compute_encoded_len(
        to_encode_len: usize,
        encoded_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_base64_encode(
        to_encode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_base64_compute_decoded_len(
        to_decode: *const aws_byte_cursor,
        decoded_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_base64_decode(
        to_decode: *const aws_byte_cursor,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_text_encoding {
    AWS_TEXT_UNKNOWN = 0,
    AWS_TEXT_UTF8 = 1,
    AWS_TEXT_UTF16 = 2,
    AWS_TEXT_UTF32 = 3,
    AWS_TEXT_ASCII = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_utf8_decoder_options {
    #[doc = " Optional.\n Callback invoked for each Unicode codepoint.\n Use this callback to store codepoints as they're decoded,\n or to perform additional validation. RFC-3629 is already enforced,\n which forbids codepoints between U+D800 and U+DFFF,\n but you may whish to forbid codepoints like U+0000.\n\n @return AWS_OP_SUCCESS to continue processing the string, otherwise\n return AWS_OP_ERROR and raise an error (i.e. AWS_ERROR_INVALID_UTF8)\n to stop processing the string and report failure."]
    pub on_codepoint: ::std::option::Option<
        unsafe extern "C" fn(
            codepoint: u32,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_utf8_decoder_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_utf8_decoder_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_utf8_decoder_options>(),
        16usize,
        concat!("Size of: ", stringify!(aws_utf8_decoder_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_utf8_decoder_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_utf8_decoder_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_codepoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_utf8_decoder_options),
            "::",
            stringify!(on_codepoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_utf8_decoder_options),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    #[doc = " Decode a complete string of UTF8/ASCII text.\n Text is always validated according to RFC-3629 (you may perform additional\n validation in the on_codepoint callback).\n The text does not need to begin with a UTF8 BOM.\n If you need to decode text incrementally as you receive it, use aws_utf8_decoder_new() instead.\n\n @param bytes Text to decode.\n @param options Options for decoding. If NULL is passed, the text is simply validated.\n\n @return AWS_OP_SUCCESS if successful.\n An error is raised if the text is not valid, or the on_codepoint callback raises an error."]
    pub fn aws_decode_utf8(
        bytes: aws_byte_cursor,
        options: *const aws_utf8_decoder_options,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_utf8_decoder {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a UTF8/ASCII decoder, which can process text incrementally as you receive it.\n Text is always validated according to RFC-3629 (you may perform additional\n validation in the on_codepoint callback).\n The text does not need to begin with a UTF8 BOM.\n To decode text all at once, simply use aws_decode_utf8().\n\n Feed bytes into the decoder with aws_utf8_decoder_update(),\n and call aws_utf8_decoder_finalize() when the text is complete.\n\n @param allocator Allocator\n @param options Options for decoder. If NULL is passed, the text is simply validated."]
    pub fn aws_utf8_decoder_new(
        allocator: *mut aws_allocator,
        options: *const aws_utf8_decoder_options,
    ) -> *mut aws_utf8_decoder;
}
extern "C" {
    pub fn aws_utf8_decoder_destroy(decoder: *mut aws_utf8_decoder);
}
extern "C" {
    pub fn aws_utf8_decoder_reset(decoder: *mut aws_utf8_decoder);
}
extern "C" {
    #[doc = " Update the decoder with more bytes of text.\n The on_codepoint callback will be invoked for each codepoint encountered.\n Raises an error if invalid UTF8 is encountered or the on_codepoint callback reports an error.\n\n Note: You must call aws_utf8_decoder_finalize() when the text is 100% complete,\n to ensure the input was completely valid."]
    pub fn aws_utf8_decoder_update(
        decoder: *mut aws_utf8_decoder,
        bytes: aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the decoder that you've reached the end of your text.\n Raises AWS_ERROR_INVALID_UTF8 if the text did not end with a complete UTF8 codepoint.\n This also resets the decoder."]
    pub fn aws_utf8_decoder_finalize(decoder: *mut aws_utf8_decoder) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_get_environment_value(
        allocator: *mut aws_allocator,
        variable_name: *const aws_string,
        value_out: *mut *mut aws_string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_set_environment_value(
        variable_name: *const aws_string,
        value: *const aws_string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_unset_environment_value(variable_name: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the first-in-first-out cache. Sets up the underlying linked hash table.\n Once `max_items` elements have been added, the oldest(first-in) item will\n be removed. For the other parameters, see aws/common/hash_table.h. Hash table\n semantics of these arguments are preserved."]
    pub fn aws_cache_new_fifo(
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        max_items: usize,
    ) -> *mut aws_cache;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_directory_iterator {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_file_type {
    AWS_FILE_TYPE_FILE = 1,
    AWS_FILE_TYPE_SYM_LINK = 2,
    AWS_FILE_TYPE_DIRECTORY = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_directory_entry {
    #[doc = " Absolute path to the entry from the current process root."]
    pub path: aws_byte_cursor,
    #[doc = " Path to the entry relative to the current working directory."]
    pub relative_path: aws_byte_cursor,
    #[doc = " Bit-field of enum aws_file_type"]
    pub file_type: ::std::os::raw::c_int,
    #[doc = " Size of the file on disk."]
    pub file_size: i64,
}
#[test]
fn bindgen_test_layout_aws_directory_entry() {
    const UNINIT: ::std::mem::MaybeUninit<aws_directory_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_directory_entry>(),
        48usize,
        concat!("Size of: ", stringify!(aws_directory_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_directory_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_directory_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relative_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(relative_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(file_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(file_size)
        )
    );
}
#[doc = " Invoked during calls to aws_directory_traverse() as an entry is encountered. entry will contain\n the parsed directory entry info.\n\n Return true to continue the traversal, or alternatively, if you have a reason to abort the traversal, return false."]
pub type aws_on_directory_entry = ::std::option::Option<
    unsafe extern "C" fn(
        entry: *const aws_directory_entry,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Deprecated - Use aws_fopen_safe() instead, avoid const char * in public APIs.\n Opens file at file_path using mode. Returns the FILE pointer if successful.\n Otherwise, aws_last_error() will contain the error that occurred"]
    pub fn aws_fopen(
        file_path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Opens file at file_path using mode. Returns the FILE pointer if successful.\n Otherwise, aws_last_error() will contain the error that occurred"]
    pub fn aws_fopen_safe(file_path: *const aws_string, mode: *const aws_string) -> *mut FILE;
}
extern "C" {
    #[doc = " Creates a directory if it doesn't currently exist. If the directory already exists, it's ignored and assumed\n successful.\n\n Returns AWS_OP_SUCCESS on success. Otherwise, check aws_last_error()."]
    pub fn aws_directory_create(dir_path: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the directory currently exists. Otherwise, it returns false."]
    pub fn aws_directory_exists(dir_path: *const aws_string) -> bool;
}
extern "C" {
    #[doc = " Deletes a directory. If the directory is not empty, this will fail unless the recursive parameter is set to true.\n If recursive is true then the entire directory and all of its contents will be deleted. If it is set to false,\n the directory will be deleted only if it is empty. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred. If the directory doesn't exist, AWS_OP_SUCCESS is still\n returned."]
    pub fn aws_directory_delete(
        dir_path: *const aws_string,
        recursive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deletes a file. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred. If the file doesn't exist, AWS_OP_SUCCESS is still returned."]
    pub fn aws_file_delete(file_path: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Moves directory at from to to.\n Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred."]
    pub fn aws_directory_or_file_move(
        from: *const aws_string,
        to: *const aws_string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traverse a directory starting at path.\n\n If you want the traversal to recurse the entire directory, pass recursive as true. Passing false for this parameter\n will only iterate the contents of the directory, but will not descend into any directories it encounters.\n\n If recursive is set to true, the traversal is performed post-order, depth-first\n (for practical reasons such as deleting a directory that contains subdirectories or files).\n\n returns AWS_OP_SUCCESS(0) on success."]
    pub fn aws_directory_traverse(
        allocator: *mut aws_allocator,
        path: *const aws_string,
        recursive: bool,
        on_entry: aws_on_directory_entry,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a read-only iterator of a directory starting at path. If path is invalid or there's any other error\n condition, NULL will be returned. Call aws_last_error() for the exact error in that case."]
    pub fn aws_directory_entry_iterator_new(
        allocator: *mut aws_allocator,
        path: *const aws_string,
    ) -> *mut aws_directory_iterator;
}
extern "C" {
    #[doc = " Moves the iterator to the next entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with\n AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available."]
    pub fn aws_directory_entry_iterator_next(
        iterator: *mut aws_directory_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Moves the iterator to the previous entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with\n AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available."]
    pub fn aws_directory_entry_iterator_previous(
        iterator: *mut aws_directory_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleanup and deallocate iterator"]
    pub fn aws_directory_entry_iterator_destroy(iterator: *mut aws_directory_iterator);
}
extern "C" {
    #[doc = " Gets the aws_directory_entry value for iterator at the current position. Returns NULL if the iterator contains no\n entries."]
    pub fn aws_directory_entry_iterator_get_value(
        iterator: *const aws_directory_iterator,
    ) -> *const aws_directory_entry;
}
extern "C" {
    #[doc = " Returns true iff the character is a directory separator on ANY supported platform."]
    pub fn aws_is_any_directory_separator(value: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns the directory separator used by the local platform"]
    pub fn aws_get_platform_directory_separator() -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Normalizes the path by replacing any directory separator with the local platform's directory separator.\n @param path path to normalize. Must be writeable."]
    pub fn aws_normalize_directory_separator(path: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Returns the current user's home directory."]
    pub fn aws_get_home_directory(allocator: *mut aws_allocator) -> *mut aws_string;
}
extern "C" {
    #[doc = " Returns true if a file or path exists, otherwise, false."]
    pub fn aws_path_exists(path: *const aws_string) -> bool;
}
extern "C" {
    pub fn aws_fseek(
        file: *mut FILE,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_file_get_length(file: *mut FILE, length: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_host_utils_is_ipv4(host: aws_byte_cursor) -> bool;
}
extern "C" {
    pub fn aws_host_utils_is_ipv6(host: aws_byte_cursor, is_uri_encoded: bool) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_json_value {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new string aws_json_value with the given string and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n Note: might be slower than c_str version due to internal copy\n @param string A byte cursor you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new string aws_json_value"]
    pub fn aws_json_value_new_string(
        allocator: *mut aws_allocator,
        string: aws_byte_cursor,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Creates a new string aws_json_value with the given string and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param string c string pointer you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new string aws_json_value"]
    pub fn aws_json_value_new_string_from_c_str(
        allocator: *mut aws_allocator,
        string: *const ::std::os::raw::c_char,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Creates a new number aws_json_value with the given number and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param number The number you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new number aws_json_value"]
    pub fn aws_json_value_new_number(
        allocator: *mut aws_allocator,
        number: f64,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Creates a new array aws_json_value and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n Deleting this array will also destroy any aws_json_values it contains.\n @param allocator The allocator to use when creating the value\n @return A new array aws_json_value"]
    pub fn aws_json_value_new_array(allocator: *mut aws_allocator) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Creates a new boolean aws_json_value with the given boolean and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param boolean The boolean you want to store in the aws_json_value\n @param allocator The allocator to use when creating the value\n @return A new boolean aws_json_value"]
    pub fn aws_json_value_new_boolean(
        allocator: *mut aws_allocator,
        boolean: bool,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Creates a new null aws_json_value and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n @param allocator The allocator to use when creating the value\n @return A new null aws_json_value"]
    pub fn aws_json_value_new_null(allocator: *mut aws_allocator) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Creates a new object aws_json_value and returns a pointer to it.\n\n Note: You will need to free the memory for the aws_json_value using aws_json_destroy on the aws_json_value or\n on the object/array containing the aws_json_value.\n Deleting this object will also destroy any aws_json_values it contains.\n @param allocator The allocator to use when creating the value\n @return A new object aws_json_value"]
    pub fn aws_json_value_new_object(allocator: *mut aws_allocator) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Gets the string of a string aws_json_value.\n @param value The string aws_json_value.\n @param output The string\n @return AWS_OP_SUCCESS if the value is a string, otherwise AWS_OP_ERR."]
    pub fn aws_json_value_get_string(
        value: *const aws_json_value,
        output: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of a number aws_json_value.\n @param value The number aws_json_value.\n @param output The number\n @return AWS_OP_SUCCESS if the value is a number, otherwise AWS_OP_ERR."]
    pub fn aws_json_value_get_number(
        value: *const aws_json_value,
        output: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the boolean of a boolean aws_json_value.\n @param value The boolean aws_json_value.\n @param output The boolean\n @return AWS_OP_SUCCESS if the value is a boolean, otherwise AWS_OP_ERR."]
    pub fn aws_json_value_get_boolean(
        value: *const aws_json_value,
        output: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds a aws_json_value to a object aws_json_value.\n\n Note that the aws_json_value will be destroyed when the aws_json_value object is destroyed\n by calling \"aws_json_destroy()\"\n Note: might be slower than c_str version due to internal copy\n @param object The object aws_json_value you want to add a value to.\n @param key The key to add the aws_json_value at.\n @param value The aws_json_value you want to add.\n @return AWS_OP_SUCCESS if adding was successful.\n          Will return AWS_OP_ERROR if the object passed is invalid or if the passed key\n          is already in use in the object."]
    pub fn aws_json_value_add_to_object(
        object: *mut aws_json_value,
        key: aws_byte_cursor,
        value: *mut aws_json_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds a aws_json_value to a object aws_json_value.\n\n Note that the aws_json_value will be destroyed when the aws_json_value object is destroyed\n by calling \"aws_json_destroy()\"\n @param object The object aws_json_value you want to add a value to.\n @param key The key to add the aws_json_value at.\n @param value The aws_json_value you want to add.\n @return AWS_OP_SUCCESS if adding was successful.\n          Will return AWS_OP_ERROR if the object passed is invalid or if the passed key\n          is already in use in the object."]
    pub fn aws_json_value_add_to_object_c_str(
        object: *mut aws_json_value,
        key: *const ::std::os::raw::c_char,
        value: *mut aws_json_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the aws_json_value at the given key.\n Note: might be slower than c_str version due to internal copy\n @param object The object aws_json_value you want to get the value from.\n @param key The key that the aws_json_value is at. Is case sensitive.\n @return The aws_json_value at the given key, otherwise NULL."]
    pub fn aws_json_value_get_from_object(
        object: *const aws_json_value,
        key: aws_byte_cursor,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Returns the aws_json_value at the given key.\n Note: same as aws_json_value_get_from_object but with key as const char *.\n Prefer this method is you have a key thats already a valid char * as it is likely to be faster.\n @param object The object aws_json_value you want to get the value from.\n @param key The key that the aws_json_value is at. Is case sensitive.\n @return The aws_json_value at the given key, otherwise NULL."]
    pub fn aws_json_value_get_from_object_c_str(
        object: *const aws_json_value,
        key: *const ::std::os::raw::c_char,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Checks if there is a aws_json_value at the given key.\n Note: might be slower than c_str version due to internal copy\n @param object The value aws_json_value you want to check a key in.\n @param key The key that you want to check. Is case sensitive.\n @return True if a aws_json_value is found."]
    pub fn aws_json_value_has_key(object: *const aws_json_value, key: aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Checks if there is a aws_json_value at the given key.\n Note: same as aws_json_value_has_key but with key as const char *.\n Prefer this method is you have a key thats already a valid char * as it is likely to be faster.\n @param object The value aws_json_value you want to check a key in.\n @param key The key that you want to check. Is case sensitive.\n @return True if a aws_json_value is found."]
    pub fn aws_json_value_has_key_c_str(
        object: *const aws_json_value,
        key: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Removes the aws_json_value at the given key.\n Note: might be slower than c_str version due to internal copy\n @param object The object aws_json_value you want to remove a aws_json_value in.\n @param key The key that the aws_json_value is at. Is case sensitive.\n @return AWS_OP_SUCCESS if the aws_json_value was removed.\n          Will return AWS_OP_ERR if the object passed is invalid or if the value\n          at the key cannot be found."]
    pub fn aws_json_value_remove_from_object(
        object: *mut aws_json_value,
        key: aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes the aws_json_value at the given key.\n Note: same as aws_json_value_remove_from_object but with key as const char *.\n Prefer this method is you have a key thats already a valid char * as it is likely to be faster.\n @param object The object aws_json_value you want to remove a aws_json_value in.\n @param key The key that the aws_json_value is at. Is case sensitive.\n @return AWS_OP_SUCCESS if the aws_json_value was removed.\n          Will return AWS_OP_ERR if the object passed is invalid or if the value\n          at the key cannot be found."]
    pub fn aws_json_value_remove_from_object_c_str(
        object: *mut aws_json_value,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief callback for iterating members of an object\n Iteration can be controlled as follows:\n - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) -\n   continue iteration without error\n - return AWS_OP_SUCCESS and out_continue is set to false -\n   stop iteration without error\n - return AWS_OP_ERR - stop iteration with error"]
pub type aws_json_on_member_encountered_const_fn = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const aws_byte_cursor,
        value: *const aws_json_value,
        out_should_continue: *mut bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief iterates through members of the object.\n iteration is sequential in order fields were initially parsed.\n @param object object to iterate over.\n @param on_member callback for when member is encountered.\n @param user_data user data to pass back in callback.\n @return AWS_OP_SUCCESS when iteration finishes completely or exits early,\n AWS_OP_ERR if value is not an object."]
    pub fn aws_json_const_iterate_object(
        object: *const aws_json_value,
        on_member: aws_json_on_member_encountered_const_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds a aws_json_value to the given array aws_json_value.\n\n Note that the aws_json_value will be destroyed when the aws_json_value array is destroyed\n by calling \"aws_json_destroy()\"\n @param array The array aws_json_value you want to add an aws_json_value to.\n @param value The aws_json_value you want to add.\n @return AWS_OP_SUCCESS if adding the aws_json_value was successful.\n          Will return AWS_OP_ERR if the array passed is invalid."]
    pub fn aws_json_value_add_array_element(
        array: *mut aws_json_value,
        value: *const aws_json_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the aws_json_value at the given index in the array aws_json_value.\n @param array The array aws_json_value.\n @param index The index of the aws_json_value you want to access.\n @return A pointer to the aws_json_value at the given index in the array, otherwise NULL."]
    pub fn aws_json_get_array_element(
        array: *const aws_json_value,
        index: usize,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Returns the number of items in the array aws_json_value.\n @param array The array aws_json_value.\n @return The number of items in the array_json_value."]
    pub fn aws_json_get_array_size(array: *const aws_json_value) -> usize;
}
extern "C" {
    #[doc = " Removes the aws_json_value at the given index in the array aws_json_value.\n @param array The array aws_json_value.\n @param index The index containing the aws_json_value you want to remove.\n @return AWS_OP_SUCCESS if the aws_json_value at the index was removed.\n          Will return AWS_OP_ERR if the array passed is invalid or if the index\n          passed is out of range."]
    pub fn aws_json_value_remove_array_element(
        array: *mut aws_json_value,
        index: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief callback for iterating values of an array.\n Iteration can be controlled as follows:\n - return AWS_OP_SUCCESS and out_should_continue is set to true (default value) -\n   continue iteration without error\n - return AWS_OP_SUCCESS and out_continue is set to false -\n   stop iteration without error\n - return AWS_OP_ERR - stop iteration with error"]
pub type aws_json_on_value_encountered_const_fn = ::std::option::Option<
    unsafe extern "C" fn(
        index: usize,
        value: *const aws_json_value,
        out_should_continue: *mut bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief iterates through values of an array.\n iteration is sequential starting with 0th element.\n @param array array to iterate over.\n @param on_value callback for when value is encountered.\n @param user_data user data to pass back in callback.\n @return AWS_OP_SUCCESS when iteration finishes completely or exits early,\n AWS_OP_ERR if value is not an array."]
    pub fn aws_json_const_iterate_array(
        array: *const aws_json_value,
        on_value: aws_json_on_value_encountered_const_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether two json values are equivalent.\n @param a first value to compare.\n @param b second value to compare.\n @param is_case_sensitive case sensitive compare or not.\n @return True is values are equal, false otherwise"]
    pub fn aws_json_value_compare(
        a: *const aws_json_value,
        b: *const aws_json_value,
        is_case_sensitive: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Duplicates json value.\n @param value first value to compare.\n @return duplicated value. NULL and last error set if value cannot be duplicated."]
    pub fn aws_json_value_duplicate(value: *const aws_json_value) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Checks if the aws_json_value is a string.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a string aws_json_value, otherwise false."]
    pub fn aws_json_value_is_string(value: *const aws_json_value) -> bool;
}
extern "C" {
    #[doc = " Checks if the aws_json_value is a number.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a number aws_json_value, otherwise false."]
    pub fn aws_json_value_is_number(value: *const aws_json_value) -> bool;
}
extern "C" {
    #[doc = " Checks if the aws_json_value is a array.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a array aws_json_value, otherwise false."]
    pub fn aws_json_value_is_array(value: *const aws_json_value) -> bool;
}
extern "C" {
    #[doc = " Checks if the aws_json_value is a boolean.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a boolean aws_json_value, otherwise false."]
    pub fn aws_json_value_is_boolean(value: *const aws_json_value) -> bool;
}
extern "C" {
    #[doc = " Checks if the aws_json_value is a null aws_json_value.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a null aws_json_value, otherwise false."]
    pub fn aws_json_value_is_null(value: *const aws_json_value) -> bool;
}
extern "C" {
    #[doc = " Checks if the aws_json_value is a object aws_json_value.\n @param value The aws_json_value to check.\n @return True if the aws_json_value is a object aws_json_value, otherwise false."]
    pub fn aws_json_value_is_object(value: *const aws_json_value) -> bool;
}
extern "C" {
    #[doc = " Removes the aws_json_value from memory. If the aws_json_value is a object or array, it will also destroy\n attached aws_json_values as well.\n\n For example, if you called \"aws_json_array_add(b, a)\" to add an object \"a\" to an array \"b\", if you call\n \"aws_json_destroy(b)\" then it will also free \"a\" automatically. All children/attached aws_json_values are freed\n when the parent/root aws_json_value is destroyed.\n @param value The aws_json_value to destroy."]
    pub fn aws_json_value_destroy(value: *mut aws_json_value);
}
extern "C" {
    #[doc = " Appends a unformatted JSON string representation of the aws_json_value into the passed byte buffer.\n The byte buffer is expected to be already initialized so the function can append the JSON into it.\n\n Note: The byte buffer will automatically have its size extended if the JSON string is over the byte\n buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not\n have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\n Note: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free\n the memory used, as it will NOT be called automatically.\n @param value The aws_json_value to format.\n @param output The destination for the JSON string\n @return AWS_OP_SUCCESS if the JSON string was allocated to output without any errors\n      Will return AWS_OP_ERR if the value passed is not an aws_json_value or if there\n      was an error appending the JSON into the byte buffer."]
    pub fn aws_byte_buf_append_json_string(
        value: *const aws_json_value,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Appends a formatted JSON string representation of the aws_json_value into the passed byte buffer.\n The byte buffer is expected to already be initialized so the function can append the JSON into it.\n\n Note: The byte buffer will automatically have its size extended if the JSON string is over the byte\n buffer capacity AND the byte buffer has an allocator associated with it. If the byte buffer does not\n have an allocator associated and the JSON string is over capacity, AWS_OP_ERR will be returned.\n\n Note: When you are finished with the aws_byte_buf, you must call \"aws_byte_buf_clean_up_secure\" to free\n the memory used, as it will NOT be called automatically.\n @param value The aws_json_value to format.\n @param output The destination for the JSON string\n @return AWS_OP_SUCCESS if the JSON string was allocated to output without any errors\n      Will return AWS_OP_ERR if the value passed is not an aws_json_value or if there\n      aws an error appending the JSON into the byte buffer."]
    pub fn aws_byte_buf_append_json_string_formatted(
        value: *const aws_json_value,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parses the JSON string and returns a aws_json_value containing the root of the JSON.\n @param allocator The allocator used to create the value\n @param string The string containing the JSON.\n @return The root aws_json_value of the JSON."]
    pub fn aws_json_value_new_from_string(
        allocator: *mut aws_allocator,
        string: aws_byte_cursor,
    ) -> *mut aws_json_value;
}
extern "C" {
    #[doc = " Initializes the last-in-first-out cache. Sets up the underlying linked hash table.\n Once `max_items` elements have been added, the latest(last-in) item will\n be removed. For the other parameters, see aws/common/hash_table.h. Hash table\n semantics of these arguments are preserved."]
    pub fn aws_cache_new_lifo(
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        max_items: usize,
    ) -> *mut aws_cache;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_string {
    pub allocator: *mut aws_allocator,
    pub len: usize,
    pub bytes: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_aws_string() {
    const UNINIT: ::std::mem::MaybeUninit<aws_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_string>(),
        24usize,
        concat!("Size of: ", stringify!(aws_string))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_string>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_string),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_string),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_string),
            "::",
            stringify!(bytes)
        )
    );
}
extern "C" {
    #[doc = " Returns true if bytes of string are the same, false otherwise."]
    pub fn aws_string_eq(a: *const aws_string, b: *const aws_string) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_ignore_case(a: *const aws_string, b: *const aws_string) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and cursor are the same, false otherwise."]
    pub fn aws_string_eq_byte_cursor(str_: *const aws_string, cur: *const aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and cursor are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_byte_cursor_ignore_case(
        str_: *const aws_string,
        cur: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and buffer are the same, false otherwise."]
    pub fn aws_string_eq_byte_buf(str_: *const aws_string, buf: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and buffer are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_byte_buf_ignore_case(
        str_: *const aws_string,
        buf: *const aws_byte_buf,
    ) -> bool;
}
extern "C" {
    pub fn aws_string_eq_c_str(
        str_: *const aws_string,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of strings are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_c_str_ignore_case(
        str_: *const aws_string,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Constructor functions which copy data from null-terminated C-string or array of bytes."]
    pub fn aws_string_new_from_c_str(
        allocator: *mut aws_allocator,
        c_str: *const ::std::os::raw::c_char,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as array."]
    pub fn aws_string_new_from_array(
        allocator: *mut aws_allocator,
        bytes: *const u8,
        len: usize,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as another string."]
    pub fn aws_string_new_from_string(
        allocator: *mut aws_allocator,
        str_: *const aws_string,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as cursor."]
    pub fn aws_string_new_from_cursor(
        allocator: *mut aws_allocator,
        cursor: *const aws_byte_cursor,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as buf."]
    pub fn aws_string_new_from_buf(
        allocator: *mut aws_allocator,
        buf: *const aws_byte_buf,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Deallocate string."]
    pub fn aws_string_destroy(str_: *mut aws_string);
}
extern "C" {
    #[doc = " Zeroes out the data bytes of string and then deallocates the memory.\n Not safe to run on a string created with AWS_STATIC_STRING_FROM_LITERAL."]
    pub fn aws_string_destroy_secure(str_: *mut aws_string);
}
extern "C" {
    #[doc = " Compares lexicographical ordering of two strings. This is a binary\n byte-by-byte comparison, treating bytes as unsigned integers. It is suitable\n for either textual or binary data and is unaware of unicode or any other byte\n encoding. If both strings are identical in the bytes of the shorter string,\n then the longer string is lexicographically after the shorter.\n\n Returns a positive number if string a > string b. (i.e., string a is\n lexicographically after string b.) Returns zero if string a = string b.\n Returns negative number if string a < string b."]
    pub fn aws_string_compare(a: *const aws_string, b: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A convenience function for sorting lists of (const struct aws_string *) elements. This can be used as a\n comparator for aws_array_list_sort. It is just a simple wrapper around aws_string_compare."]
    pub fn aws_array_list_comparator_string(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies all bytes from string to buf.\n\n On success, returns true and updates the buf pointer/length\n accordingly. If there is insufficient space in the buf, returns\n false, leaving the buf unchanged."]
    pub fn aws_byte_buf_write_from_whole_string(
        buf: *mut aws_byte_buf,
        src: *const aws_string,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates an aws_byte_cursor from an existing string."]
    pub fn aws_byte_cursor_from_string(src: *const aws_string) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " If the string was dynamically allocated, clones it. If the string was statically allocated (i.e. has no allocator),\n returns the original string."]
    pub fn aws_string_clone_or_reuse(
        allocator: *mut aws_allocator,
        str_: *const aws_string,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Computes the length of a c string in bytes assuming the character set is either ASCII or UTF-8. If no NULL character\n is found within max_read_len of str, AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED is raised. Otherwise, str_len\n will contain the string length minus the NULL character, and AWS_OP_SUCCESS will be returned."]
    pub fn aws_secure_strlen(
        str_: *const ::std::os::raw::c_char,
        max_read_len: usize,
        str_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__types) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nranges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__nranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ranges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__ranges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneCharClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneLocale> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sgetrune) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sgetrune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sputrune) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sputrune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__invalid_rune) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__invalid_rune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__runetype) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__maplower) as usize - ptr as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mapupper) as usize - ptr as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__runetype_ext) as usize - ptr as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__maplower_ext) as usize - ptr as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mapupper_ext) as usize - ptr as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__variable) as usize - ptr as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__variable_len) as usize - ptr as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ncharclasses) as usize - ptr as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__ncharclasses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__charclasses) as usize - ptr as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__charclasses)
        )
    );
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_thread_detach_state {
    AWS_THREAD_NOT_CREATED = 1,
    AWS_THREAD_JOINABLE = 2,
    AWS_THREAD_JOIN_COMPLETED = 3,
    AWS_THREAD_MANAGED = 4,
}
#[repr(u32)]
#[doc = " Specifies the join strategy used on an aws_thread, which in turn controls whether or not a thread participates\n in the managed thread system.  The managed thread system provides logic to guarantee a join on all participating\n threads at the cost of laziness (the user cannot control when joins happen).\n\n Manual - thread does not participate in the managed thread system; any joins must be done by the user.  This\n is the default.  The user must call aws_thread_clean_up(), but only after any desired join operation has completed.\n Not doing so will cause the windows handle to leak.\n\n Managed - the managed thread system will automatically perform a join some time after the thread's run function\n has completed.  It is an error to call aws_thread_join on a thread configured with the managed join strategy.  The\n managed thread system will call aws_thread_clean_up() on the thread after the background join has completed.\n\n Additionally, an API exists, aws_thread_join_all_managed(), which blocks and returns when all outstanding threads\n with the managed strategy have fully joined.  This API is useful for tests (rather than waiting for many individual\n signals) and program shutdown or DLL unload.  This API is automatically invoked by the common library clean up\n function.  If the common library clean up is called from a managed thread, this will cause deadlock.\n\n Lazy thread joining is done only when threads finish their run function or when the user calls\n aws_thread_join_all_managed().  This means it may be a long time between thread function completion and the join\n being applied, but the queue of unjoined threads is always one or fewer so there is no critical resource\n backlog.\n\n Currently, only event loop group async cleanup and host resolver threads participate in the managed thread system.\n Additionally, event loop threads will increment and decrement the pending join count (they are manually joined\n internally) in order to have an accurate view of internal thread usage and also to prevent failure to release\n an event loop group fully from allowing aws_thread_join_all_managed() from running to completion when its\n intent is such that it should block instead."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_thread_join_strategy {
    AWS_TJS_MANUAL = 0,
    AWS_TJS_MANAGED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread_options {
    pub stack_size: usize,
    pub cpu_id: i32,
    pub join_strategy: aws_thread_join_strategy,
    #[doc = " Thread name, for debugging purpose.\n The length should not exceed AWS_THREAD_NAME_RECOMMENDED_STRLEN(15)\n if you want it to display properly on all platforms."]
    pub name: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_thread_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_thread_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_thread_options>(),
        32usize,
        concat!("Size of: ", stringify!(aws_thread_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_thread_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_thread_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join_strategy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(join_strategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(name)
        )
    );
}
pub type aws_thread_once = pthread_once_t;
pub type aws_thread_id_t = pthread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread {
    pub allocator: *mut aws_allocator,
    pub detach_state: aws_thread_detach_state,
    pub thread_id: aws_thread_id_t,
}
#[test]
fn bindgen_test_layout_aws_thread() {
    const UNINIT: ::std::mem::MaybeUninit<aws_thread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_thread>(),
        24usize,
        concat!("Size of: ", stringify!(aws_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_thread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detach_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread),
            "::",
            stringify!(detach_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread),
            "::",
            stringify!(thread_id)
        )
    );
}
extern "C" {
    #[doc = " Returns an instance of system default thread options."]
    pub fn aws_default_thread_options() -> *const aws_thread_options;
}
extern "C" {
    pub fn aws_thread_call_once(
        flag: *mut aws_thread_once,
        call_once: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Initializes a new platform specific thread object struct (not the os-level\n thread itself)."]
    pub fn aws_thread_init(
        thread: *mut aws_thread,
        allocator: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates an OS level thread and associates it with func. context will be passed to func when it is executed.\n options will be applied to the thread if they are applicable for the platform.\n\n After launch, you may join on the thread.  A successfully launched thread must have clean_up called on it in order\n to avoid a handle leak.  If you do not join before calling clean_up, the thread will become detached.\n\n Managed threads must not have join or clean_up called on them by external code."]
    pub fn aws_thread_launch(
        thread: *mut aws_thread,
        func: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        options: *const aws_thread_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the id of thread"]
    pub fn aws_thread_get_id(thread: *mut aws_thread) -> aws_thread_id_t;
}
extern "C" {
    #[doc = " Gets the detach state of the thread. For example, is it safe to call join on\n this thread? Has it been detached()?"]
    pub fn aws_thread_get_detach_state(thread: *mut aws_thread) -> aws_thread_detach_state;
}
extern "C" {
    #[doc = " Joins the calling thread to a thread instance. Returns when thread is\n finished.  Calling this from the associated OS thread will cause a deadlock."]
    pub fn aws_thread_join(thread: *mut aws_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Blocking call that waits for all managed threads to complete their join call.  This can only be called\n from the main thread or a non-managed thread.\n\n This gets called automatically from library cleanup.\n\n By default the wait is unbounded, but that default can be overridden via aws_thread_set_managed_join_timeout_ns()"]
    pub fn aws_thread_join_all_managed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overrides how long, in nanoseconds, that aws_thread_join_all_managed will wait for threads to complete.\n A value of zero will result in an unbounded wait."]
    pub fn aws_thread_set_managed_join_timeout_ns(timeout_in_ns: u64);
}
extern "C" {
    #[doc = " Cleans up the thread handle. Don't call this on a managed thread.  If you wish to join the thread, you must join\n before calling this function."]
    pub fn aws_thread_clean_up(thread: *mut aws_thread);
}
extern "C" {
    #[doc = " Returns the thread id of the calling thread."]
    pub fn aws_thread_current_thread_id() -> aws_thread_id_t;
}
extern "C" {
    #[doc = " Compare thread ids."]
    pub fn aws_thread_thread_id_equal(t1: aws_thread_id_t, t2: aws_thread_id_t) -> bool;
}
extern "C" {
    #[doc = " Sleeps the current thread by nanos."]
    pub fn aws_thread_current_sleep(nanos: u64);
}
pub type aws_thread_atexit_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Adds a callback to the chain to be called when the current thread joins.\n Callbacks are called from the current thread, in the reverse order they\n were added, after the thread function returns.\n If not called from within an aws_thread, has no effect."]
    pub fn aws_thread_current_at_exit(
        callback: aws_thread_atexit_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increments the count of unjoined threads in the managed thread system.  Used by managed threads and\n event loop threads.  Additional usage requires the user to join corresponding threads themselves and\n correctly increment/decrement even in the face of launch/join errors.\n\n aws_thread_join_all_managed() will not return until this count has gone to zero."]
    pub fn aws_thread_increment_unjoined_count();
}
extern "C" {
    #[doc = " Decrements the count of unjoined threads in the managed thread system.  Used by managed threads and\n event loop threads.  Additional usage requires the user to join corresponding threads themselves and\n correctly increment/decrement even in the face of launch/join errors.\n\n aws_thread_join_all_managed() will not return until this count has gone to zero."]
    pub fn aws_thread_decrement_unjoined_count();
}
extern "C" {
    #[doc = " Gets name of the current thread.\n Caller is responsible for destroying returned string.\n If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is\n set to NULL.\n If underlying OS call fails,  AWS_ERROR_SYS_CALL_FAILURE will be raised\n If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED\n will be raised"]
    pub fn aws_thread_current_name(
        allocator: *mut aws_allocator,
        out_name: *mut *mut aws_string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets name of the thread.\n Caller is responsible for destroying returned string.\n If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is\n set to NULL.\n If underlying OS call fails,  AWS_ERROR_SYS_CALL_FAILURE will be raised\n If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED\n will be raised"]
    pub fn aws_thread_name(
        allocator: *mut aws_allocator,
        thread_id: aws_thread_id_t,
        out_name: *mut *mut aws_string,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Controls what log calls pass through the logger and what log calls get filtered out.\n If a log level has a value of X, then all log calls using a level <= X will appear, while\n those using a value > X will not occur.\n\n You can filter both dynamically (by setting the log level on the logger object) or statically\n (by defining AWS_STATIC_LOG_LEVEL to be an appropriate integer module-wide).  Statically filtered\n log calls will be completely compiled out but require a rebuild if you want to get more detail\n about what's happening."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_log_level {
    AWS_LL_NONE = 0,
    AWS_LL_FATAL = 1,
    AWS_LL_ERROR = 2,
    AWS_LL_WARN = 3,
    AWS_LL_INFO = 4,
    AWS_LL_DEBUG = 5,
    AWS_LL_TRACE = 6,
    AWS_LL_COUNT = 7,
}
#[doc = " Log subject is a way of designating the topic of logging.\n\n The general idea is to support a finer-grained approach to log level control.  The primary use case\n is for situations that require more detailed logging within a specific domain, where enabling that detail\n globally leads to an untenable flood of information.\n\n For example, enable TRACE logging for tls-related log statements (handshake binary payloads), but\n only WARN logging everywhere else (because http payloads would blow up the log files).\n\n Log subject is an enum similar to aws error: each library has its own value-space and someone is\n responsible for registering the value <-> string connections."]
pub type aws_log_subject_t = u32;
pub const AWS_LOG_SUBJECT_STRIDE_BITS: _bindgen_ty_6 = _bindgen_ty_6::AWS_LOG_SUBJECT_STRIDE_BITS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    AWS_LOG_SUBJECT_STRIDE_BITS = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_subject_info {
    pub subject_id: aws_log_subject_t,
    pub subject_name: *const ::std::os::raw::c_char,
    pub subject_description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aws_log_subject_info() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_subject_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_subject_info>(),
        24usize,
        concat!("Size of: ", stringify!(aws_log_subject_info))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_subject_info>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_subject_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info),
            "::",
            stringify!(subject_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info),
            "::",
            stringify!(subject_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info),
            "::",
            stringify!(subject_description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_subject_info_list {
    pub subject_list: *mut aws_log_subject_info,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_aws_log_subject_info_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_subject_info_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_subject_info_list>(),
        16usize,
        concat!("Size of: ", stringify!(aws_log_subject_info_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_subject_info_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_subject_info_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info_list),
            "::",
            stringify!(subject_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info_list),
            "::",
            stringify!(count)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_common_log_subject {
    AWS_LS_COMMON_GENERAL = 0,
    AWS_LS_COMMON_TASK_SCHEDULER = 1,
    AWS_LS_COMMON_THREAD = 2,
    AWS_LS_COMMON_MEMTRACE = 3,
    AWS_LS_COMMON_XML_PARSER = 4,
    AWS_LS_COMMON_IO = 5,
    AWS_LS_COMMON_BUS = 6,
    AWS_LS_COMMON_TEST = 7,
    AWS_LS_COMMON_JSON_PARSER = 8,
    AWS_LS_COMMON_CBOR = 9,
    AWS_LS_COMMON_LAST = 1023,
}
#[doc = " We separate the log level function from the log call itself so that we can do the filter check in the macros (see\n below)\n\n By doing so, we make it so that the variadic format arguments are not even evaluated if the filter check does not\n succeed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_vtable {
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            logger: *mut aws_logger,
            log_level: aws_log_level,
            subject: aws_log_subject_t,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub get_log_level: ::std::option::Option<
        unsafe extern "C" fn(logger: *mut aws_logger, subject: aws_log_subject_t) -> aws_log_level,
    >,
    pub clean_up: ::std::option::Option<unsafe extern "C" fn(logger: *mut aws_logger)>,
    pub set_log_level: ::std::option::Option<
        unsafe extern "C" fn(logger: *mut aws_logger, arg1: aws_log_level) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_aws_logger_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger_vtable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger_vtable>(),
        32usize,
        concat!("Size of: ", stringify!(aws_logger_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_log_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(get_log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_up) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(clean_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_log_level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(set_log_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger {
    pub vtable: *mut aws_logger_vtable,
    pub allocator: *mut aws_allocator,
    pub p_impl: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_logger() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger>(),
        24usize,
        concat!("Size of: ", stringify!(aws_logger))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_impl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger),
            "::",
            stringify!(p_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_pipeline {
    pub formatter: *mut aws_log_formatter,
    pub channel: *mut aws_log_channel,
    pub writer: *mut aws_log_writer,
    pub allocator: *mut aws_allocator,
    pub level: aws_atomic_var,
}
#[test]
fn bindgen_test_layout_aws_logger_pipeline() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger_pipeline> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger_pipeline>(),
        40usize,
        concat!("Size of: ", stringify!(aws_logger_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger_pipeline))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(formatter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " Options for aws_logger_init_standard().\n Set `filename` to open a file for logging and close it when the logger cleans up.\n Set `file` to use a file that is already open, such as `stderr` or `stdout`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_standard_options {
    pub level: aws_log_level,
    pub filename: *const ::std::os::raw::c_char,
    pub file: *mut FILE,
}
#[test]
fn bindgen_test_layout_aws_logger_standard_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger_standard_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger_standard_options>(),
        24usize,
        concat!("Size of: ", stringify!(aws_logger_standard_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger_standard_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger_standard_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_standard_options),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_standard_options),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_standard_options),
            "::",
            stringify!(file)
        )
    );
}
extern "C" {
    #[doc = " Sets the aws logger used globally across the process.  Not thread-safe.  Must only be called once."]
    pub fn aws_logger_set(logger: *mut aws_logger);
}
extern "C" {
    #[doc = " Gets the aws logger used globally across the process."]
    pub fn aws_logger_get() -> *mut aws_logger;
}
extern "C" {
    #[doc = " Gets the aws logger used globally across the process if the logging level is at least the inputted level.\n\n @param subject log subject to perform the level check versus, not currently used\n @param level logging level to check against in order to return the logger\n @return the current logger if the current logging level is at or more detailed then the supplied logging level"]
    pub fn aws_logger_get_conditional(
        subject: aws_log_subject_t,
        level: aws_log_level,
    ) -> *mut aws_logger;
}
extern "C" {
    #[doc = " Cleans up all resources used by the logger; simply invokes the clean_up v-function"]
    pub fn aws_logger_clean_up(logger: *mut aws_logger);
}
extern "C" {
    #[doc = " Sets the current logging level for the logger.  Loggers are not require to support this.\n @param logger logger to set the log level for\n @param level new log level for the logger\n @return AWS_OP_SUCCESS if the level was successfully set, AWS_OP_ERR otherwise"]
    pub fn aws_logger_set_log_level(
        logger: *mut aws_logger,
        level: aws_log_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a log level to a c-string constant.  Intended primarily to support building log lines that\n include the level in them, i.e.\n\n [ERROR] 10:34:54.642 01-31-19 - Json parse error...."]
    pub fn aws_log_level_to_string(
        log_level: aws_log_level,
        level_string: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a c-string constant to a log level value.  Uses case-insensitive comparison\n and simply iterates all possibilities until a match or nothing remains.  If no match\n is found, AWS_OP_ERR is returned."]
    pub fn aws_string_to_log_level(
        level_string: *const ::std::os::raw::c_char,
        log_level: *mut aws_log_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts an aws_thread_id_t to a c-string.  For portability, aws_thread_id_t\n must not be printed directly.  Intended primarily to support building log\n lines that include the thread id in them.  The parameter `buffer` must\n point-to a char buffer of length `bufsz == AWS_THREAD_ID_T_REPR_BUFSZ`.  The\n thread id representation is returned in `buffer`."]
    pub fn aws_thread_id_t_to_string(
        thread_id: aws_thread_id_t,
        buffer: *mut ::std::os::raw::c_char,
        bufsz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get subject name from log subject."]
    pub fn aws_log_subject_name(subject: aws_log_subject_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Connects log subject strings with log subject integer values"]
    pub fn aws_register_log_subject_info_list(log_subject_list: *mut aws_log_subject_info_list);
}
extern "C" {
    #[doc = " Disconnects log subject strings with log subject integer values"]
    pub fn aws_unregister_log_subject_info_list(log_subject_list: *mut aws_log_subject_info_list);
}
extern "C" {
    pub fn aws_logger_init_standard(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        options: *mut aws_logger_standard_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_logger_init_from_external(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        formatter: *mut aws_log_formatter,
        channel: *mut aws_log_channel,
        writer: *mut aws_log_writer,
        level: aws_log_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut g_pipeline_logger_owned_vtable: aws_logger_vtable;
}
extern "C" {
    pub fn aws_logger_init_noalloc(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        options: *mut aws_logger_standard_options,
    ) -> ::std::os::raw::c_int;
}
pub type aws_log_channel_send_fn = ::std::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_log_channel,
        output: *mut aws_string,
    ) -> ::std::os::raw::c_int,
>;
pub type aws_log_channel_clean_up_fn =
    ::std::option::Option<unsafe extern "C" fn(channel: *mut aws_log_channel)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_channel_vtable {
    pub send: aws_log_channel_send_fn,
    pub clean_up: aws_log_channel_clean_up_fn,
}
#[test]
fn bindgen_test_layout_aws_log_channel_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_channel_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_channel_vtable>(),
        16usize,
        concat!("Size of: ", stringify!(aws_log_channel_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_channel_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_channel_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_channel_vtable),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_up) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_channel_vtable),
            "::",
            stringify!(clean_up)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_channel {
    pub vtable: *mut aws_log_channel_vtable,
    pub allocator: *mut aws_allocator,
    pub writer: *mut aws_log_writer,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_log_channel() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_channel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_channel>(),
        32usize,
        concat!("Size of: ", stringify!(aws_log_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_channel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_channel),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_channel),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_channel),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_channel),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    pub fn aws_log_channel_init_foreground(
        channel: *mut aws_log_channel,
        allocator: *mut aws_allocator,
        writer: *mut aws_log_writer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_log_channel_init_background(
        channel: *mut aws_log_channel,
        allocator: *mut aws_allocator,
        writer: *mut aws_log_writer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_log_channel_clean_up(channel: *mut aws_log_channel);
}
pub type __gnuc_va_list = __builtin_va_list;
pub type aws_log_formatter_format_fn = ::std::option::Option<
    unsafe extern "C" fn(
        formatter: *mut aws_log_formatter,
        formatted_output: *mut *mut aws_string,
        level: aws_log_level,
        subject: aws_log_subject_t,
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> ::std::os::raw::c_int,
>;
pub type aws_log_formatter_clean_up_fn =
    ::std::option::Option<unsafe extern "C" fn(logger: *mut aws_log_formatter)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter_vtable {
    pub format: aws_log_formatter_format_fn,
    pub clean_up: aws_log_formatter_clean_up_fn,
}
#[test]
fn bindgen_test_layout_aws_log_formatter_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_formatter_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_formatter_vtable>(),
        16usize,
        concat!("Size of: ", stringify!(aws_log_formatter_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_formatter_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_formatter_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_formatter_vtable),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_up) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_formatter_vtable),
            "::",
            stringify!(clean_up)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter {
    pub vtable: *mut aws_log_formatter_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_log_formatter() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_formatter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_formatter>(),
        24usize,
        concat!("Size of: ", stringify!(aws_log_formatter))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_formatter>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_formatter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_formatter),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_formatter),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_formatter),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter_standard_options {
    pub date_format: aws_date_format,
}
#[test]
fn bindgen_test_layout_aws_log_formatter_standard_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_formatter_standard_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_formatter_standard_options>(),
        4usize,
        concat!("Size of: ", stringify!(aws_log_formatter_standard_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_formatter_standard_options>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(aws_log_formatter_standard_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_formatter_standard_options),
            "::",
            stringify!(date_format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logging_standard_formatting_data {
    pub log_line_buffer: *mut ::std::os::raw::c_char,
    pub total_length: usize,
    pub level: aws_log_level,
    pub subject_name: *const ::std::os::raw::c_char,
    pub format: *const ::std::os::raw::c_char,
    pub date_format: aws_date_format,
    pub allocator: *mut aws_allocator,
    pub amount_written: usize,
}
#[test]
fn bindgen_test_layout_aws_logging_standard_formatting_data() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logging_standard_formatting_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logging_standard_formatting_data>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aws_logging_standard_formatting_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logging_standard_formatting_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_logging_standard_formatting_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_line_buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(log_line_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(subject_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date_format) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(date_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amount_written) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logging_standard_formatting_data),
            "::",
            stringify!(amount_written)
        )
    );
}
extern "C" {
    pub fn aws_log_formatter_init_default(
        formatter: *mut aws_log_formatter,
        allocator: *mut aws_allocator,
        options: *mut aws_log_formatter_standard_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_log_formatter_clean_up(formatter: *mut aws_log_formatter);
}
extern "C" {
    pub fn aws_format_standard_log_line(
        formatting_data: *mut aws_logging_standard_formatting_data,
        args: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type aws_log_writer_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        writer: *mut aws_log_writer,
        output: *const aws_string,
    ) -> ::std::os::raw::c_int,
>;
pub type aws_log_writer_clean_up_fn =
    ::std::option::Option<unsafe extern "C" fn(writer: *mut aws_log_writer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer_vtable {
    pub write: aws_log_writer_write_fn,
    pub clean_up: aws_log_writer_clean_up_fn,
}
#[test]
fn bindgen_test_layout_aws_log_writer_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_writer_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_writer_vtable>(),
        16usize,
        concat!("Size of: ", stringify!(aws_log_writer_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_writer_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_writer_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer_vtable),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_up) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer_vtable),
            "::",
            stringify!(clean_up)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer {
    pub vtable: *mut aws_log_writer_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_log_writer() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_writer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_writer>(),
        24usize,
        concat!("Size of: ", stringify!(aws_log_writer))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_writer>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_writer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer_file_options {
    pub filename: *const ::std::os::raw::c_char,
    pub file: *mut FILE,
}
#[test]
fn bindgen_test_layout_aws_log_writer_file_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_writer_file_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_writer_file_options>(),
        16usize,
        concat!("Size of: ", stringify!(aws_log_writer_file_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_writer_file_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_writer_file_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer_file_options),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_writer_file_options),
            "::",
            stringify!(file)
        )
    );
}
extern "C" {
    pub fn aws_log_writer_init_stdout(
        writer: *mut aws_log_writer,
        allocator: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_log_writer_init_stderr(
        writer: *mut aws_log_writer,
        allocator: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_log_writer_init_file(
        writer: *mut aws_log_writer,
        allocator: *mut aws_allocator,
        options: *mut aws_log_writer_file_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_log_writer_clean_up(writer: *mut aws_log_writer);
}
extern "C" {
    #[doc = " Initializes the Least-recently-used cache. Sets up the underlying linked hash table.\n Once `max_items` elements have been added, the least recently used item will be removed. For the other parameters,\n see aws/common/hash_table.h. Hash table semantics of these arguments are preserved.(Yes the one that was the answer\n to that interview question that one time)."]
    pub fn aws_cache_new_lru(
        allocator: *mut aws_allocator,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
        max_items: usize,
    ) -> *mut aws_cache;
}
extern "C" {
    #[doc = " Accesses the least-recently-used element, sets it to most-recently-used\n element, and returns the value."]
    pub fn aws_lru_cache_use_lru_element(cache: *mut aws_cache) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Accesses the most-recently-used element and returns its value."]
    pub fn aws_lru_cache_get_mru_element(cache: *const aws_cache) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_mutex {
    pub mutex_handle: pthread_mutex_t,
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_aws_mutex() {
    const UNINIT: ::std::mem::MaybeUninit<aws_mutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_mutex>(),
        72usize,
        concat!("Size of: ", stringify!(aws_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_mutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_mutex),
            "::",
            stringify!(mutex_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_mutex),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " Initializes a new platform instance of mutex."]
    pub fn aws_mutex_init(mutex: *mut aws_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up internal resources."]
    pub fn aws_mutex_clean_up(mutex: *mut aws_mutex);
}
extern "C" {
    #[doc = " Blocks until it acquires the lock. While on some platforms such as Windows,\n this may behave as a reentrant mutex, you should not treat it like one. On\n platforms it is possible for it to be non-reentrant, it will be."]
    pub fn aws_mutex_lock(mutex: *mut aws_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to acquire the lock but returns immediately if it can not.\n While on some platforms such as Windows, this may behave as a reentrant mutex,\n you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]"]
    pub fn aws_mutex_try_lock(mutex: *mut aws_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Releases the lock."]
    pub fn aws_mutex_unlock(mutex: *mut aws_mutex) -> ::std::os::raw::c_int;
}
pub type aws_priority_queue_compare_fn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_priority_queue {
    #[doc = " predicate that determines the priority of the elements in the queue."]
    pub pred: aws_priority_queue_compare_fn,
    #[doc = " The underlying container storing the queue elements."]
    pub container: aws_array_list,
    #[doc = " An array of pointers to backpointer elements. This array is initialized when\n the first call to aws_priority_queue_push_bp is made, and is subsequently maintained\n through any heap node manipulations.\n\n Each element is a struct aws_priority_queue_node *, pointing to a backpointer field\n owned by the calling code, or a NULL. The backpointer field is continually updated\n with information needed to locate and remove a specific node later on."]
    pub backpointers: aws_array_list,
}
#[test]
fn bindgen_test_layout_aws_priority_queue() {
    const UNINIT: ::std::mem::MaybeUninit<aws_priority_queue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_priority_queue>(),
        88usize,
        concat!("Size of: ", stringify!(aws_priority_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_priority_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_priority_queue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pred) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue),
            "::",
            stringify!(pred)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).container) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backpointers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue),
            "::",
            stringify!(backpointers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_priority_queue_node {
    #[doc = " The current index of the node in question, or SIZE_MAX if the node has been removed."]
    pub current_index: usize,
}
#[test]
fn bindgen_test_layout_aws_priority_queue_node() {
    const UNINIT: ::std::mem::MaybeUninit<aws_priority_queue_node> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_priority_queue_node>(),
        8usize,
        concat!("Size of: ", stringify!(aws_priority_queue_node))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_priority_queue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_priority_queue_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue_node),
            "::",
            stringify!(current_index)
        )
    );
}
extern "C" {
    #[doc = " Initializes a priority queue struct for use. This mode will grow memory automatically (exponential model)\n Default size is the inital size of the queue\n item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n pred is the function that will be used to determine priority."]
    pub fn aws_priority_queue_init_dynamic(
        queue: *mut aws_priority_queue,
        alloc: *mut aws_allocator,
        default_size: usize,
        item_size: usize,
        pred: aws_priority_queue_compare_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes a priority queue struct for use. This mode will not allocate any additional memory. When the heap fills\n new enqueue operations will fail with AWS_ERROR_PRIORITY_QUEUE_FULL.\n\n Heaps initialized using this call do not support the aws_priority_queue_push_ref call with a non-NULL backpointer\n parameter.\n\n heap is the raw memory allocated for this priority_queue\n item_count is the maximum number of elements the raw heap can contain\n item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n pred is the function that will be used to determine priority."]
    pub fn aws_priority_queue_init_static(
        queue: *mut aws_priority_queue,
        heap: *mut ::std::os::raw::c_void,
        item_count: usize,
        item_size: usize,
        pred: aws_priority_queue_compare_fn,
    );
}
extern "C" {
    #[doc = " Checks that the backpointer at a specific index of the queue is\n NULL or points to a correctly allocated aws_priority_queue_node."]
    pub fn aws_priority_queue_backpointer_index_valid(
        queue: *const aws_priority_queue,
        index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks that the backpointers of the priority queue are either NULL\n or correctly allocated to point at aws_priority_queue_nodes. This\n check is O(n), as it accesses every backpointer in a loop, and thus\n shouldn't be used carelessly."]
    pub fn aws_priority_queue_backpointers_valid_deep(queue: *const aws_priority_queue) -> bool;
}
extern "C" {
    #[doc = " Checks that the backpointers of the priority queue satisfy validity\n constraints."]
    pub fn aws_priority_queue_backpointers_valid(queue: *const aws_priority_queue) -> bool;
}
extern "C" {
    #[doc = " Set of properties of a valid aws_priority_queue."]
    pub fn aws_priority_queue_is_valid(queue: *const aws_priority_queue) -> bool;
}
extern "C" {
    #[doc = " Cleans up any internally allocated memory and resets the struct for reuse or deletion."]
    pub fn aws_priority_queue_clean_up(queue: *mut aws_priority_queue);
}
extern "C" {
    #[doc = " Copies item into the queue and places it in the proper priority order. Complexity: O(log(n))."]
    pub fn aws_priority_queue_push(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\n If the backpointer parameter is non-null, the heap will continually update the pointed-to field\n with information needed to remove the node later on. *backpointer must remain valid until the node\n is removed from the heap, and may be updated on any mutating operation on the priority queue.\n\n If the node is removed, the backpointer will be set to a sentinel value that indicates that the\n node has already been removed. It is safe (and a no-op) to call aws_priority_queue_remove with\n such a sentinel value."]
    pub fn aws_priority_queue_push_ref(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
        backpointer: *mut aws_priority_queue_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the element of the highest priority, and removes it from the queue.. Complexity: O(log(n)).\n If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised."]
    pub fn aws_priority_queue_pop(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes a specific node from the priority queue. Complexity: O(log(n))\n After removing a node (using either _remove or _pop), the backpointer set at push_ref time is set\n to a sentinel value. If this sentinel value is passed to aws_priority_queue_remove,\n AWS_ERROR_PRIORITY_QUEUE_BAD_NODE will be raised. Note, however, that passing uninitialized\n aws_priority_queue_nodes, or ones from different priority queues, results in undefined behavior."]
    pub fn aws_priority_queue_remove(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
        node: *const aws_priority_queue_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtains a pointer to the element of the highest priority. Complexity: constant time.\n If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised."]
    pub fn aws_priority_queue_top(
        queue: *const aws_priority_queue,
        item: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes all elements from the queue, but does not free internal memory."]
    pub fn aws_priority_queue_clear(queue: *mut aws_priority_queue);
}
extern "C" {
    #[doc = " Current number of elements in the queue"]
    pub fn aws_priority_queue_size(queue: *const aws_priority_queue) -> usize;
}
extern "C" {
    #[doc = " Current allocated capacity for the queue, in dynamic mode this grows over time, in static mode, this will never\n change."]
    pub fn aws_priority_queue_capacity(queue: *const aws_priority_queue) -> usize;
}
extern "C" {
    #[doc = " Initializes a queue node to a default value that indicates the node is not in the queue.\n\n @param node priority queue node to initialize with a default value"]
    pub fn aws_priority_queue_node_init(node: *mut aws_priority_queue_node);
}
extern "C" {
    #[doc = " Checks if a priority queue node is currently in a priority queue.\n\n @param node priority queue node to check usage for\n\n @return true if the node is in a queue, false otherwise"]
    pub fn aws_priority_queue_node_is_in_queue(node: *const aws_priority_queue_node) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_run_command_result {
    pub ret_code: ::std::os::raw::c_int,
    #[doc = " captured stdout message from running the command,\n caller is responsible for releasing the memory."]
    pub std_out: *mut aws_string,
    #[doc = " captured stderr message from running the command,\n caller is responsible for releasing the memory.\n It's currently not implemented and the value will be set to NULL."]
    pub std_err: *mut aws_string,
}
#[test]
fn bindgen_test_layout_aws_run_command_result() {
    const UNINIT: ::std::mem::MaybeUninit<aws_run_command_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_run_command_result>(),
        24usize,
        concat!("Size of: ", stringify!(aws_run_command_result))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_run_command_result>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_run_command_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ret_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_run_command_result),
            "::",
            stringify!(ret_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).std_out) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_run_command_result),
            "::",
            stringify!(std_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).std_err) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_run_command_result),
            "::",
            stringify!(std_err)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_run_command_options {
    #[doc = " command path and commandline options of running that command."]
    pub command: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aws_run_command_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_run_command_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_run_command_options>(),
        8usize,
        concat!("Size of: ", stringify!(aws_run_command_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_run_command_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_run_command_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_run_command_options),
            "::",
            stringify!(command)
        )
    );
}
extern "C" {
    #[doc = " Returns the current process's PID (process id).\n @return PID as int"]
    pub fn aws_get_pid() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the soft limit for max io handles (max fds in unix terminology). This limit is one more than the actual\n limit. The soft limit can be changed up to the hard limit by any process regardless of permissions."]
    pub fn aws_get_soft_limit_io_handles() -> usize;
}
extern "C" {
    #[doc = " Returns the hard limit for max io handles (max fds in unix terminology). This limit is one more than the actual\n limit. This limit cannot be increased without sudo permissions."]
    pub fn aws_get_hard_limit_io_handles() -> usize;
}
extern "C" {
    #[doc = " Sets the new soft limit for io_handles (max fds). This can be up to the hard limit but may not exceed it.\n\n This operation will always fail with AWS_ERROR_UNIMPLEMENTED error code on Windows."]
    pub fn aws_set_soft_limit_io_handles(max_handles: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_run_command_result_init(
        allocator: *mut aws_allocator,
        result: *mut aws_run_command_result,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_run_command_result_cleanup(result: *mut aws_run_command_result);
}
extern "C" {
    #[doc = " Currently this API is implemented using popen on Posix system and\n _popen on Windows to capture output from running a command. Note\n that popen only captures stdout, and doesn't provide an option to\n capture stderr. We will add more options, such as acquire stderr\n in the future so probably will alter the underlying implementation\n as well."]
    pub fn aws_run_command(
        allocator: *mut aws_allocator,
        options: *mut aws_run_command_options,
        result: *mut aws_run_command_result,
    ) -> ::std::os::raw::c_int;
}
pub type aws_simple_completion_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_ref_count {
    pub ref_count: aws_atomic_var,
    pub object: *mut ::std::os::raw::c_void,
    pub on_zero_fn: aws_simple_completion_callback,
}
#[test]
fn bindgen_test_layout_aws_ref_count() {
    const UNINIT: ::std::mem::MaybeUninit<aws_ref_count> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_ref_count>(),
        24usize,
        concat!("Size of: ", stringify!(aws_ref_count))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_ref_count>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_ref_count))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ref_count),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ref_count),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_zero_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ref_count),
            "::",
            stringify!(on_zero_fn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_shutdown_callback_options {
    pub shutdown_callback_fn: aws_simple_completion_callback,
    pub shutdown_callback_user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_shutdown_callback_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_shutdown_callback_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_shutdown_callback_options>(),
        16usize,
        concat!("Size of: ", stringify!(aws_shutdown_callback_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_shutdown_callback_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_shutdown_callback_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_callback_fn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_shutdown_callback_options),
            "::",
            stringify!(shutdown_callback_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_callback_user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_shutdown_callback_options),
            "::",
            stringify!(shutdown_callback_user_data)
        )
    );
}
extern "C" {
    #[doc = " Initializes a ref-counter structure.  After initialization, the ref count will be 1.\n\n @param ref_count ref-counter to initialize\n @param object object being ref counted\n @param on_zero_fn function to invoke when the ref count reaches zero"]
    pub fn aws_ref_count_init(
        ref_count: *mut aws_ref_count,
        object: *mut ::std::os::raw::c_void,
        on_zero_fn: aws_simple_completion_callback,
    );
}
extern "C" {
    #[doc = " Increments a ref-counter's ref count\n\n @param ref_count ref-counter to increment the count for\n @return the object being ref-counted"]
    pub fn aws_ref_count_acquire(ref_count: *mut aws_ref_count) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Decrements a ref-counter's ref count.  Invokes the on_zero callback if the ref count drops to zero\n @param ref_count ref-counter to decrement the count for\n @return the value of the decremented ref count"]
    pub fn aws_ref_count_release(ref_count: *mut aws_ref_count) -> usize;
}
#[doc = " Lockless ring buffer implementation that is thread safe assuming a single thread acquires and a single thread\n releases. For any other use case (other than the single-threaded use-case), you must manage thread-safety manually.\n\n Also, a very important note: release must happen in the same order as acquire. If you do not your application, and\n possibly computers within a thousand mile radius, may die terrible deaths, and the local drinking water will be\n poisoned for generations with fragments of what is left of your radioactive corrupted memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_ring_buffer {
    pub allocator: *mut aws_allocator,
    pub allocation: *mut u8,
    pub head: aws_atomic_var,
    pub tail: aws_atomic_var,
    pub allocation_end: *mut u8,
}
#[test]
fn bindgen_test_layout_aws_ring_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<aws_ring_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_ring_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(aws_ring_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_ring_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_ring_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ring_buffer),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ring_buffer),
            "::",
            stringify!(allocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ring_buffer),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ring_buffer),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocation_end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ring_buffer),
            "::",
            stringify!(allocation_end)
        )
    );
}
extern "C" {
    #[doc = " Initializes a ring buffer with an allocation of size `size`. Returns AWS_OP_SUCCESS on a successful initialization,\n AWS_OP_ERR otherwise."]
    pub fn aws_ring_buffer_init(
        ring_buf: *mut aws_ring_buffer,
        allocator: *mut aws_allocator,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up the ring buffer's resources."]
    pub fn aws_ring_buffer_clean_up(ring_buf: *mut aws_ring_buffer);
}
extern "C" {
    #[doc = " Attempts to acquire `requested_size` buffer and stores the result in `dest` if successful. Returns AWS_OP_SUCCESS if\n the requested size was available for use, AWS_OP_ERR otherwise."]
    pub fn aws_ring_buffer_acquire(
        ring_buf: *mut aws_ring_buffer,
        requested_size: usize,
        dest: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to acquire `requested_size` buffer and stores the result in `dest` if successful. If not available, it will\n attempt to acquire anywhere from 1 byte to `requested_size`. Returns AWS_OP_SUCCESS if some buffer space is available\n for use, AWS_OP_ERR otherwise."]
    pub fn aws_ring_buffer_acquire_up_to(
        ring_buf: *mut aws_ring_buffer,
        minimum_size: usize,
        requested_size: usize,
        dest: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Releases `buf` back to the ring buffer for further use. RELEASE MUST HAPPEN in the SAME ORDER AS ACQUIRE.\n If you do not, your application, and possibly computers within a thousand mile radius, may die terrible deaths,\n and the local drinking water will be poisoned for generations\n with fragments of what is left of your radioactive corrupted memory."]
    pub fn aws_ring_buffer_release(ring_buffer: *mut aws_ring_buffer, buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Returns true if the memory in `buf` was vended by this ring buffer, false otherwise.\n Make sure `buf->buffer` and `ring_buffer->allocation` refer to the same memory region."]
    pub fn aws_ring_buffer_buf_belongs_to_pool(
        ring_buffer: *const aws_ring_buffer,
        buf: *const aws_byte_buf,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_rw_lock {
    pub lock_handle: pthread_rwlock_t,
}
#[test]
fn bindgen_test_layout_aws_rw_lock() {
    const UNINIT: ::std::mem::MaybeUninit<aws_rw_lock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_rw_lock>(),
        200usize,
        concat!("Size of: ", stringify!(aws_rw_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_rw_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_rw_lock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_rw_lock),
            "::",
            stringify!(lock_handle)
        )
    );
}
extern "C" {
    #[doc = " Initializes a new platform instance of mutex."]
    pub fn aws_rw_lock_init(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up internal resources."]
    pub fn aws_rw_lock_clean_up(lock: *mut aws_rw_lock);
}
extern "C" {
    #[doc = " Blocks until it acquires the lock. While on some platforms such as Windows,\n this may behave as a reentrant mutex, you should not treat it like one. On\n platforms it is possible for it to be non-reentrant, it will be."]
    pub fn aws_rw_lock_rlock(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_rw_lock_wlock(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to acquire the lock but returns immediately if it can not.\n While on some platforms such as Windows, this may behave as a reentrant mutex,\n you should not treat it like one. On platforms it is possible for it to be non-reentrant, it will be.\n Note: For windows, minimum support server version is Windows Server 2008 R2 [desktop apps | UWP apps]"]
    pub fn aws_rw_lock_try_rlock(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_rw_lock_try_wlock(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Releases the lock."]
    pub fn aws_rw_lock_runlock(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_rw_lock_wunlock(lock: *mut aws_rw_lock) -> ::std::os::raw::c_int;
}
pub type aws_crt_statistics_category_t = u32;
pub const AWS_CRT_STATISTICS_CATEGORY_STRIDE_BITS: _bindgen_ty_7 =
    _bindgen_ty_7::AWS_CRT_STATISTICS_CATEGORY_STRIDE_BITS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_7 {
    AWS_CRT_STATISTICS_CATEGORY_STRIDE_BITS = 8,
}
#[repr(u32)]
#[doc = " The common-specific range of the aws_crt_statistics_category cross-library enum.\n\n This enum functions as an RTTI value that lets statistics handler's interpret (via cast) a\n specific statistics structure if the RTTI value is understood.\n\n Common doesn't have any statistics structures presently, so its range is essentially empty.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_crt_common_statistics_category {
    AWSCRT_STAT_CAT_INVALID = 0,
}
#[doc = " Pattern-struct that functions as a base \"class\" for all statistics structures.  To conform\n to the pattern, a statistics structure must have its first member be the category.  In that\n case it becomes \"safe\" to cast from aws_crt_statistics_base to the specific statistics structure\n based on the category value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_base {
    pub category: aws_crt_statistics_category_t,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_base() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_base>(),
        4usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_base))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_base>(),
        4usize,
        concat!("Alignment of ", stringify!(aws_crt_statistics_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_base),
            "::",
            stringify!(category)
        )
    );
}
#[doc = " The start and end time, in milliseconds-since-epoch, that a set of statistics was gathered over."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_sample_interval {
    pub begin_time_ms: u64,
    pub end_time_ms: u64,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_sample_interval() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_sample_interval> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_sample_interval>(),
        16usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_sample_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_sample_interval>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_crt_statistics_sample_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_time_ms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_sample_interval),
            "::",
            stringify!(begin_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_time_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_sample_interval),
            "::",
            stringify!(end_time_ms)
        )
    );
}
pub type aws_crt_statistics_handler_process_statistics_fn = ::std::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_crt_statistics_handler,
        interval: *mut aws_crt_statistics_sample_interval,
        stats: *mut aws_array_list,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type aws_crt_statistics_handler_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_crt_statistics_handler)>;
pub type aws_crt_statistics_handler_get_report_interval_ms_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut aws_crt_statistics_handler) -> u64>;
#[doc = " Vtable for functions that all statistics handlers must implement"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_handler_vtable {
    pub process_statistics: aws_crt_statistics_handler_process_statistics_fn,
    pub destroy: aws_crt_statistics_handler_destroy_fn,
    pub get_report_interval_ms: aws_crt_statistics_handler_get_report_interval_ms_fn,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_handler_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_handler_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_handler_vtable>(),
        24usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_handler_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_handler_vtable>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_crt_statistics_handler_vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_statistics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler_vtable),
            "::",
            stringify!(process_statistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_report_interval_ms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler_vtable),
            "::",
            stringify!(get_report_interval_ms)
        )
    );
}
#[doc = " Base structure for all statistics handler implementations.\n\n A statistics handler is an object that listens to a stream of polymorphic (via the category RTTI enum) statistics\n structures emitted from some arbitrary source.  In the initial implementation, statistics handlers are primarily\n attached to channels, where they monitor IO throughput and state data (from channel handlers) to determine a\n connection's health.\n\n Statistics handlers are a generalization of the timeout and bandwidth filters that are often associated with\n SDK network connections.  Configurable, default implementations are defined at the protocol level (http, etc...)\n where they can be attached at connection (channel) creation time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_handler {
    pub vtable: *mut aws_crt_statistics_handler_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_handler() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_handler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_handler>(),
        24usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_crt_statistics_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Submits a list of statistics objects to a statistics handler for processing\n\n handler - the statistics handler that will process the statistics objects\n interval - time period over which the statistics were gathered\n stats - list of pointers to structures that can be case to aws_crt_statistics_base (i.e. have category as a first\n   member)\n context - (optional) additional context specific to where the statistics handler has been attached"]
    pub fn aws_crt_statistics_handler_process_statistics(
        handler: *mut aws_crt_statistics_handler,
        interval: *mut aws_crt_statistics_sample_interval,
        stats: *mut aws_array_list,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Queries the frequency (via an interval in milliseconds) which a statistics handler would like to be informed\n of statistics."]
    pub fn aws_crt_statistics_handler_get_report_interval_ms(
        handler: *mut aws_crt_statistics_handler,
    ) -> u64;
}
extern "C" {
    #[doc = " completely destroys a statistics handler.  The handler's cleanup function must clean up the impl portion completely\n (including its allocation, if done separately)."]
    pub fn aws_crt_statistics_handler_destroy(handler: *mut aws_crt_statistics_handler);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_platform_os {
    AWS_PLATFORM_OS_WINDOWS = 0,
    AWS_PLATFORM_OS_MAC = 1,
    AWS_PLATFORM_OS_UNIX = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_cpu_info {
    pub cpu_id: i32,
    pub suspected_hyper_thread: bool,
}
#[test]
fn bindgen_test_layout_aws_cpu_info() {
    const UNINIT: ::std::mem::MaybeUninit<aws_cpu_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_cpu_info>(),
        8usize,
        concat!("Size of: ", stringify!(aws_cpu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_cpu_info>(),
        4usize,
        concat!("Alignment of ", stringify!(aws_cpu_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cpu_info),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).suspected_hyper_thread) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_cpu_info),
            "::",
            stringify!(suspected_hyper_thread)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_system_environment {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocates and initializes information about the system the current process is executing on.\n If successful returns an instance of aws_system_environment. If it fails, it will return NULL.\n\n Note: This api is used internally and is still early in its evolution.\n It may change in incompatible ways in the future."]
    pub fn aws_system_environment_load(
        allocator: *mut aws_allocator,
    ) -> *mut aws_system_environment;
}
extern "C" {
    pub fn aws_system_environment_acquire(
        env: *mut aws_system_environment,
    ) -> *mut aws_system_environment;
}
extern "C" {
    pub fn aws_system_environment_release(env: *mut aws_system_environment);
}
extern "C" {
    #[doc = " Returns the virtualization vendor for the specified compute environment, e.g. \"Xen, Amazon EC2, etc...\"\n\n The return value may be empty and in that case no vendor was detected."]
    pub fn aws_system_environment_get_virtualization_vendor(
        env: *const aws_system_environment,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the product name for the specified compute environment. For example, the Amazon EC2 Instance type.\n\n The return value may be empty and in that case no vendor was detected."]
    pub fn aws_system_environment_get_virtualization_product_name(
        env: *const aws_system_environment,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the number of processors for the specified compute environment."]
    pub fn aws_system_environment_get_processor_count(env: *mut aws_system_environment) -> usize;
}
extern "C" {
    #[doc = " Returns the number of separate cpu groupings (multi-socket configurations or NUMA)."]
    pub fn aws_system_environment_get_cpu_group_count(env: *const aws_system_environment) -> usize;
}
extern "C" {
    pub fn aws_get_platform_build_os() -> aws_platform_os;
}
extern "C" {
    pub fn aws_system_info_processor_count() -> usize;
}
extern "C" {
    #[doc = " Returns the logical processor groupings on the system (such as multiple numa nodes)."]
    pub fn aws_get_cpu_group_count() -> u16;
}
extern "C" {
    #[doc = " For a group, returns the number of CPUs it contains."]
    pub fn aws_get_cpu_count_for_group(group_idx: u16) -> usize;
}
extern "C" {
    #[doc = " Fills in cpu_ids_array with the cpu_id's for the group. To obtain the size to allocate for cpu_ids_array\n and the value for argument for cpu_ids_array_length, call aws_get_cpu_count_for_group()."]
    pub fn aws_get_cpu_ids_for_group(
        group_idx: u16,
        cpu_ids_array: *mut aws_cpu_info,
        cpu_ids_array_length: usize,
    );
}
extern "C" {
    pub fn aws_is_debugger_present() -> bool;
}
extern "C" {
    pub fn aws_debug_break();
}
extern "C" {
    pub fn aws_backtrace(
        stack_frames: *mut *mut ::std::os::raw::c_void,
        num_frames: usize,
    ) -> usize;
}
extern "C" {
    pub fn aws_backtrace_symbols(
        stack_frames: *const *mut ::std::os::raw::c_void,
        stack_depth: usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_backtrace_addr2line(
        stack_frames: *const *mut ::std::os::raw::c_void,
        stack_depth: usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Print a backtrace from either the current stack, or (if provided) the current exception/signal\n  call_site_data is siginfo_t* on POSIX, and LPEXCEPTION_POINTERS on Windows, and can be null"]
    pub fn aws_backtrace_print(fp: *mut FILE, call_site_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn aws_backtrace_log(log_level: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_memory_usage_stats {
    pub maxrss: usize,
    pub page_faults: usize,
    pub _reserved: [usize; 8usize],
}
#[test]
fn bindgen_test_layout_aws_memory_usage_stats() {
    const UNINIT: ::std::mem::MaybeUninit<aws_memory_usage_stats> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_memory_usage_stats>(),
        80usize,
        concat!("Size of: ", stringify!(aws_memory_usage_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_memory_usage_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_memory_usage_stats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_usage_stats),
            "::",
            stringify!(maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_faults) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_usage_stats),
            "::",
            stringify!(page_faults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_usage_stats),
            "::",
            stringify!(_reserved)
        )
    );
}
extern "C" {
    pub fn aws_init_memory_usage_for_current_process(
        memory_usage: *mut aws_memory_usage_stats,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_task_status {
    AWS_TASK_STATUS_RUN_READY = 0,
    AWS_TASK_STATUS_CANCELED = 1,
}
#[doc = " A scheduled function."]
pub type aws_task_fn = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut aws_task,
        arg: *mut ::std::os::raw::c_void,
        arg1: aws_task_status,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_task {
    pub fn_: aws_task_fn,
    pub arg: *mut ::std::os::raw::c_void,
    pub timestamp: u64,
    pub node: aws_linked_list_node,
    pub priority_queue_node: aws_priority_queue_node,
    pub type_tag: *const ::std::os::raw::c_char,
    pub abi_extension: aws_task__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_task__bindgen_ty_1 {
    pub scheduled: bool,
    pub reserved: usize,
}
#[test]
fn bindgen_test_layout_aws_task__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aws_task__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_task__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(aws_task__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_task__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheduled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task__bindgen_ty_1),
            "::",
            stringify!(scheduled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_aws_task() {
    const UNINIT: ::std::mem::MaybeUninit<aws_task> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_task>(),
        64usize,
        concat!("Size of: ", stringify!(aws_task))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_task>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_queue_node) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(priority_queue_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_tag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(type_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi_extension) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(abi_extension)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_task_scheduler {
    pub alloc: *mut aws_allocator,
    pub timed_queue: aws_priority_queue,
    pub timed_list: aws_linked_list,
    pub asap_list: aws_linked_list,
}
#[test]
fn bindgen_test_layout_aws_task_scheduler() {
    const UNINIT: ::std::mem::MaybeUninit<aws_task_scheduler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_task_scheduler>(),
        160usize,
        concat!("Size of: ", stringify!(aws_task_scheduler))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_task_scheduler>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_task_scheduler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timed_queue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(timed_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timed_list) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(timed_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asap_list) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(asap_list)
        )
    );
}
extern "C" {
    #[doc = " Init an aws_task"]
    pub fn aws_task_init(
        task: *mut aws_task,
        fn_: aws_task_fn,
        arg: *mut ::std::os::raw::c_void,
        type_tag: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn aws_task_run(task: *mut aws_task, status: aws_task_status);
}
extern "C" {
    #[doc = " Initializes a task scheduler instance."]
    pub fn aws_task_scheduler_init(
        scheduler: *mut aws_task_scheduler,
        alloc: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Empties and executes all queued tasks, passing the AWS_TASK_STATUS_CANCELED status to the task function.\n Cleans up any memory allocated, and prepares the instance for reuse or deletion."]
    pub fn aws_task_scheduler_clean_up(scheduler: *mut aws_task_scheduler);
}
extern "C" {
    pub fn aws_task_scheduler_is_valid(scheduler: *const aws_task_scheduler) -> bool;
}
extern "C" {
    #[doc = " Returns whether the scheduler has any scheduled tasks.\n next_task_time (optional) will be set to time of the next task, note that 0 will be set if tasks were\n added via aws_task_scheduler_schedule_now() and UINT64_MAX will be set if no tasks are scheduled at all."]
    pub fn aws_task_scheduler_has_tasks(
        scheduler: *const aws_task_scheduler,
        next_task_time: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Schedules a task to run immediately.\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_task_scheduler_schedule_now(scheduler: *mut aws_task_scheduler, task: *mut aws_task);
}
extern "C" {
    #[doc = " Schedules a task to run at time_to_run.\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_task_scheduler_schedule_future(
        scheduler: *mut aws_task_scheduler,
        task: *mut aws_task,
        time_to_run: u64,
    );
}
extern "C" {
    #[doc = " Removes task from the scheduler and invokes the task with the AWS_TASK_STATUS_CANCELED status."]
    pub fn aws_task_scheduler_cancel_task(scheduler: *mut aws_task_scheduler, task: *mut aws_task);
}
extern "C" {
    #[doc = " Sequentially execute all tasks scheduled to run at, or before current_time.\n AWS_TASK_STATUS_RUN_READY will be passed to the task function as the task status.\n\n If a task schedules another task, the new task will not be executed until the next call to this function."]
    pub fn aws_task_scheduler_run_all(scheduler: *mut aws_task_scheduler, current_time: u64);
}
extern "C" {
    #[doc = " Convert a status value to a c-string suitable for logging"]
    pub fn aws_task_status_to_c_str(status: aws_task_status) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread_scheduler {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new instance of a thread scheduler. This object receives scheduled tasks and executes them inside a\n background thread. On success, this function returns an instance with a ref-count of 1. On failure it returns NULL.\n\n thread_options are optional.\n\n The semantics of this interface conform to the semantics of aws_task_scheduler."]
    pub fn aws_thread_scheduler_new(
        allocator: *mut aws_allocator,
        thread_options: *const aws_thread_options,
    ) -> *mut aws_thread_scheduler;
}
extern "C" {
    #[doc = " Acquire a reference to the scheduler."]
    pub fn aws_thread_scheduler_acquire(scheduler: *mut aws_thread_scheduler);
}
extern "C" {
    #[doc = " Release a reference to the scheduler."]
    pub fn aws_thread_scheduler_release(scheduler: *const aws_thread_scheduler);
}
extern "C" {
    #[doc = " Schedules a task to run in the future. time_to_run is the absolute time from the system hw_clock."]
    pub fn aws_thread_scheduler_schedule_future(
        scheduler: *mut aws_thread_scheduler,
        task: *mut aws_task,
        time_to_run: u64,
    );
}
extern "C" {
    #[doc = " Schedules a task to run as soon as possible."]
    pub fn aws_thread_scheduler_schedule_now(
        scheduler: *mut aws_thread_scheduler,
        task: *mut aws_task,
    );
}
extern "C" {
    #[doc = " Cancel a task that has been scheduled. The cancellation callback will be invoked in the background thread.\n This function is slow, so please don't do it in the hot path for your code."]
    pub fn aws_thread_scheduler_cancel_task(
        scheduler: *mut aws_thread_scheduler,
        task: *mut aws_task,
    );
}
extern "C" {
    #[doc = " Cross platform friendly version of timegm"]
    pub fn aws_timegm(t: *mut tm) -> time_t;
}
extern "C" {
    #[doc = " Cross platform friendly version of localtime_r"]
    pub fn aws_localtime(time: time_t, t: *mut tm);
}
extern "C" {
    #[doc = " Cross platform friendly version of gmtime_r"]
    pub fn aws_gmtime(time: time_t, t: *mut tm);
}
#[doc = " Data representing a URI. uri_str is always allocated and filled in.\n The other portions are merely storing offsets into uri_str."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri {
    pub self_size: usize,
    pub allocator: *mut aws_allocator,
    pub uri_str: aws_byte_buf,
    pub scheme: aws_byte_cursor,
    pub authority: aws_byte_cursor,
    pub userinfo: aws_byte_cursor,
    pub user: aws_byte_cursor,
    pub password: aws_byte_cursor,
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub path: aws_byte_cursor,
    pub query_string: aws_byte_cursor,
    pub path_and_query: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_uri() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uri> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uri>(),
        200usize,
        concat!("Size of: ", stringify!(aws_uri))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uri>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_uri))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(self_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri_str) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(uri_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authority) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(authority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userinfo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(userinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_string) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(query_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_and_query) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(path_and_query)
        )
    );
}
#[doc = " key/value pairs for a query string. If the query fragment was not in format key=value, the fragment value\n will be stored in key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri_param {
    pub key: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_uri_param() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uri_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uri_param>(),
        32usize,
        concat!("Size of: ", stringify!(aws_uri_param))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uri_param>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_uri_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_param),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_param),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Arguments for building a URI instance. All members must\n be initialized before passing them to aws_uri_init().\n\n query_string and query_params are exclusive to each other. If you set\n query_string, do not prepend it with '?'"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri_builder_options {
    pub scheme: aws_byte_cursor,
    pub path: aws_byte_cursor,
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub query_params: *mut aws_array_list,
    pub query_string: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_uri_builder_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uri_builder_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uri_builder_options>(),
        80usize,
        concat!("Size of: ", stringify!(aws_uri_builder_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uri_builder_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_uri_builder_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_params) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(query_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_string) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(query_string)
        )
    );
}
extern "C" {
    #[doc = " Parses 'uri_str' and initializes uri. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure.\n After calling this function, the parts can be accessed."]
    pub fn aws_uri_init_parse(
        uri: *mut aws_uri,
        allocator: *mut aws_allocator,
        uri_str: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes uri to values specified in options. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure.\n After calling this function, the parts can be accessed."]
    pub fn aws_uri_init_from_builder_options(
        uri: *mut aws_uri,
        allocator: *mut aws_allocator,
        options: *mut aws_uri_builder_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_uri_clean_up(uri: *mut aws_uri);
}
extern "C" {
    #[doc = " Returns the scheme portion of the uri (e.g. http, https, ftp, ftps, etc...). If the scheme was not present\n in the uri, the returned value will be empty. It is the users job to determine the appropriate defaults\n if this field is empty, based on protocol, port, etc..."]
    pub fn aws_uri_scheme(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the authority portion of the uri (host[:port]). If it was not present, this was a request uri. In that\n case, the value will be empty."]
    pub fn aws_uri_authority(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the path portion of the uri, including any leading '/'. If not present, this value will be empty."]
    pub fn aws_uri_path(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the query string portion of the uri, minus the '?'. If not present, this value will be empty."]
    pub fn aws_uri_query_string(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the 'host_name' portion of the authority. If no authority was present, this value will be empty."]
    pub fn aws_uri_host_name(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the port portion of the authority if it was present, otherwise, returns 0.\n If this is 0, it is the users job to determine the correct port based on scheme and protocol."]
    pub fn aws_uri_port(uri: *const aws_uri) -> u32;
}
extern "C" {
    #[doc = " Returns the path and query portion of the uri (i.e., the thing you send across the wire)."]
    pub fn aws_uri_path_and_query(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " For iterating over the params in the query string.\n `param` is an in/out argument used to track progress, it MUST be zeroed out to start.\n If true is returned, `param` contains the value of the next param.\n If false is returned, there are no further params.\n\n Edge cases:\n 1) Entries without '=' sign are treated as having a key and no value.\n    Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\n 2) Blank entries are skipped.\n    Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\""]
    pub fn aws_query_string_next_param(
        query_string: aws_byte_cursor,
        param: *mut aws_uri_param,
    ) -> bool;
}
extern "C" {
    #[doc = " Parses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and\n AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param.\n The user is also responsible for cleaning up out_params when finished."]
    pub fn aws_query_string_params(
        query_string: aws_byte_cursor,
        out_params: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For iterating over the params in the uri query string.\n `param` is an in/out argument used to track progress, it MUST be zeroed out to start.\n If true is returned, `param` contains the value of the next param.\n If false is returned, there are no further params.\n\n Edge cases:\n 1) Entries without '=' sign are treated as having a key and no value.\n    Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\n 2) Blank entries are skipped.\n    Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\""]
    pub fn aws_uri_query_string_next_param(uri: *const aws_uri, param: *mut aws_uri_param) -> bool;
}
extern "C" {
    #[doc = " Parses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and\n AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param.\n The user is also responsible for cleaning up out_params when finished."]
    pub fn aws_uri_query_string_params(
        uri: *const aws_uri,
        out_params: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the uri path encoding of a cursor to a buffer.  This is the modified version of rfc3986 used by\n sigv4 signing."]
    pub fn aws_byte_buf_append_encoding_uri_path(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the uri query param encoding (passthrough alnum + '-' '_' '~' '.') of a UTF-8 cursor to a buffer\n For example, reading \"a b_c\" would write \"a%20b_c\"."]
    pub fn aws_byte_buf_append_encoding_uri_param(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the uri decoding of a UTF-8 cursor to a buffer,\n replacing %xx escapes by their single byte equivalent.\n For example, reading \"a%20b_c\" would write \"a b_c\"."]
    pub fn aws_byte_buf_append_decoding_uri(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uuid {
    pub uuid_data: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_aws_uuid() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uuid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uuid>(),
        16usize,
        concat!("Size of: ", stringify!(aws_uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uuid>(),
        1usize,
        concat!("Alignment of ", stringify!(aws_uuid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uuid_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uuid),
            "::",
            stringify!(uuid_data)
        )
    );
}
pub const AWS_UUID_STR_LEN: _bindgen_ty_8 = _bindgen_ty_8::AWS_UUID_STR_LEN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_8 {
    AWS_UUID_STR_LEN = 37,
}
extern "C" {
    pub fn aws_uuid_init(uuid: *mut aws_uuid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_uuid_init_from_str(
        uuid: *mut aws_uuid,
        uuid_str: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_uuid_to_str(
        uuid: *const aws_uuid,
        output: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_uuid_equals(a: *const aws_uuid, b: *const aws_uuid) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_xml_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_xml_attribute {
    pub name: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_xml_attribute() {
    const UNINIT: ::std::mem::MaybeUninit<aws_xml_attribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_xml_attribute>(),
        32usize,
        concat!("Size of: ", stringify!(aws_xml_attribute))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_xml_attribute>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_xml_attribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_xml_attribute),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_xml_attribute),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Callback for when an xml node is encountered in the document. As a user you have a few options:\n\n 1. fail the parse by returning AWS_OP_ERR (after an error has been raised). This will stop any further parsing.\n 2. call aws_xml_node_traverse() on the node to descend into the node with a new callback and user_data.\n 3. call aws_xml_node_as_body() to retrieve the contents of the node as text.\n\n You MUST NOT call both aws_xml_node_traverse() and aws_xml_node_as_body() on the same node.\n\n return true to continue the parsing operation."]
pub type aws_xml_parser_on_node_encountered_fn = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut aws_xml_node,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_xml_parser_options {
    pub doc: aws_byte_cursor,
    pub max_depth: usize,
    pub on_root_encountered: aws_xml_parser_on_node_encountered_fn,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_xml_parser_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_xml_parser_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_xml_parser_options>(),
        40usize,
        concat!("Size of: ", stringify!(aws_xml_parser_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_xml_parser_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_xml_parser_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_xml_parser_options),
            "::",
            stringify!(doc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_depth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_xml_parser_options),
            "::",
            stringify!(max_depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_root_encountered) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_xml_parser_options),
            "::",
            stringify!(on_root_encountered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_xml_parser_options),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    #[doc = " Parse an XML document.\n WARNING: This is not a public API. It is only intended for use within the aws-c libraries."]
    pub fn aws_xml_parse(
        allocator: *mut aws_allocator,
        options: *const aws_xml_parser_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the contents of the body of node into out_body. out_body is an output parameter in this case. Upon success,\n out_body will contain the body of the node."]
    pub fn aws_xml_node_as_body(
        node: *mut aws_xml_node,
        out_body: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traverse node and invoke on_node_encountered when a nested node is encountered."]
    pub fn aws_xml_node_traverse(
        node: *mut aws_xml_node,
        on_node_encountered: aws_xml_parser_on_node_encountered_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_xml_node_get_name(node: *const aws_xml_node) -> aws_byte_cursor;
}
extern "C" {
    pub fn aws_xml_node_get_num_attributes(node: *const aws_xml_node) -> usize;
}
extern "C" {
    pub fn aws_xml_node_get_attribute(
        node: *const aws_xml_node,
        attribute_index: usize,
    ) -> aws_xml_attribute;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
