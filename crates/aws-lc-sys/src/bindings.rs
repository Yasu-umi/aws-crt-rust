/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140400;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const DYNAMIC_TARGETS_ENABLED: u32 = 0;
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_MACCATALYST: u32 = 0;
pub const TARGET_OS_UIKITFORMAC: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_RTKIT: u32 = 0;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_CPU_ARM64: u32 = 1;
pub const TARGET_OS_VISION: u32 = 0;
pub const TARGET_OS_DRIVERKIT: u32 = 0;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_WINDOWS: u32 = 0;
pub const TARGET_OS_LINUX: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 0;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const AWSLC_VERSION_NAME: &[u8; 7] = b"AWS-LC\0";
pub const OPENSSL_VERSION_NUMBER: u32 = 269488255;
pub const SSLEAY_VERSION_NUMBER: u32 = 269488255;
pub const AWSLC_API_VERSION: u32 = 29;
pub const AWSLC_VERSION_NUMBER_STRING: &[u8; 7] = b"1.32.0\0";
pub const EVP_AEAD_MAX_KEY_LENGTH: u32 = 80;
pub const EVP_AEAD_MAX_NONCE_LENGTH: u32 = 24;
pub const EVP_AEAD_MAX_OVERHEAD: u32 = 64;
pub const EVP_AEAD_DEFAULT_TAG_LENGTH: u32 = 0;
pub const FIPS_AES_GCM_NONCE_LENGTH: u32 = 12;
pub const AES_ENCRYPT: u32 = 1;
pub const AES_DECRYPT: u32 = 0;
pub const AES_MAXNR: u32 = 14;
pub const AES_BLOCK_SIZE: u32 = 16;
pub const ARMV7_NEON: u32 = 1;
pub const ARMV8_AES: u32 = 4;
pub const ARMV8_SHA1: u32 = 8;
pub const ARMV8_SHA256: u32 = 16;
pub const ARMV8_PMULL: u32 = 32;
pub const ARMV8_SHA512: u32 = 64;
pub const ARMV8_SHA3: u32 = 2048;
pub const ARMV8_NEOVERSE_V1: u32 = 4096;
pub const ARMV8_APPLE_M1: u32 = 8192;
pub const ARMV8_NEOVERSE_V2: u32 = 16384;
pub const ARM_CPU_IMP_ARM: u32 = 65;
pub const ARM_CPU_PART_CORTEX_A72: u32 = 3336;
pub const ARM_CPU_PART_N1: u32 = 3340;
pub const ARM_CPU_PART_V1: u32 = 3392;
pub const ARM_CPU_PART_V2: u32 = 3407;
pub const MIDR_PARTNUM_SHIFT: u32 = 4;
pub const MIDR_PARTNUM_MASK: u32 = 65520;
pub const MIDR_IMPLEMENTER_SHIFT: u32 = 24;
pub const MIDR_IMPLEMENTER_MASK: u32 = 4278190080;
pub const MIDR_ARCHITECTURE_SHIFT: u32 = 16;
pub const MIDR_ARCHITECTURE_MASK: u32 = 983040;
pub const MIDR_CPU_MODEL_MASK: u32 = 4279238640;
pub const TIME_UTC: u32 = 1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const SHA_CBLOCK: u32 = 64;
pub const SHA_DIGEST_LENGTH: u32 = 20;
pub const SHA224_CBLOCK: u32 = 64;
pub const SHA224_DIGEST_LENGTH: u32 = 28;
pub const SHA256_CBLOCK: u32 = 64;
pub const SHA256_DIGEST_LENGTH: u32 = 32;
pub const SHA384_CBLOCK: u32 = 128;
pub const SHA384_DIGEST_LENGTH: u32 = 48;
pub const SHA512_CBLOCK: u32 = 128;
pub const SHA512_DIGEST_LENGTH: u32 = 64;
pub const SHA512_224_DIGEST_LENGTH: u32 = 28;
pub const SHA512_256_DIGEST_LENGTH: u32 = 32;
pub const __GNUC_VA_LIST: u32 = 1;
pub const CRYPTO_LOCK: u32 = 1;
pub const CRYPTO_UNLOCK: u32 = 2;
pub const CRYPTO_READ: u32 = 4;
pub const CRYPTO_WRITE: u32 = 8;
pub const OPENSSL_VERSION_TEXT: &[u8; 42] = b"OpenSSL 1.1.1 (compatible; AWS-LC 1.32.0)\0";
pub const OPENSSL_VERSION: u32 = 0;
pub const OPENSSL_CFLAGS: u32 = 1;
pub const OPENSSL_BUILT_ON: u32 = 2;
pub const OPENSSL_PLATFORM: u32 = 3;
pub const OPENSSL_DIR: u32 = 4;
pub const SSLEAY_VERSION: u32 = 0;
pub const SSLEAY_CFLAGS: u32 = 1;
pub const SSLEAY_BUILT_ON: u32 = 2;
pub const SSLEAY_PLATFORM: u32 = 3;
pub const SSLEAY_DIR: u32 = 4;
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS: u32 = 0;
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS: u32 = 0;
pub const OPENSSL_INIT_ADD_ALL_CIPHERS: u32 = 0;
pub const OPENSSL_INIT_ADD_ALL_DIGESTS: u32 = 0;
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS: u32 = 0;
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS: u32 = 0;
pub const OPENSSL_INIT_LOAD_CONFIG: u32 = 0;
pub const OPENSSL_INIT_NO_LOAD_CONFIG: u32 = 0;
pub const OPENSSL_INIT_ENGINE_ALL_BUILTIN: u32 = 0;
pub const ERR_FLAG_STRING: u32 = 1;
pub const ERR_FLAG_MALLOCED: u32 = 2;
pub const ERR_LIB_NONE: u32 = 1;
pub const ERR_LIB_SYS: u32 = 2;
pub const ERR_LIB_BN: u32 = 3;
pub const ERR_LIB_RSA: u32 = 4;
pub const ERR_LIB_DH: u32 = 5;
pub const ERR_LIB_EVP: u32 = 6;
pub const ERR_LIB_BUF: u32 = 7;
pub const ERR_LIB_OBJ: u32 = 8;
pub const ERR_LIB_PEM: u32 = 9;
pub const ERR_LIB_DSA: u32 = 10;
pub const ERR_LIB_X509: u32 = 11;
pub const ERR_LIB_ASN1: u32 = 12;
pub const ERR_LIB_CONF: u32 = 13;
pub const ERR_LIB_CRYPTO: u32 = 14;
pub const ERR_LIB_EC: u32 = 15;
pub const ERR_LIB_SSL: u32 = 16;
pub const ERR_LIB_BIO: u32 = 17;
pub const ERR_LIB_PKCS7: u32 = 18;
pub const ERR_LIB_PKCS8: u32 = 19;
pub const ERR_LIB_X509V3: u32 = 20;
pub const ERR_LIB_RAND: u32 = 21;
pub const ERR_LIB_ENGINE: u32 = 22;
pub const ERR_LIB_OCSP: u32 = 23;
pub const ERR_LIB_UI: u32 = 24;
pub const ERR_LIB_COMP: u32 = 25;
pub const ERR_LIB_ECDSA: u32 = 26;
pub const ERR_LIB_ECDH: u32 = 27;
pub const ERR_LIB_HMAC: u32 = 28;
pub const ERR_LIB_DIGEST: u32 = 29;
pub const ERR_LIB_CIPHER: u32 = 30;
pub const ERR_LIB_HKDF: u32 = 31;
pub const ERR_LIB_TRUST_TOKEN: u32 = 32;
pub const ERR_LIB_USER: u32 = 33;
pub const ERR_NUM_LIBS: u32 = 34;
pub const ERR_LIB_PKCS12: u32 = 35;
pub const ERR_LIB_DSO: u32 = 36;
pub const ERR_LIB_OSSL_STORE: u32 = 37;
pub const ERR_LIB_FIPS: u32 = 38;
pub const ERR_LIB_CMS: u32 = 39;
pub const ERR_LIB_TS: u32 = 40;
pub const ERR_LIB_CT: u32 = 41;
pub const ERR_LIB_ASYNC: u32 = 42;
pub const ERR_LIB_KDF: u32 = 43;
pub const ERR_LIB_SM2: u32 = 44;
pub const ERR_R_SYS_LIB: u32 = 2;
pub const ERR_R_BN_LIB: u32 = 3;
pub const ERR_R_RSA_LIB: u32 = 4;
pub const ERR_R_DH_LIB: u32 = 5;
pub const ERR_R_EVP_LIB: u32 = 6;
pub const ERR_R_BUF_LIB: u32 = 7;
pub const ERR_R_OBJ_LIB: u32 = 8;
pub const ERR_R_PEM_LIB: u32 = 9;
pub const ERR_R_DSA_LIB: u32 = 10;
pub const ERR_R_X509_LIB: u32 = 11;
pub const ERR_R_ASN1_LIB: u32 = 12;
pub const ERR_R_CONF_LIB: u32 = 13;
pub const ERR_R_CRYPTO_LIB: u32 = 14;
pub const ERR_R_EC_LIB: u32 = 15;
pub const ERR_R_SSL_LIB: u32 = 16;
pub const ERR_R_BIO_LIB: u32 = 17;
pub const ERR_R_PKCS7_LIB: u32 = 18;
pub const ERR_R_PKCS8_LIB: u32 = 19;
pub const ERR_R_X509V3_LIB: u32 = 20;
pub const ERR_R_RAND_LIB: u32 = 21;
pub const ERR_R_DSO_LIB: u32 = 36;
pub const ERR_R_ENGINE_LIB: u32 = 22;
pub const ERR_R_OCSP_LIB: u32 = 23;
pub const ERR_R_UI_LIB: u32 = 24;
pub const ERR_R_COMP_LIB: u32 = 25;
pub const ERR_R_ECDSA_LIB: u32 = 26;
pub const ERR_R_ECDH_LIB: u32 = 27;
pub const ERR_R_FIPS_LIB: u32 = 38;
pub const ERR_R_CMS_LIB: u32 = 39;
pub const ERR_R_TS_LIB: u32 = 40;
pub const ERR_R_HMAC_LIB: u32 = 28;
pub const ERR_R_USER_LIB: u32 = 33;
pub const ERR_R_DIGEST_LIB: u32 = 29;
pub const ERR_R_CIPHER_LIB: u32 = 30;
pub const ERR_R_HKDF_LIB: u32 = 31;
pub const ERR_R_TRUST_TOKEN_LIB: u32 = 32;
pub const ERR_R_FATAL: u32 = 64;
pub const ERR_R_MALLOC_FAILURE: u32 = 65;
pub const ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED: u32 = 66;
pub const ERR_R_PASSED_NULL_PARAMETER: u32 = 67;
pub const ERR_R_INTERNAL_ERROR: u32 = 68;
pub const ERR_R_OVERFLOW: u32 = 69;
pub const ERR_ERROR_STRING_BUF_LEN: u32 = 120;
pub const ERR_TXT_STRING: u32 = 1;
pub const ERR_TXT_MALLOCED: u32 = 2;
pub const ERR_NUM_ERRORS: u32 = 16;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const BIO_RR_CONNECT: u32 = 2;
pub const BIO_RR_ACCEPT: u32 = 3;
pub const BIO_CB_FREE: u32 = 1;
pub const BIO_CB_READ: u32 = 2;
pub const BIO_CB_WRITE: u32 = 3;
pub const BIO_CB_PUTS: u32 = 4;
pub const BIO_CB_GETS: u32 = 5;
pub const BIO_CB_CTRL: u32 = 6;
pub const BIO_CB_RETURN: u32 = 128;
pub const BIO_NOCLOSE: u32 = 0;
pub const BIO_CLOSE: u32 = 1;
pub const BIO_FP_TEXT: u32 = 16;
pub const BIO_CTRL_DGRAM_QUERY_MTU: u32 = 40;
pub const BIO_CTRL_DGRAM_SET_MTU: u32 = 42;
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED: u32 = 43;
pub const BIO_CTRL_DGRAM_GET_PEER: u32 = 46;
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU: u32 = 47;
pub const BIO_CTRL_RESET: u32 = 1;
pub const BIO_CTRL_EOF: u32 = 2;
pub const BIO_CTRL_INFO: u32 = 3;
pub const BIO_CTRL_GET_CLOSE: u32 = 8;
pub const BIO_CTRL_SET_CLOSE: u32 = 9;
pub const BIO_CTRL_PENDING: u32 = 10;
pub const BIO_CTRL_FLUSH: u32 = 11;
pub const BIO_CTRL_WPENDING: u32 = 13;
pub const BIO_CTRL_SET_CALLBACK: u32 = 14;
pub const BIO_CTRL_GET_CALLBACK: u32 = 15;
pub const BIO_CTRL_SET: u32 = 4;
pub const BIO_CTRL_GET: u32 = 5;
pub const BIO_CTRL_PUSH: u32 = 6;
pub const BIO_CTRL_POP: u32 = 7;
pub const BIO_CTRL_DUP: u32 = 12;
pub const BIO_CTRL_SET_FILENAME: u32 = 30;
pub const BIO_FLAGS_READ: u32 = 1;
pub const BIO_FLAGS_WRITE: u32 = 2;
pub const BIO_FLAGS_IO_SPECIAL: u32 = 4;
pub const BIO_FLAGS_RWS: u32 = 7;
pub const BIO_FLAGS_SHOULD_RETRY: u32 = 8;
pub const BIO_FLAGS_BASE64_NO_NL: u32 = 256;
pub const BIO_FLAGS_MEM_RDONLY: u32 = 512;
pub const BIO_TYPE_NONE: u32 = 0;
pub const BIO_TYPE_MEM: u32 = 1025;
pub const BIO_TYPE_FILE: u32 = 1026;
pub const BIO_TYPE_FD: u32 = 1284;
pub const BIO_TYPE_SOCKET: u32 = 1285;
pub const BIO_TYPE_NULL: u32 = 1030;
pub const BIO_TYPE_SSL: u32 = 519;
pub const BIO_TYPE_MD: u32 = 520;
pub const BIO_TYPE_BUFFER: u32 = 521;
pub const BIO_TYPE_CIPHER: u32 = 522;
pub const BIO_TYPE_BASE64: u32 = 523;
pub const BIO_TYPE_CONNECT: u32 = 1292;
pub const BIO_TYPE_ACCEPT: u32 = 1293;
pub const BIO_TYPE_PROXY_CLIENT: u32 = 526;
pub const BIO_TYPE_PROXY_SERVER: u32 = 527;
pub const BIO_TYPE_NBIO_TEST: u32 = 528;
pub const BIO_TYPE_NULL_FILTER: u32 = 529;
pub const BIO_TYPE_BER: u32 = 530;
pub const BIO_TYPE_BIO: u32 = 1043;
pub const BIO_TYPE_LINEBUFFER: u32 = 532;
pub const BIO_TYPE_DGRAM: u32 = 1301;
pub const BIO_TYPE_ASN1: u32 = 534;
pub const BIO_TYPE_COMP: u32 = 535;
pub const BIO_TYPE_DESCRIPTOR: u32 = 256;
pub const BIO_TYPE_FILTER: u32 = 512;
pub const BIO_TYPE_SOURCE_SINK: u32 = 1024;
pub const BIO_TYPE_START: u32 = 128;
pub const BIO_C_SET_CONNECT: u32 = 100;
pub const BIO_C_DO_STATE_MACHINE: u32 = 101;
pub const BIO_C_SET_NBIO: u32 = 102;
pub const BIO_C_SET_PROXY_PARAM: u32 = 103;
pub const BIO_C_SET_FD: u32 = 104;
pub const BIO_C_GET_FD: u32 = 105;
pub const BIO_C_SET_FILE_PTR: u32 = 106;
pub const BIO_C_GET_FILE_PTR: u32 = 107;
pub const BIO_C_SET_FILENAME: u32 = 108;
pub const BIO_C_SET_SSL: u32 = 109;
pub const BIO_C_SET_MD: u32 = 111;
pub const BIO_C_GET_MD: u32 = 112;
pub const BIO_C_GET_CIPHER_STATUS: u32 = 113;
pub const BIO_C_SET_BUF_MEM: u32 = 114;
pub const BIO_C_GET_BUF_MEM_PTR: u32 = 115;
pub const BIO_C_GET_BUFF_NUM_LINES: u32 = 116;
pub const BIO_C_SET_BUFF_SIZE: u32 = 117;
pub const BIO_C_SET_ACCEPT: u32 = 118;
pub const BIO_C_SSL_MODE: u32 = 119;
pub const BIO_C_GET_MD_CTX: u32 = 120;
pub const BIO_C_GET_PROXY_PARAM: u32 = 121;
pub const BIO_C_SET_BUFF_READ_DATA: u32 = 122;
pub const BIO_C_GET_ACCEPT: u32 = 124;
pub const BIO_C_FILE_SEEK: u32 = 128;
pub const BIO_C_GET_CIPHER_CTX: u32 = 129;
pub const BIO_C_SET_BUF_MEM_EOF_RETURN: u32 = 130;
pub const BIO_C_SET_BIND_MODE: u32 = 131;
pub const BIO_C_GET_BIND_MODE: u32 = 132;
pub const BIO_C_FILE_TELL: u32 = 133;
pub const BIO_C_GET_SOCKS: u32 = 134;
pub const BIO_C_SET_SOCKS: u32 = 135;
pub const BIO_C_SET_WRITE_BUF_SIZE: u32 = 136;
pub const BIO_C_GET_WRITE_BUF_SIZE: u32 = 137;
pub const BIO_C_GET_WRITE_GUARANTEE: u32 = 140;
pub const BIO_C_GET_READ_REQUEST: u32 = 141;
pub const BIO_C_SHUTDOWN_WR: u32 = 142;
pub const BIO_C_NREAD0: u32 = 143;
pub const BIO_C_NREAD: u32 = 144;
pub const BIO_C_NWRITE0: u32 = 145;
pub const BIO_C_NWRITE: u32 = 146;
pub const BIO_C_RESET_READ_REQUEST: u32 = 147;
pub const BIO_C_SET_MD_CTX: u32 = 148;
pub const BIO_C_SET_PREFIX: u32 = 149;
pub const BIO_C_GET_PREFIX: u32 = 150;
pub const BIO_C_SET_SUFFIX: u32 = 151;
pub const BIO_C_GET_SUFFIX: u32 = 152;
pub const BIO_C_SET_EX_ARG: u32 = 153;
pub const BIO_C_GET_EX_ARG: u32 = 154;
pub const BIO_R_BAD_FOPEN_MODE: u32 = 100;
pub const BIO_R_BROKEN_PIPE: u32 = 101;
pub const BIO_R_CONNECT_ERROR: u32 = 102;
pub const BIO_R_ERROR_SETTING_NBIO: u32 = 103;
pub const BIO_R_INVALID_ARGUMENT: u32 = 104;
pub const BIO_R_IN_USE: u32 = 105;
pub const BIO_R_KEEPALIVE: u32 = 106;
pub const BIO_R_NBIO_CONNECT_ERROR: u32 = 107;
pub const BIO_R_NO_HOSTNAME_SPECIFIED: u32 = 108;
pub const BIO_R_NO_PORT_SPECIFIED: u32 = 109;
pub const BIO_R_NO_SUCH_FILE: u32 = 110;
pub const BIO_R_NULL_PARAMETER: u32 = 111;
pub const BIO_R_SYS_LIB: u32 = 112;
pub const BIO_R_UNABLE_TO_CREATE_SOCKET: u32 = 113;
pub const BIO_R_UNINITIALIZED: u32 = 114;
pub const BIO_R_UNSUPPORTED_METHOD: u32 = 115;
pub const BIO_R_WRITE_TO_READ_ONLY_BIO: u32 = 116;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const BN_BITS2: u32 = 64;
pub const BN_DEC_FMT1: &[u8; 5] = b"%llu\0";
pub const BN_HEX_FMT1: &[u8; 5] = b"%llx\0";
pub const BN_HEX_FMT2: &[u8; 8] = b"%016llx\0";
pub const BN_RAND_TOP_ANY: i32 = -1;
pub const BN_RAND_TOP_ONE: u32 = 0;
pub const BN_RAND_TOP_TWO: u32 = 1;
pub const BN_RAND_BOTTOM_ANY: u32 = 0;
pub const BN_RAND_BOTTOM_ODD: u32 = 1;
pub const BN_GENCB_GENERATED: u32 = 0;
pub const BN_GENCB_PRIME_TEST: u32 = 1;
pub const BN_prime_checks_for_validation: u32 = 64;
pub const BN_prime_checks_for_generation: u32 = 0;
pub const BN_prime_checks: u32 = 64;
pub const BN_FLG_MALLOCED: u32 = 1;
pub const BN_FLG_STATIC_DATA: u32 = 2;
pub const BN_R_ARG2_LT_ARG3: u32 = 100;
pub const BN_R_BAD_RECIPROCAL: u32 = 101;
pub const BN_R_BIGNUM_TOO_LONG: u32 = 102;
pub const BN_R_BITS_TOO_SMALL: u32 = 103;
pub const BN_R_CALLED_WITH_EVEN_MODULUS: u32 = 104;
pub const BN_R_DIV_BY_ZERO: u32 = 105;
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA: u32 = 106;
pub const BN_R_INPUT_NOT_REDUCED: u32 = 107;
pub const BN_R_INVALID_RANGE: u32 = 108;
pub const BN_R_NEGATIVE_NUMBER: u32 = 109;
pub const BN_R_NOT_A_SQUARE: u32 = 110;
pub const BN_R_NOT_INITIALIZED: u32 = 111;
pub const BN_R_NO_INVERSE: u32 = 112;
pub const BN_R_PRIVATE_KEY_TOO_LARGE: u32 = 113;
pub const BN_R_P_IS_NOT_PRIME: u32 = 114;
pub const BN_R_TOO_MANY_ITERATIONS: u32 = 115;
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES: u32 = 116;
pub const BN_R_BAD_ENCODING: u32 = 117;
pub const BN_R_ENCODE_ERROR: u32 = 118;
pub const BN_R_INVALID_INPUT: u32 = 119;
pub const BN_F_BN_GENERATE_PRIME_EX: u32 = 0;
pub const V_ASN1_UNIVERSAL: u32 = 0;
pub const V_ASN1_APPLICATION: u32 = 64;
pub const V_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const V_ASN1_PRIVATE: u32 = 192;
pub const V_ASN1_CONSTRUCTED: u32 = 32;
pub const V_ASN1_PRIMITIVE_TAG: u32 = 31;
pub const V_ASN1_MAX_UNIVERSAL: u32 = 255;
pub const V_ASN1_UNDEF: i32 = -1;
pub const V_ASN1_OTHER: i32 = -3;
pub const V_ASN1_ANY: i32 = -4;
pub const V_ASN1_EOC: u32 = 0;
pub const V_ASN1_BOOLEAN: u32 = 1;
pub const V_ASN1_INTEGER: u32 = 2;
pub const V_ASN1_BIT_STRING: u32 = 3;
pub const V_ASN1_OCTET_STRING: u32 = 4;
pub const V_ASN1_NULL: u32 = 5;
pub const V_ASN1_OBJECT: u32 = 6;
pub const V_ASN1_OBJECT_DESCRIPTOR: u32 = 7;
pub const V_ASN1_EXTERNAL: u32 = 8;
pub const V_ASN1_REAL: u32 = 9;
pub const V_ASN1_ENUMERATED: u32 = 10;
pub const V_ASN1_UTF8STRING: u32 = 12;
pub const V_ASN1_SEQUENCE: u32 = 16;
pub const V_ASN1_SET: u32 = 17;
pub const V_ASN1_NUMERICSTRING: u32 = 18;
pub const V_ASN1_PRINTABLESTRING: u32 = 19;
pub const V_ASN1_T61STRING: u32 = 20;
pub const V_ASN1_TELETEXSTRING: u32 = 20;
pub const V_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const V_ASN1_IA5STRING: u32 = 22;
pub const V_ASN1_UTCTIME: u32 = 23;
pub const V_ASN1_GENERALIZEDTIME: u32 = 24;
pub const V_ASN1_GRAPHICSTRING: u32 = 25;
pub const V_ASN1_ISO64STRING: u32 = 26;
pub const V_ASN1_VISIBLESTRING: u32 = 26;
pub const V_ASN1_GENERALSTRING: u32 = 27;
pub const V_ASN1_UNIVERSALSTRING: u32 = 28;
pub const V_ASN1_BMPSTRING: u32 = 30;
pub const V_ASN1_NEG: u32 = 256;
pub const V_ASN1_NEG_INTEGER: u32 = 258;
pub const V_ASN1_NEG_ENUMERATED: u32 = 266;
pub const B_ASN1_NUMERICSTRING: u32 = 1;
pub const B_ASN1_PRINTABLESTRING: u32 = 2;
pub const B_ASN1_T61STRING: u32 = 4;
pub const B_ASN1_TELETEXSTRING: u32 = 4;
pub const B_ASN1_VIDEOTEXSTRING: u32 = 8;
pub const B_ASN1_IA5STRING: u32 = 16;
pub const B_ASN1_GRAPHICSTRING: u32 = 32;
pub const B_ASN1_ISO64STRING: u32 = 64;
pub const B_ASN1_VISIBLESTRING: u32 = 64;
pub const B_ASN1_GENERALSTRING: u32 = 128;
pub const B_ASN1_UNIVERSALSTRING: u32 = 256;
pub const B_ASN1_OCTET_STRING: u32 = 512;
pub const B_ASN1_BIT_STRING: u32 = 1024;
pub const B_ASN1_BMPSTRING: u32 = 2048;
pub const B_ASN1_UNKNOWN: u32 = 4096;
pub const B_ASN1_UTF8STRING: u32 = 8192;
pub const B_ASN1_UTCTIME: u32 = 16384;
pub const B_ASN1_GENERALIZEDTIME: u32 = 32768;
pub const B_ASN1_SEQUENCE: u32 = 65536;
pub const ASN1_BOOLEAN_FALSE: u32 = 0;
pub const ASN1_BOOLEAN_TRUE: u32 = 255;
pub const ASN1_BOOLEAN_NONE: i32 = -1;
pub const ASN1_STRING_FLAG_BITS_LEFT: u32 = 8;
pub const MBSTRING_FLAG: u32 = 4096;
pub const MBSTRING_UTF8: u32 = 4096;
pub const MBSTRING_ASC: u32 = 4097;
pub const MBSTRING_BMP: u32 = 4098;
pub const MBSTRING_UNIV: u32 = 4100;
pub const DIRSTRING_TYPE: u32 = 10246;
pub const PKCS9STRING_TYPE: u32 = 10262;
pub const STABLE_NO_MASK: u32 = 2;
pub const B_ASN1_DIRECTORYSTRING: u32 = 10502;
pub const B_ASN1_DISPLAYTEXT: u32 = 10320;
pub const B_ASN1_TIME: u32 = 49152;
pub const ASN1_STRFLGS_ESC_2253: u32 = 1;
pub const ASN1_STRFLGS_ESC_CTRL: u32 = 2;
pub const ASN1_STRFLGS_ESC_MSB: u32 = 4;
pub const ASN1_STRFLGS_ESC_QUOTE: u32 = 8;
pub const ASN1_STRFLGS_UTF8_CONVERT: u32 = 16;
pub const ASN1_STRFLGS_IGNORE_TYPE: u32 = 32;
pub const ASN1_STRFLGS_SHOW_TYPE: u32 = 64;
pub const ASN1_STRFLGS_DUMP_ALL: u32 = 128;
pub const ASN1_STRFLGS_DUMP_UNKNOWN: u32 = 256;
pub const ASN1_STRFLGS_DUMP_DER: u32 = 512;
pub const ASN1_STRFLGS_RFC2253: u32 = 791;
pub const B_ASN1_PRINTABLE: u32 = 81175;
pub const ASN1_R_ASN1_LENGTH_MISMATCH: u32 = 100;
pub const ASN1_R_AUX_ERROR: u32 = 101;
pub const ASN1_R_BAD_GET_ASN1_OBJECT_CALL: u32 = 102;
pub const ASN1_R_BAD_OBJECT_HEADER: u32 = 103;
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH: u32 = 104;
pub const ASN1_R_BN_LIB: u32 = 105;
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH: u32 = 106;
pub const ASN1_R_BUFFER_TOO_SMALL: u32 = 107;
pub const ASN1_R_CONTEXT_NOT_INITIALISED: u32 = 108;
pub const ASN1_R_DECODE_ERROR: u32 = 109;
pub const ASN1_R_DEPTH_EXCEEDED: u32 = 110;
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED: u32 = 111;
pub const ASN1_R_ENCODE_ERROR: u32 = 112;
pub const ASN1_R_ERROR_GETTING_TIME: u32 = 113;
pub const ASN1_R_EXPECTING_AN_ASN1_SEQUENCE: u32 = 114;
pub const ASN1_R_EXPECTING_AN_INTEGER: u32 = 115;
pub const ASN1_R_EXPECTING_AN_OBJECT: u32 = 116;
pub const ASN1_R_EXPECTING_A_BOOLEAN: u32 = 117;
pub const ASN1_R_EXPECTING_A_TIME: u32 = 118;
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH: u32 = 119;
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED: u32 = 120;
pub const ASN1_R_FIELD_MISSING: u32 = 121;
pub const ASN1_R_FIRST_NUM_TOO_LARGE: u32 = 122;
pub const ASN1_R_HEADER_TOO_LONG: u32 = 123;
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT: u32 = 124;
pub const ASN1_R_ILLEGAL_BOOLEAN: u32 = 125;
pub const ASN1_R_ILLEGAL_CHARACTERS: u32 = 126;
pub const ASN1_R_ILLEGAL_FORMAT: u32 = 127;
pub const ASN1_R_ILLEGAL_HEX: u32 = 128;
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG: u32 = 129;
pub const ASN1_R_ILLEGAL_INTEGER: u32 = 130;
pub const ASN1_R_ILLEGAL_NESTED_TAGGING: u32 = 131;
pub const ASN1_R_ILLEGAL_NULL: u32 = 132;
pub const ASN1_R_ILLEGAL_NULL_VALUE: u32 = 133;
pub const ASN1_R_ILLEGAL_OBJECT: u32 = 134;
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY: u32 = 135;
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE: u32 = 136;
pub const ASN1_R_ILLEGAL_TAGGED_ANY: u32 = 137;
pub const ASN1_R_ILLEGAL_TIME_VALUE: u32 = 138;
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT: u32 = 139;
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG: u32 = 140;
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 141;
pub const ASN1_R_INVALID_BMPSTRING: u32 = 142;
pub const ASN1_R_INVALID_DIGIT: u32 = 143;
pub const ASN1_R_INVALID_MODIFIER: u32 = 144;
pub const ASN1_R_INVALID_NUMBER: u32 = 145;
pub const ASN1_R_INVALID_OBJECT_ENCODING: u32 = 146;
pub const ASN1_R_INVALID_SEPARATOR: u32 = 147;
pub const ASN1_R_INVALID_TIME_FORMAT: u32 = 148;
pub const ASN1_R_INVALID_UNIVERSALSTRING: u32 = 149;
pub const ASN1_R_INVALID_UTF8STRING: u32 = 150;
pub const ASN1_R_LIST_ERROR: u32 = 151;
pub const ASN1_R_MISSING_ASN1_EOS: u32 = 152;
pub const ASN1_R_MISSING_EOC: u32 = 153;
pub const ASN1_R_MISSING_SECOND_NUMBER: u32 = 154;
pub const ASN1_R_MISSING_VALUE: u32 = 155;
pub const ASN1_R_MSTRING_NOT_UNIVERSAL: u32 = 156;
pub const ASN1_R_MSTRING_WRONG_TAG: u32 = 157;
pub const ASN1_R_NESTED_ASN1_ERROR: u32 = 158;
pub const ASN1_R_NESTED_ASN1_STRING: u32 = 159;
pub const ASN1_R_NON_HEX_CHARACTERS: u32 = 160;
pub const ASN1_R_NOT_ASCII_FORMAT: u32 = 161;
pub const ASN1_R_NOT_ENOUGH_DATA: u32 = 162;
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE: u32 = 163;
pub const ASN1_R_NULL_IS_WRONG_LENGTH: u32 = 164;
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT: u32 = 165;
pub const ASN1_R_ODD_NUMBER_OF_CHARS: u32 = 166;
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE: u32 = 167;
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH: u32 = 168;
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED: u32 = 169;
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG: u32 = 170;
pub const ASN1_R_SHORT_LINE: u32 = 171;
pub const ASN1_R_STREAMING_NOT_SUPPORTED: u32 = 172;
pub const ASN1_R_STRING_TOO_LONG: u32 = 173;
pub const ASN1_R_STRING_TOO_SHORT: u32 = 174;
pub const ASN1_R_TAG_VALUE_TOO_HIGH: u32 = 175;
pub const ASN1_R_TIME_NOT_ASCII_FORMAT: u32 = 176;
pub const ASN1_R_TOO_LONG: u32 = 177;
pub const ASN1_R_TYPE_NOT_CONSTRUCTED: u32 = 178;
pub const ASN1_R_TYPE_NOT_PRIMITIVE: u32 = 179;
pub const ASN1_R_UNEXPECTED_EOC: u32 = 180;
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH: u32 = 181;
pub const ASN1_R_UNKNOWN_FORMAT: u32 = 182;
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM: u32 = 183;
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM: u32 = 184;
pub const ASN1_R_UNKNOWN_TAG: u32 = 185;
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE: u32 = 186;
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 187;
pub const ASN1_R_UNSUPPORTED_TYPE: u32 = 188;
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE: u32 = 189;
pub const ASN1_R_WRONG_TAG: u32 = 190;
pub const ASN1_R_WRONG_TYPE: u32 = 191;
pub const ASN1_R_NESTED_TOO_DEEP: u32 = 192;
pub const ASN1_R_BAD_TEMPLATE: u32 = 193;
pub const ASN1_R_INVALID_BIT_STRING_PADDING: u32 = 194;
pub const ASN1_R_WRONG_INTEGER_TYPE: u32 = 195;
pub const ASN1_R_INVALID_INTEGER: u32 = 196;
pub const ASN1_TFLG_OPTIONAL: u32 = 1;
pub const ASN1_TFLG_SET_OF: u32 = 2;
pub const ASN1_TFLG_SEQUENCE_OF: u32 = 4;
pub const ASN1_TFLG_SK_MASK: u32 = 6;
pub const ASN1_TFLG_IMPTAG: u32 = 8;
pub const ASN1_TFLG_EXPTAG: u32 = 16;
pub const ASN1_TFLG_TAG_MASK: u32 = 24;
pub const ASN1_TFLG_UNIVERSAL: u32 = 0;
pub const ASN1_TFLG_APPLICATION: u32 = 64;
pub const ASN1_TFLG_CONTEXT: u32 = 128;
pub const ASN1_TFLG_PRIVATE: u32 = 192;
pub const ASN1_TFLG_TAG_CLASS: u32 = 192;
pub const ASN1_TFLG_ADB_MASK: u32 = 768;
pub const ASN1_TFLG_ADB_OID: u32 = 256;
pub const ASN1_TFLG_COMBINE: u32 = 1024;
pub const ASN1_ITYPE_PRIMITIVE: u32 = 0;
pub const ASN1_ITYPE_SEQUENCE: u32 = 1;
pub const ASN1_ITYPE_CHOICE: u32 = 2;
pub const ASN1_ITYPE_EXTERN: u32 = 4;
pub const ASN1_ITYPE_MSTRING: u32 = 5;
pub const ASN1_AFLG_REFCOUNT: u32 = 1;
pub const ASN1_AFLG_ENCODING: u32 = 2;
pub const ASN1_OP_NEW_PRE: u32 = 0;
pub const ASN1_OP_NEW_POST: u32 = 1;
pub const ASN1_OP_FREE_PRE: u32 = 2;
pub const ASN1_OP_FREE_POST: u32 = 3;
pub const ASN1_OP_D2I_PRE: u32 = 4;
pub const ASN1_OP_D2I_POST: u32 = 5;
pub const ASN1_OP_PRINT_PRE: u32 = 8;
pub const ASN1_OP_PRINT_POST: u32 = 9;
pub const ASN1_OP_STREAM_PRE: u32 = 10;
pub const ASN1_OP_STREAM_POST: u32 = 11;
pub const ASN1_OP_DETACHED_PRE: u32 = 12;
pub const ASN1_OP_DETACHED_POST: u32 = 13;
pub const BLAKE2B256_DIGEST_LENGTH: u32 = 32;
pub const BLAKE2B_CBLOCK: u32 = 128;
pub const BF_ENCRYPT: u32 = 1;
pub const BF_DECRYPT: u32 = 0;
pub const BF_ROUNDS: u32 = 16;
pub const BF_BLOCK: u32 = 8;
pub const CBS_ASN1_TAG_SHIFT: u32 = 24;
pub const CBS_ASN1_CONSTRUCTED: u32 = 536870912;
pub const CBS_ASN1_UNIVERSAL: u32 = 0;
pub const CBS_ASN1_APPLICATION: u32 = 1073741824;
pub const CBS_ASN1_CONTEXT_SPECIFIC: u32 = 2147483648;
pub const CBS_ASN1_PRIVATE: u32 = 3221225472;
pub const CBS_ASN1_CLASS_MASK: u32 = 3221225472;
pub const CBS_ASN1_TAG_NUMBER_MASK: u32 = 536870911;
pub const CBS_ASN1_BOOLEAN: u32 = 1;
pub const CBS_ASN1_INTEGER: u32 = 2;
pub const CBS_ASN1_BITSTRING: u32 = 3;
pub const CBS_ASN1_OCTETSTRING: u32 = 4;
pub const CBS_ASN1_NULL: u32 = 5;
pub const CBS_ASN1_OBJECT: u32 = 6;
pub const CBS_ASN1_ENUMERATED: u32 = 10;
pub const CBS_ASN1_UTF8STRING: u32 = 12;
pub const CBS_ASN1_SEQUENCE: u32 = 536870928;
pub const CBS_ASN1_SET: u32 = 536870929;
pub const CBS_ASN1_NUMERICSTRING: u32 = 18;
pub const CBS_ASN1_PRINTABLESTRING: u32 = 19;
pub const CBS_ASN1_T61STRING: u32 = 20;
pub const CBS_ASN1_VIDEOTEXSTRING: u32 = 21;
pub const CBS_ASN1_IA5STRING: u32 = 22;
pub const CBS_ASN1_UTCTIME: u32 = 23;
pub const CBS_ASN1_GENERALIZEDTIME: u32 = 24;
pub const CBS_ASN1_GRAPHICSTRING: u32 = 25;
pub const CBS_ASN1_VISIBLESTRING: u32 = 26;
pub const CBS_ASN1_GENERALSTRING: u32 = 27;
pub const CBS_ASN1_UNIVERSALSTRING: u32 = 28;
pub const CBS_ASN1_BMPSTRING: u32 = 30;
pub const EVP_CIPH_STREAM_CIPHER: u32 = 0;
pub const EVP_CIPH_ECB_MODE: u32 = 1;
pub const EVP_CIPH_CBC_MODE: u32 = 2;
pub const EVP_CIPH_CFB_MODE: u32 = 3;
pub const EVP_CIPH_OFB_MODE: u32 = 4;
pub const EVP_CIPH_CTR_MODE: u32 = 5;
pub const EVP_CIPH_GCM_MODE: u32 = 6;
pub const EVP_CIPH_XTS_MODE: u32 = 7;
pub const EVP_CIPH_CCM_MODE: u32 = 8;
pub const EVP_CIPH_FLAG_LENGTH_BITS: u32 = 8192;
pub const EVP_CIPH_OCB_MODE: u32 = 9;
pub const EVP_CIPH_WRAP_MODE: u32 = 10;
pub const EVP_CIPH_VARIABLE_LENGTH: u32 = 64;
pub const EVP_CIPH_ALWAYS_CALL_INIT: u32 = 128;
pub const EVP_CIPH_CUSTOM_IV: u32 = 256;
pub const EVP_CIPH_CTRL_INIT: u32 = 512;
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER: u32 = 1024;
pub const EVP_CIPH_FLAG_AEAD_CIPHER: u32 = 2048;
pub const EVP_CIPH_CUSTOM_COPY: u32 = 4096;
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW: u32 = 0;
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW: u32 = 0;
pub const EVP_CIPH_NO_PADDING: u32 = 2048;
pub const EVP_CTRL_INIT: u32 = 0;
pub const EVP_CTRL_SET_KEY_LENGTH: u32 = 1;
pub const EVP_CTRL_GET_RC2_KEY_BITS: u32 = 2;
pub const EVP_CTRL_SET_RC2_KEY_BITS: u32 = 3;
pub const EVP_CTRL_GET_RC5_ROUNDS: u32 = 4;
pub const EVP_CTRL_SET_RC5_ROUNDS: u32 = 5;
pub const EVP_CTRL_RAND_KEY: u32 = 6;
pub const EVP_CTRL_PBE_PRF_NID: u32 = 7;
pub const EVP_CTRL_COPY: u32 = 8;
pub const EVP_CTRL_AEAD_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_AEAD_GET_TAG: u32 = 16;
pub const EVP_CTRL_AEAD_SET_TAG: u32 = 17;
pub const EVP_CTRL_AEAD_SET_IV_FIXED: u32 = 18;
pub const EVP_CTRL_GCM_IV_GEN: u32 = 19;
pub const EVP_CTRL_CCM_SET_L: u32 = 20;
pub const EVP_CTRL_AEAD_SET_MAC_KEY: u32 = 23;
pub const EVP_CTRL_GCM_SET_IV_INV: u32 = 24;
pub const EVP_CTRL_GET_IVLEN: u32 = 25;
pub const EVP_GCM_TLS_FIXED_IV_LEN: u32 = 4;
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN: u32 = 8;
pub const EVP_GCM_TLS_TAG_LEN: u32 = 16;
pub const EVP_CTRL_GCM_SET_IVLEN: u32 = 9;
pub const EVP_CTRL_GCM_GET_TAG: u32 = 16;
pub const EVP_CTRL_GCM_SET_TAG: u32 = 17;
pub const EVP_CTRL_GCM_SET_IV_FIXED: u32 = 18;
pub const EVP_MAX_KEY_LENGTH: u32 = 64;
pub const EVP_MAX_IV_LENGTH: u32 = 16;
pub const EVP_MAX_BLOCK_LENGTH: u32 = 32;
pub const EVP_CTRL_AEAD_TLS1_AAD: u32 = 22;
pub const EVP_AEAD_TLS1_AAD_LEN: u32 = 13;
pub const CIPHER_R_AES_KEY_SETUP_FAILED: u32 = 100;
pub const CIPHER_R_BAD_DECRYPT: u32 = 101;
pub const CIPHER_R_BAD_KEY_LENGTH: u32 = 102;
pub const CIPHER_R_BUFFER_TOO_SMALL: u32 = 103;
pub const CIPHER_R_CTRL_NOT_IMPLEMENTED: u32 = 104;
pub const CIPHER_R_CTRL_OPERATION_NOT_IMPLEMENTED: u32 = 105;
pub const CIPHER_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH: u32 = 106;
pub const CIPHER_R_INITIALIZATION_ERROR: u32 = 107;
pub const CIPHER_R_INPUT_NOT_INITIALIZED: u32 = 108;
pub const CIPHER_R_INVALID_AD_SIZE: u32 = 109;
pub const CIPHER_R_INVALID_KEY_LENGTH: u32 = 110;
pub const CIPHER_R_INVALID_NONCE_SIZE: u32 = 111;
pub const CIPHER_R_INVALID_OPERATION: u32 = 112;
pub const CIPHER_R_IV_TOO_LARGE: u32 = 113;
pub const CIPHER_R_NO_CIPHER_SET: u32 = 114;
pub const CIPHER_R_OUTPUT_ALIASES_INPUT: u32 = 115;
pub const CIPHER_R_TAG_TOO_LARGE: u32 = 116;
pub const CIPHER_R_TOO_LARGE: u32 = 117;
pub const CIPHER_R_UNSUPPORTED_AD_SIZE: u32 = 118;
pub const CIPHER_R_UNSUPPORTED_INPUT_SIZE: u32 = 119;
pub const CIPHER_R_UNSUPPORTED_KEY_SIZE: u32 = 120;
pub const CIPHER_R_UNSUPPORTED_NONCE_SIZE: u32 = 121;
pub const CIPHER_R_UNSUPPORTED_TAG_SIZE: u32 = 122;
pub const CIPHER_R_WRONG_FINAL_BLOCK_LENGTH: u32 = 123;
pub const CIPHER_R_NO_DIRECTION_SET: u32 = 124;
pub const CIPHER_R_INVALID_NONCE: u32 = 125;
pub const CIPHER_R_XTS_DUPLICATED_KEYS: u32 = 138;
pub const CIPHER_R_XTS_DATA_UNIT_IS_TOO_LARGE: u32 = 139;
pub const CIPHER_R_CTRL_OPERATION_NOT_PERFORMED: u32 = 140;
pub const CIPHER_R_SERIALIZATION_INVALID_EVP_AEAD_CTX: u32 = 141;
pub const CIPHER_R_ALIGNMENT_CHANGED: u32 = 142;
pub const CIPHER_R_SERIALIZATION_INVALID_SERDE_VERSION: u32 = 143;
pub const CIPHER_R_SERIALIZATION_INVALID_CIPHER_ID: u32 = 144;
pub const CONF_MFLAGS_DEFAULT_SECTION: u32 = 0;
pub const CONF_MFLAGS_IGNORE_MISSING_FILE: u32 = 0;
pub const CONF_R_LIST_CANNOT_BE_NULL: u32 = 100;
pub const CONF_R_MISSING_CLOSE_SQUARE_BRACKET: u32 = 101;
pub const CONF_R_MISSING_EQUAL_SIGN: u32 = 102;
pub const CONF_R_NO_CLOSE_BRACE: u32 = 103;
pub const CONF_R_UNABLE_TO_CREATE_NEW_SECTION: u32 = 104;
pub const CONF_R_VARIABLE_HAS_NO_VALUE: u32 = 105;
pub const CONF_R_VARIABLE_EXPANSION_TOO_LONG: u32 = 106;
pub const CONF_R_VARIABLE_EXPANSION_NOT_SUPPORTED: u32 = 107;
pub const CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const CTR_DRBG_MAX_GENERATE_LENGTH: u32 = 65536;
pub const X25519_PRIVATE_KEY_LEN: u32 = 32;
pub const X25519_PUBLIC_VALUE_LEN: u32 = 32;
pub const X25519_SHARED_KEY_LEN: u32 = 32;
pub const ED25519_PRIVATE_KEY_LEN: u32 = 64;
pub const ED25519_PRIVATE_KEY_SEED_LEN: u32 = 32;
pub const ED25519_PUBLIC_KEY_LEN: u32 = 32;
pub const ED25519_SIGNATURE_LEN: u32 = 64;
pub const ED25519_SEED_LEN: u32 = 32;
pub const SPAKE2_MAX_MSG_SIZE: u32 = 32;
pub const SPAKE2_MAX_KEY_SIZE: u32 = 64;
pub const DES_ENCRYPT: u32 = 1;
pub const DES_DECRYPT: u32 = 0;
pub const DES_CBC_MODE: u32 = 0;
pub const DES_PCBC_MODE: u32 = 1;
pub const DH_GENERATOR_2: u32 = 2;
pub const DH_GENERATOR_5: u32 = 5;
pub const DH_CHECK_P_NOT_PRIME: u32 = 1;
pub const DH_CHECK_P_NOT_SAFE_PRIME: u32 = 2;
pub const DH_CHECK_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_CHECK_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_CHECK_Q_NOT_PRIME: u32 = 16;
pub const DH_CHECK_INVALID_Q_VALUE: u32 = 32;
pub const DH_NOT_SUITABLE_GENERATOR: u32 = 8;
pub const DH_UNABLE_TO_CHECK_GENERATOR: u32 = 4;
pub const DH_CHECK_PUBKEY_TOO_SMALL: u32 = 1;
pub const DH_CHECK_PUBKEY_TOO_LARGE: u32 = 2;
pub const DH_CHECK_PUBKEY_INVALID: u32 = 4;
pub const DH_FLAG_CACHE_MONT_P: u32 = 0;
pub const DH_R_BAD_GENERATOR: u32 = 100;
pub const DH_R_INVALID_PUBKEY: u32 = 101;
pub const DH_R_MODULUS_TOO_LARGE: u32 = 102;
pub const DH_R_NO_PRIVATE_VALUE: u32 = 103;
pub const DH_R_DECODE_ERROR: u32 = 104;
pub const DH_R_ENCODE_ERROR: u32 = 105;
pub const DH_R_INVALID_NID: u32 = 106;
pub const DH_R_INVALID_PARAMETERS: u32 = 107;
pub const DH_F_DH_BUILTIN_GENPARAMS: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const EVP_MAX_MD_SIZE: u32 = 64;
pub const EVP_MAX_MD_CHAINING_LENGTH: u32 = 64;
pub const EVP_MAX_MD_BLOCK_SIZE: u32 = 128;
pub const EVP_MD_FLAG_DIGALGID_ABSENT: u32 = 2;
pub const EVP_MD_FLAG_XOF: u32 = 4;
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW: u32 = 0;
pub const DIGEST_R_INPUT_NOT_INITIALIZED: u32 = 100;
pub const DIGEST_R_DECODE_ERROR: u32 = 101;
pub const DIGEST_R_UNKNOWN_HASH: u32 = 102;
pub const DSA_R_BAD_Q_VALUE: u32 = 100;
pub const DSA_R_MISSING_PARAMETERS: u32 = 101;
pub const DSA_R_MODULUS_TOO_LARGE: u32 = 102;
pub const DSA_R_NEED_NEW_SETUP_VALUES: u32 = 103;
pub const DSA_R_BAD_VERSION: u32 = 104;
pub const DSA_R_DECODE_ERROR: u32 = 105;
pub const DSA_R_ENCODE_ERROR: u32 = 106;
pub const DSA_R_INVALID_PARAMETERS: u32 = 107;
pub const DSA_R_TOO_MANY_ITERATIONS: u32 = 108;
pub const OPENSSL_EC_EXPLICIT_CURVE: u32 = 0;
pub const OPENSSL_EC_NAMED_CURVE: u32 = 1;
pub const EC_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EC_R_COORDINATES_OUT_OF_RANGE: u32 = 101;
pub const EC_R_D2I_ECPKPARAMETERS_FAILURE: u32 = 102;
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE: u32 = 103;
pub const EC_R_GROUP2PKPARAMETERS_FAILURE: u32 = 104;
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE: u32 = 105;
pub const EC_R_INCOMPATIBLE_OBJECTS: u32 = 106;
pub const EC_R_INVALID_COMPRESSED_POINT: u32 = 107;
pub const EC_R_INVALID_COMPRESSION_BIT: u32 = 108;
pub const EC_R_INVALID_ENCODING: u32 = 109;
pub const EC_R_INVALID_FIELD: u32 = 110;
pub const EC_R_INVALID_FORM: u32 = 111;
pub const EC_R_INVALID_GROUP_ORDER: u32 = 112;
pub const EC_R_INVALID_PRIVATE_KEY: u32 = 113;
pub const EC_R_MISSING_PARAMETERS: u32 = 114;
pub const EC_R_MISSING_PRIVATE_KEY: u32 = 115;
pub const EC_R_NON_NAMED_CURVE: u32 = 116;
pub const EC_R_NOT_INITIALIZED: u32 = 117;
pub const EC_R_PKPARAMETERS2GROUP_FAILURE: u32 = 118;
pub const EC_R_POINT_AT_INFINITY: u32 = 119;
pub const EC_R_POINT_IS_NOT_ON_CURVE: u32 = 120;
pub const EC_R_SLOT_FULL: u32 = 121;
pub const EC_R_UNDEFINED_GENERATOR: u32 = 122;
pub const EC_R_UNKNOWN_GROUP: u32 = 123;
pub const EC_R_UNKNOWN_ORDER: u32 = 124;
pub const EC_R_WRONG_ORDER: u32 = 125;
pub const EC_R_BIGNUM_OUT_OF_RANGE: u32 = 126;
pub const EC_R_WRONG_CURVE_PARAMETERS: u32 = 127;
pub const EC_R_DECODE_ERROR: u32 = 128;
pub const EC_R_ENCODE_ERROR: u32 = 129;
pub const EC_R_GROUP_MISMATCH: u32 = 130;
pub const EC_R_INVALID_COFACTOR: u32 = 131;
pub const EC_R_PUBLIC_KEY_VALIDATION_FAILED: u32 = 132;
pub const EC_R_INVALID_SCALAR: u32 = 133;
pub const ENGINE_R_OPERATION_NOT_SUPPORTED: u32 = 100;
pub const EC_PKEY_NO_PARAMETERS: u32 = 1;
pub const EC_PKEY_NO_PUBKEY: u32 = 2;
pub const ECDSA_FLAG_OPAQUE: u32 = 1;
pub const ECDH_R_KDF_FAILED: u32 = 100;
pub const ECDH_R_NO_PRIVATE_VALUE: u32 = 101;
pub const ECDH_R_POINT_ARITHMETIC_FAILURE: u32 = 102;
pub const ECDH_R_UNKNOWN_DIGEST_LENGTH: u32 = 103;
pub const ECDSA_R_BAD_SIGNATURE: u32 = 100;
pub const ECDSA_R_MISSING_PARAMETERS: u32 = 101;
pub const ECDSA_R_NEED_NEW_SETUP_VALUES: u32 = 102;
pub const ECDSA_R_NOT_IMPLEMENTED: u32 = 103;
pub const ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED: u32 = 104;
pub const ECDSA_R_ENCODE_ERROR: u32 = 105;
pub const ECDSA_R_MISMATCHED_SIGNATURE: u32 = 205;
pub const ECDSA_R_TOO_MANY_ITERATIONS: u32 = 106;
pub const EVP_R_BUFFER_TOO_SMALL: u32 = 100;
pub const EVP_R_COMMAND_NOT_SUPPORTED: u32 = 101;
pub const EVP_R_DECODE_ERROR: u32 = 102;
pub const EVP_R_DIFFERENT_KEY_TYPES: u32 = 103;
pub const EVP_R_DIFFERENT_PARAMETERS: u32 = 104;
pub const EVP_R_ENCODE_ERROR: u32 = 105;
pub const EVP_R_EXPECTING_AN_EC_KEY_KEY: u32 = 106;
pub const EVP_R_EXPECTING_AN_RSA_KEY: u32 = 107;
pub const EVP_R_EXPECTING_A_DSA_KEY: u32 = 108;
pub const EVP_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE: u32 = 109;
pub const EVP_R_INVALID_DIGEST_LENGTH: u32 = 110;
pub const EVP_R_INVALID_DIGEST_TYPE: u32 = 111;
pub const EVP_R_INVALID_KEYBITS: u32 = 112;
pub const EVP_R_INVALID_MGF1_MD: u32 = 113;
pub const EVP_R_INVALID_OPERATION: u32 = 114;
pub const EVP_R_INVALID_PADDING_MODE: u32 = 115;
pub const EVP_R_INVALID_PSS_SALTLEN: u32 = 116;
pub const EVP_R_KEYS_NOT_SET: u32 = 117;
pub const EVP_R_MISSING_PARAMETERS: u32 = 118;
pub const EVP_R_NO_DEFAULT_DIGEST: u32 = 119;
pub const EVP_R_NO_KEY_SET: u32 = 120;
pub const EVP_R_NO_MDC2_SUPPORT: u32 = 121;
pub const EVP_R_NO_NID_FOR_CURVE: u32 = 122;
pub const EVP_R_NO_OPERATION_SET: u32 = 123;
pub const EVP_R_NO_PARAMETERS_SET: u32 = 124;
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE: u32 = 125;
pub const EVP_R_OPERATON_NOT_INITIALIZED: u32 = 126;
pub const EVP_R_UNKNOWN_PUBLIC_KEY_TYPE: u32 = 127;
pub const EVP_R_UNSUPPORTED_ALGORITHM: u32 = 128;
pub const EVP_R_UNSUPPORTED_PUBLIC_KEY_TYPE: u32 = 129;
pub const EVP_R_NOT_A_PRIVATE_KEY: u32 = 130;
pub const EVP_R_INVALID_SIGNATURE: u32 = 131;
pub const EVP_R_MEMORY_LIMIT_EXCEEDED: u32 = 132;
pub const EVP_R_INVALID_PARAMETERS: u32 = 133;
pub const EVP_R_INVALID_PEER_KEY: u32 = 134;
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH: u32 = 135;
pub const EVP_R_EMPTY_PSK: u32 = 136;
pub const EVP_R_INVALID_BUFFER_SIZE: u32 = 137;
pub const EVP_R_BAD_DECRYPT: u32 = 138;
pub const EVP_R_INVALID_PSS_MD: u32 = 500;
pub const EVP_R_INVALID_PSS_SALT_LEN: u32 = 501;
pub const EVP_R_INVALID_PSS_TRAILER_FIELD: u32 = 502;
pub const SN_undef: &[u8; 6] = b"UNDEF\0";
pub const LN_undef: &[u8; 10] = b"undefined\0";
pub const NID_undef: u32 = 0;
pub const OBJ_undef: u32 = 0;
pub const SN_rsadsi: &[u8; 7] = b"rsadsi\0";
pub const LN_rsadsi: &[u8; 24] = b"RSA Data Security, Inc.\0";
pub const NID_rsadsi: u32 = 1;
pub const SN_pkcs: &[u8; 5] = b"pkcs\0";
pub const LN_pkcs: &[u8; 29] = b"RSA Data Security, Inc. PKCS\0";
pub const NID_pkcs: u32 = 2;
pub const SN_md2: &[u8; 4] = b"MD2\0";
pub const LN_md2: &[u8; 4] = b"md2\0";
pub const NID_md2: u32 = 3;
pub const SN_md5: &[u8; 4] = b"MD5\0";
pub const LN_md5: &[u8; 4] = b"md5\0";
pub const NID_md5: u32 = 4;
pub const SN_rc4: &[u8; 4] = b"RC4\0";
pub const LN_rc4: &[u8; 4] = b"rc4\0";
pub const NID_rc4: u32 = 5;
pub const LN_rsaEncryption: &[u8; 14] = b"rsaEncryption\0";
pub const NID_rsaEncryption: u32 = 6;
pub const SN_md2WithRSAEncryption: &[u8; 8] = b"RSA-MD2\0";
pub const LN_md2WithRSAEncryption: &[u8; 21] = b"md2WithRSAEncryption\0";
pub const NID_md2WithRSAEncryption: u32 = 7;
pub const SN_md5WithRSAEncryption: &[u8; 8] = b"RSA-MD5\0";
pub const LN_md5WithRSAEncryption: &[u8; 21] = b"md5WithRSAEncryption\0";
pub const NID_md5WithRSAEncryption: u32 = 8;
pub const SN_pbeWithMD2AndDES_CBC: &[u8; 12] = b"PBE-MD2-DES\0";
pub const LN_pbeWithMD2AndDES_CBC: &[u8; 21] = b"pbeWithMD2AndDES-CBC\0";
pub const NID_pbeWithMD2AndDES_CBC: u32 = 9;
pub const SN_pbeWithMD5AndDES_CBC: &[u8; 12] = b"PBE-MD5-DES\0";
pub const LN_pbeWithMD5AndDES_CBC: &[u8; 21] = b"pbeWithMD5AndDES-CBC\0";
pub const NID_pbeWithMD5AndDES_CBC: u32 = 10;
pub const SN_X500: &[u8; 5] = b"X500\0";
pub const LN_X500: &[u8; 27] = b"directory services (X.500)\0";
pub const NID_X500: u32 = 11;
pub const SN_X509: &[u8; 5] = b"X509\0";
pub const NID_X509: u32 = 12;
pub const SN_commonName: &[u8; 3] = b"CN\0";
pub const LN_commonName: &[u8; 11] = b"commonName\0";
pub const NID_commonName: u32 = 13;
pub const SN_countryName: &[u8; 2] = b"C\0";
pub const LN_countryName: &[u8; 12] = b"countryName\0";
pub const NID_countryName: u32 = 14;
pub const SN_localityName: &[u8; 2] = b"L\0";
pub const LN_localityName: &[u8; 13] = b"localityName\0";
pub const NID_localityName: u32 = 15;
pub const SN_stateOrProvinceName: &[u8; 3] = b"ST\0";
pub const LN_stateOrProvinceName: &[u8; 20] = b"stateOrProvinceName\0";
pub const NID_stateOrProvinceName: u32 = 16;
pub const SN_organizationName: &[u8; 2] = b"O\0";
pub const LN_organizationName: &[u8; 17] = b"organizationName\0";
pub const NID_organizationName: u32 = 17;
pub const SN_organizationalUnitName: &[u8; 3] = b"OU\0";
pub const LN_organizationalUnitName: &[u8; 23] = b"organizationalUnitName\0";
pub const NID_organizationalUnitName: u32 = 18;
pub const SN_rsa: &[u8; 4] = b"RSA\0";
pub const LN_rsa: &[u8; 4] = b"rsa\0";
pub const NID_rsa: u32 = 19;
pub const SN_pkcs7: &[u8; 6] = b"pkcs7\0";
pub const NID_pkcs7: u32 = 20;
pub const LN_pkcs7_data: &[u8; 11] = b"pkcs7-data\0";
pub const NID_pkcs7_data: u32 = 21;
pub const LN_pkcs7_signed: &[u8; 17] = b"pkcs7-signedData\0";
pub const NID_pkcs7_signed: u32 = 22;
pub const LN_pkcs7_enveloped: &[u8; 20] = b"pkcs7-envelopedData\0";
pub const NID_pkcs7_enveloped: u32 = 23;
pub const LN_pkcs7_signedAndEnveloped: &[u8; 29] = b"pkcs7-signedAndEnvelopedData\0";
pub const NID_pkcs7_signedAndEnveloped: u32 = 24;
pub const LN_pkcs7_digest: &[u8; 17] = b"pkcs7-digestData\0";
pub const NID_pkcs7_digest: u32 = 25;
pub const LN_pkcs7_encrypted: &[u8; 20] = b"pkcs7-encryptedData\0";
pub const NID_pkcs7_encrypted: u32 = 26;
pub const SN_pkcs3: &[u8; 6] = b"pkcs3\0";
pub const NID_pkcs3: u32 = 27;
pub const LN_dhKeyAgreement: &[u8; 15] = b"dhKeyAgreement\0";
pub const NID_dhKeyAgreement: u32 = 28;
pub const SN_des_ecb: &[u8; 8] = b"DES-ECB\0";
pub const LN_des_ecb: &[u8; 8] = b"des-ecb\0";
pub const NID_des_ecb: u32 = 29;
pub const SN_des_cfb64: &[u8; 8] = b"DES-CFB\0";
pub const LN_des_cfb64: &[u8; 8] = b"des-cfb\0";
pub const NID_des_cfb64: u32 = 30;
pub const SN_des_cbc: &[u8; 8] = b"DES-CBC\0";
pub const LN_des_cbc: &[u8; 8] = b"des-cbc\0";
pub const NID_des_cbc: u32 = 31;
pub const SN_des_ede_ecb: &[u8; 8] = b"DES-EDE\0";
pub const LN_des_ede_ecb: &[u8; 8] = b"des-ede\0";
pub const NID_des_ede_ecb: u32 = 32;
pub const SN_des_ede3_ecb: &[u8; 9] = b"DES-EDE3\0";
pub const LN_des_ede3_ecb: &[u8; 9] = b"des-ede3\0";
pub const NID_des_ede3_ecb: u32 = 33;
pub const SN_idea_cbc: &[u8; 9] = b"IDEA-CBC\0";
pub const LN_idea_cbc: &[u8; 9] = b"idea-cbc\0";
pub const NID_idea_cbc: u32 = 34;
pub const SN_idea_cfb64: &[u8; 9] = b"IDEA-CFB\0";
pub const LN_idea_cfb64: &[u8; 9] = b"idea-cfb\0";
pub const NID_idea_cfb64: u32 = 35;
pub const SN_idea_ecb: &[u8; 9] = b"IDEA-ECB\0";
pub const LN_idea_ecb: &[u8; 9] = b"idea-ecb\0";
pub const NID_idea_ecb: u32 = 36;
pub const SN_rc2_cbc: &[u8; 8] = b"RC2-CBC\0";
pub const LN_rc2_cbc: &[u8; 8] = b"rc2-cbc\0";
pub const NID_rc2_cbc: u32 = 37;
pub const SN_rc2_ecb: &[u8; 8] = b"RC2-ECB\0";
pub const LN_rc2_ecb: &[u8; 8] = b"rc2-ecb\0";
pub const NID_rc2_ecb: u32 = 38;
pub const SN_rc2_cfb64: &[u8; 8] = b"RC2-CFB\0";
pub const LN_rc2_cfb64: &[u8; 8] = b"rc2-cfb\0";
pub const NID_rc2_cfb64: u32 = 39;
pub const SN_rc2_ofb64: &[u8; 8] = b"RC2-OFB\0";
pub const LN_rc2_ofb64: &[u8; 8] = b"rc2-ofb\0";
pub const NID_rc2_ofb64: u32 = 40;
pub const SN_sha: &[u8; 4] = b"SHA\0";
pub const LN_sha: &[u8; 4] = b"sha\0";
pub const NID_sha: u32 = 41;
pub const SN_shaWithRSAEncryption: &[u8; 8] = b"RSA-SHA\0";
pub const LN_shaWithRSAEncryption: &[u8; 21] = b"shaWithRSAEncryption\0";
pub const NID_shaWithRSAEncryption: u32 = 42;
pub const SN_des_ede_cbc: &[u8; 12] = b"DES-EDE-CBC\0";
pub const LN_des_ede_cbc: &[u8; 12] = b"des-ede-cbc\0";
pub const NID_des_ede_cbc: u32 = 43;
pub const SN_des_ede3_cbc: &[u8; 13] = b"DES-EDE3-CBC\0";
pub const LN_des_ede3_cbc: &[u8; 13] = b"des-ede3-cbc\0";
pub const NID_des_ede3_cbc: u32 = 44;
pub const SN_des_ofb64: &[u8; 8] = b"DES-OFB\0";
pub const LN_des_ofb64: &[u8; 8] = b"des-ofb\0";
pub const NID_des_ofb64: u32 = 45;
pub const SN_idea_ofb64: &[u8; 9] = b"IDEA-OFB\0";
pub const LN_idea_ofb64: &[u8; 9] = b"idea-ofb\0";
pub const NID_idea_ofb64: u32 = 46;
pub const SN_pkcs9: &[u8; 6] = b"pkcs9\0";
pub const NID_pkcs9: u32 = 47;
pub const LN_pkcs9_emailAddress: &[u8; 13] = b"emailAddress\0";
pub const NID_pkcs9_emailAddress: u32 = 48;
pub const LN_pkcs9_unstructuredName: &[u8; 17] = b"unstructuredName\0";
pub const NID_pkcs9_unstructuredName: u32 = 49;
pub const LN_pkcs9_contentType: &[u8; 12] = b"contentType\0";
pub const NID_pkcs9_contentType: u32 = 50;
pub const LN_pkcs9_messageDigest: &[u8; 14] = b"messageDigest\0";
pub const NID_pkcs9_messageDigest: u32 = 51;
pub const LN_pkcs9_signingTime: &[u8; 12] = b"signingTime\0";
pub const NID_pkcs9_signingTime: u32 = 52;
pub const LN_pkcs9_countersignature: &[u8; 17] = b"countersignature\0";
pub const NID_pkcs9_countersignature: u32 = 53;
pub const LN_pkcs9_challengePassword: &[u8; 18] = b"challengePassword\0";
pub const NID_pkcs9_challengePassword: u32 = 54;
pub const LN_pkcs9_unstructuredAddress: &[u8; 20] = b"unstructuredAddress\0";
pub const NID_pkcs9_unstructuredAddress: u32 = 55;
pub const LN_pkcs9_extCertAttributes: &[u8; 30] = b"extendedCertificateAttributes\0";
pub const NID_pkcs9_extCertAttributes: u32 = 56;
pub const SN_netscape: &[u8; 9] = b"Netscape\0";
pub const LN_netscape: &[u8; 30] = b"Netscape Communications Corp.\0";
pub const NID_netscape: u32 = 57;
pub const SN_netscape_cert_extension: &[u8; 10] = b"nsCertExt\0";
pub const LN_netscape_cert_extension: &[u8; 31] = b"Netscape Certificate Extension\0";
pub const NID_netscape_cert_extension: u32 = 58;
pub const SN_netscape_data_type: &[u8; 11] = b"nsDataType\0";
pub const LN_netscape_data_type: &[u8; 19] = b"Netscape Data Type\0";
pub const NID_netscape_data_type: u32 = 59;
pub const SN_des_ede_cfb64: &[u8; 12] = b"DES-EDE-CFB\0";
pub const LN_des_ede_cfb64: &[u8; 12] = b"des-ede-cfb\0";
pub const NID_des_ede_cfb64: u32 = 60;
pub const SN_des_ede3_cfb64: &[u8; 13] = b"DES-EDE3-CFB\0";
pub const LN_des_ede3_cfb64: &[u8; 13] = b"des-ede3-cfb\0";
pub const NID_des_ede3_cfb64: u32 = 61;
pub const SN_des_ede_ofb64: &[u8; 12] = b"DES-EDE-OFB\0";
pub const LN_des_ede_ofb64: &[u8; 12] = b"des-ede-ofb\0";
pub const NID_des_ede_ofb64: u32 = 62;
pub const SN_des_ede3_ofb64: &[u8; 13] = b"DES-EDE3-OFB\0";
pub const LN_des_ede3_ofb64: &[u8; 13] = b"des-ede3-ofb\0";
pub const NID_des_ede3_ofb64: u32 = 63;
pub const SN_sha1: &[u8; 5] = b"SHA1\0";
pub const LN_sha1: &[u8; 5] = b"sha1\0";
pub const NID_sha1: u32 = 64;
pub const SN_sha1WithRSAEncryption: &[u8; 9] = b"RSA-SHA1\0";
pub const LN_sha1WithRSAEncryption: &[u8; 22] = b"sha1WithRSAEncryption\0";
pub const NID_sha1WithRSAEncryption: u32 = 65;
pub const SN_dsaWithSHA: &[u8; 8] = b"DSA-SHA\0";
pub const LN_dsaWithSHA: &[u8; 11] = b"dsaWithSHA\0";
pub const NID_dsaWithSHA: u32 = 66;
pub const SN_dsa_2: &[u8; 8] = b"DSA-old\0";
pub const LN_dsa_2: &[u8; 18] = b"dsaEncryption-old\0";
pub const NID_dsa_2: u32 = 67;
pub const SN_pbeWithSHA1AndRC2_CBC: &[u8; 16] = b"PBE-SHA1-RC2-64\0";
pub const LN_pbeWithSHA1AndRC2_CBC: &[u8; 22] = b"pbeWithSHA1AndRC2-CBC\0";
pub const NID_pbeWithSHA1AndRC2_CBC: u32 = 68;
pub const LN_id_pbkdf2: &[u8; 7] = b"PBKDF2\0";
pub const NID_id_pbkdf2: u32 = 69;
pub const SN_dsaWithSHA1_2: &[u8; 13] = b"DSA-SHA1-old\0";
pub const LN_dsaWithSHA1_2: &[u8; 16] = b"dsaWithSHA1-old\0";
pub const NID_dsaWithSHA1_2: u32 = 70;
pub const SN_netscape_cert_type: &[u8; 11] = b"nsCertType\0";
pub const LN_netscape_cert_type: &[u8; 19] = b"Netscape Cert Type\0";
pub const NID_netscape_cert_type: u32 = 71;
pub const SN_netscape_base_url: &[u8; 10] = b"nsBaseUrl\0";
pub const LN_netscape_base_url: &[u8; 18] = b"Netscape Base Url\0";
pub const NID_netscape_base_url: u32 = 72;
pub const SN_netscape_revocation_url: &[u8; 16] = b"nsRevocationUrl\0";
pub const LN_netscape_revocation_url: &[u8; 24] = b"Netscape Revocation Url\0";
pub const NID_netscape_revocation_url: u32 = 73;
pub const SN_netscape_ca_revocation_url: &[u8; 18] = b"nsCaRevocationUrl\0";
pub const LN_netscape_ca_revocation_url: &[u8; 27] = b"Netscape CA Revocation Url\0";
pub const NID_netscape_ca_revocation_url: u32 = 74;
pub const SN_netscape_renewal_url: &[u8; 13] = b"nsRenewalUrl\0";
pub const LN_netscape_renewal_url: &[u8; 21] = b"Netscape Renewal Url\0";
pub const NID_netscape_renewal_url: u32 = 75;
pub const SN_netscape_ca_policy_url: &[u8; 14] = b"nsCaPolicyUrl\0";
pub const LN_netscape_ca_policy_url: &[u8; 23] = b"Netscape CA Policy Url\0";
pub const NID_netscape_ca_policy_url: u32 = 76;
pub const SN_netscape_ssl_server_name: &[u8; 16] = b"nsSslServerName\0";
pub const LN_netscape_ssl_server_name: &[u8; 25] = b"Netscape SSL Server Name\0";
pub const NID_netscape_ssl_server_name: u32 = 77;
pub const SN_netscape_comment: &[u8; 10] = b"nsComment\0";
pub const LN_netscape_comment: &[u8; 17] = b"Netscape Comment\0";
pub const NID_netscape_comment: u32 = 78;
pub const SN_netscape_cert_sequence: &[u8; 15] = b"nsCertSequence\0";
pub const LN_netscape_cert_sequence: &[u8; 30] = b"Netscape Certificate Sequence\0";
pub const NID_netscape_cert_sequence: u32 = 79;
pub const SN_desx_cbc: &[u8; 9] = b"DESX-CBC\0";
pub const LN_desx_cbc: &[u8; 9] = b"desx-cbc\0";
pub const NID_desx_cbc: u32 = 80;
pub const SN_id_ce: &[u8; 6] = b"id-ce\0";
pub const NID_id_ce: u32 = 81;
pub const SN_subject_key_identifier: &[u8; 21] = b"subjectKeyIdentifier\0";
pub const LN_subject_key_identifier: &[u8; 30] = b"X509v3 Subject Key Identifier\0";
pub const NID_subject_key_identifier: u32 = 82;
pub const SN_key_usage: &[u8; 9] = b"keyUsage\0";
pub const LN_key_usage: &[u8; 17] = b"X509v3 Key Usage\0";
pub const NID_key_usage: u32 = 83;
pub const SN_private_key_usage_period: &[u8; 22] = b"privateKeyUsagePeriod\0";
pub const LN_private_key_usage_period: &[u8; 32] = b"X509v3 Private Key Usage Period\0";
pub const NID_private_key_usage_period: u32 = 84;
pub const SN_subject_alt_name: &[u8; 15] = b"subjectAltName\0";
pub const LN_subject_alt_name: &[u8; 32] = b"X509v3 Subject Alternative Name\0";
pub const NID_subject_alt_name: u32 = 85;
pub const SN_issuer_alt_name: &[u8; 14] = b"issuerAltName\0";
pub const LN_issuer_alt_name: &[u8; 31] = b"X509v3 Issuer Alternative Name\0";
pub const NID_issuer_alt_name: u32 = 86;
pub const SN_basic_constraints: &[u8; 17] = b"basicConstraints\0";
pub const LN_basic_constraints: &[u8; 25] = b"X509v3 Basic Constraints\0";
pub const NID_basic_constraints: u32 = 87;
pub const SN_crl_number: &[u8; 10] = b"crlNumber\0";
pub const LN_crl_number: &[u8; 18] = b"X509v3 CRL Number\0";
pub const NID_crl_number: u32 = 88;
pub const SN_certificate_policies: &[u8; 20] = b"certificatePolicies\0";
pub const LN_certificate_policies: &[u8; 28] = b"X509v3 Certificate Policies\0";
pub const NID_certificate_policies: u32 = 89;
pub const SN_authority_key_identifier: &[u8; 23] = b"authorityKeyIdentifier\0";
pub const LN_authority_key_identifier: &[u8; 32] = b"X509v3 Authority Key Identifier\0";
pub const NID_authority_key_identifier: u32 = 90;
pub const SN_bf_cbc: &[u8; 7] = b"BF-CBC\0";
pub const LN_bf_cbc: &[u8; 7] = b"bf-cbc\0";
pub const NID_bf_cbc: u32 = 91;
pub const SN_bf_ecb: &[u8; 7] = b"BF-ECB\0";
pub const LN_bf_ecb: &[u8; 7] = b"bf-ecb\0";
pub const NID_bf_ecb: u32 = 92;
pub const SN_bf_cfb64: &[u8; 7] = b"BF-CFB\0";
pub const LN_bf_cfb64: &[u8; 7] = b"bf-cfb\0";
pub const NID_bf_cfb64: u32 = 93;
pub const SN_bf_ofb64: &[u8; 7] = b"BF-OFB\0";
pub const LN_bf_ofb64: &[u8; 7] = b"bf-ofb\0";
pub const NID_bf_ofb64: u32 = 94;
pub const SN_mdc2: &[u8; 5] = b"MDC2\0";
pub const LN_mdc2: &[u8; 5] = b"mdc2\0";
pub const NID_mdc2: u32 = 95;
pub const SN_mdc2WithRSA: &[u8; 9] = b"RSA-MDC2\0";
pub const LN_mdc2WithRSA: &[u8; 12] = b"mdc2WithRSA\0";
pub const NID_mdc2WithRSA: u32 = 96;
pub const SN_rc4_40: &[u8; 7] = b"RC4-40\0";
pub const LN_rc4_40: &[u8; 7] = b"rc4-40\0";
pub const NID_rc4_40: u32 = 97;
pub const SN_rc2_40_cbc: &[u8; 11] = b"RC2-40-CBC\0";
pub const LN_rc2_40_cbc: &[u8; 11] = b"rc2-40-cbc\0";
pub const NID_rc2_40_cbc: u32 = 98;
pub const SN_givenName: &[u8; 3] = b"GN\0";
pub const LN_givenName: &[u8; 10] = b"givenName\0";
pub const NID_givenName: u32 = 99;
pub const SN_surname: &[u8; 3] = b"SN\0";
pub const LN_surname: &[u8; 8] = b"surname\0";
pub const NID_surname: u32 = 100;
pub const SN_initials: &[u8; 9] = b"initials\0";
pub const LN_initials: &[u8; 9] = b"initials\0";
pub const NID_initials: u32 = 101;
pub const SN_crl_distribution_points: &[u8; 22] = b"crlDistributionPoints\0";
pub const LN_crl_distribution_points: &[u8; 31] = b"X509v3 CRL Distribution Points\0";
pub const NID_crl_distribution_points: u32 = 103;
pub const SN_md5WithRSA: &[u8; 11] = b"RSA-NP-MD5\0";
pub const LN_md5WithRSA: &[u8; 11] = b"md5WithRSA\0";
pub const NID_md5WithRSA: u32 = 104;
pub const LN_serialNumber: &[u8; 13] = b"serialNumber\0";
pub const NID_serialNumber: u32 = 105;
pub const SN_title: &[u8; 6] = b"title\0";
pub const LN_title: &[u8; 6] = b"title\0";
pub const NID_title: u32 = 106;
pub const LN_description: &[u8; 12] = b"description\0";
pub const NID_description: u32 = 107;
pub const SN_cast5_cbc: &[u8; 10] = b"CAST5-CBC\0";
pub const LN_cast5_cbc: &[u8; 10] = b"cast5-cbc\0";
pub const NID_cast5_cbc: u32 = 108;
pub const SN_cast5_ecb: &[u8; 10] = b"CAST5-ECB\0";
pub const LN_cast5_ecb: &[u8; 10] = b"cast5-ecb\0";
pub const NID_cast5_ecb: u32 = 109;
pub const SN_cast5_cfb64: &[u8; 10] = b"CAST5-CFB\0";
pub const LN_cast5_cfb64: &[u8; 10] = b"cast5-cfb\0";
pub const NID_cast5_cfb64: u32 = 110;
pub const SN_cast5_ofb64: &[u8; 10] = b"CAST5-OFB\0";
pub const LN_cast5_ofb64: &[u8; 10] = b"cast5-ofb\0";
pub const NID_cast5_ofb64: u32 = 111;
pub const LN_pbeWithMD5AndCast5_CBC: &[u8; 22] = b"pbeWithMD5AndCast5CBC\0";
pub const NID_pbeWithMD5AndCast5_CBC: u32 = 112;
pub const SN_dsaWithSHA1: &[u8; 9] = b"DSA-SHA1\0";
pub const LN_dsaWithSHA1: &[u8; 12] = b"dsaWithSHA1\0";
pub const NID_dsaWithSHA1: u32 = 113;
pub const SN_md5_sha1: &[u8; 9] = b"MD5-SHA1\0";
pub const LN_md5_sha1: &[u8; 9] = b"md5-sha1\0";
pub const NID_md5_sha1: u32 = 114;
pub const SN_sha1WithRSA: &[u8; 11] = b"RSA-SHA1-2\0";
pub const LN_sha1WithRSA: &[u8; 12] = b"sha1WithRSA\0";
pub const NID_sha1WithRSA: u32 = 115;
pub const SN_dsa: &[u8; 4] = b"DSA\0";
pub const LN_dsa: &[u8; 14] = b"dsaEncryption\0";
pub const NID_dsa: u32 = 116;
pub const SN_ripemd160: &[u8; 10] = b"RIPEMD160\0";
pub const LN_ripemd160: &[u8; 10] = b"ripemd160\0";
pub const NID_ripemd160: u32 = 117;
pub const SN_ripemd160WithRSA: &[u8; 14] = b"RSA-RIPEMD160\0";
pub const LN_ripemd160WithRSA: &[u8; 17] = b"ripemd160WithRSA\0";
pub const NID_ripemd160WithRSA: u32 = 119;
pub const SN_rc5_cbc: &[u8; 8] = b"RC5-CBC\0";
pub const LN_rc5_cbc: &[u8; 8] = b"rc5-cbc\0";
pub const NID_rc5_cbc: u32 = 120;
pub const SN_rc5_ecb: &[u8; 8] = b"RC5-ECB\0";
pub const LN_rc5_ecb: &[u8; 8] = b"rc5-ecb\0";
pub const NID_rc5_ecb: u32 = 121;
pub const SN_rc5_cfb64: &[u8; 8] = b"RC5-CFB\0";
pub const LN_rc5_cfb64: &[u8; 8] = b"rc5-cfb\0";
pub const NID_rc5_cfb64: u32 = 122;
pub const SN_rc5_ofb64: &[u8; 8] = b"RC5-OFB\0";
pub const LN_rc5_ofb64: &[u8; 8] = b"rc5-ofb\0";
pub const NID_rc5_ofb64: u32 = 123;
pub const SN_zlib_compression: &[u8; 5] = b"ZLIB\0";
pub const LN_zlib_compression: &[u8; 17] = b"zlib compression\0";
pub const NID_zlib_compression: u32 = 125;
pub const SN_ext_key_usage: &[u8; 17] = b"extendedKeyUsage\0";
pub const LN_ext_key_usage: &[u8; 26] = b"X509v3 Extended Key Usage\0";
pub const NID_ext_key_usage: u32 = 126;
pub const SN_id_pkix: &[u8; 5] = b"PKIX\0";
pub const NID_id_pkix: u32 = 127;
pub const SN_id_kp: &[u8; 6] = b"id-kp\0";
pub const NID_id_kp: u32 = 128;
pub const SN_server_auth: &[u8; 11] = b"serverAuth\0";
pub const LN_server_auth: &[u8; 30] = b"TLS Web Server Authentication\0";
pub const NID_server_auth: u32 = 129;
pub const SN_client_auth: &[u8; 11] = b"clientAuth\0";
pub const LN_client_auth: &[u8; 30] = b"TLS Web Client Authentication\0";
pub const NID_client_auth: u32 = 130;
pub const SN_code_sign: &[u8; 12] = b"codeSigning\0";
pub const LN_code_sign: &[u8; 13] = b"Code Signing\0";
pub const NID_code_sign: u32 = 131;
pub const SN_email_protect: &[u8; 16] = b"emailProtection\0";
pub const LN_email_protect: &[u8; 18] = b"E-mail Protection\0";
pub const NID_email_protect: u32 = 132;
pub const SN_time_stamp: &[u8; 13] = b"timeStamping\0";
pub const LN_time_stamp: &[u8; 14] = b"Time Stamping\0";
pub const NID_time_stamp: u32 = 133;
pub const SN_ms_code_ind: &[u8; 10] = b"msCodeInd\0";
pub const LN_ms_code_ind: &[u8; 34] = b"Microsoft Individual Code Signing\0";
pub const NID_ms_code_ind: u32 = 134;
pub const SN_ms_code_com: &[u8; 10] = b"msCodeCom\0";
pub const LN_ms_code_com: &[u8; 34] = b"Microsoft Commercial Code Signing\0";
pub const NID_ms_code_com: u32 = 135;
pub const SN_ms_ctl_sign: &[u8; 10] = b"msCTLSign\0";
pub const LN_ms_ctl_sign: &[u8; 29] = b"Microsoft Trust List Signing\0";
pub const NID_ms_ctl_sign: u32 = 136;
pub const SN_ms_sgc: &[u8; 6] = b"msSGC\0";
pub const LN_ms_sgc: &[u8; 30] = b"Microsoft Server Gated Crypto\0";
pub const NID_ms_sgc: u32 = 137;
pub const SN_ms_efs: &[u8; 6] = b"msEFS\0";
pub const LN_ms_efs: &[u8; 32] = b"Microsoft Encrypted File System\0";
pub const NID_ms_efs: u32 = 138;
pub const SN_ns_sgc: &[u8; 6] = b"nsSGC\0";
pub const LN_ns_sgc: &[u8; 29] = b"Netscape Server Gated Crypto\0";
pub const NID_ns_sgc: u32 = 139;
pub const SN_delta_crl: &[u8; 9] = b"deltaCRL\0";
pub const LN_delta_crl: &[u8; 27] = b"X509v3 Delta CRL Indicator\0";
pub const NID_delta_crl: u32 = 140;
pub const SN_crl_reason: &[u8; 10] = b"CRLReason\0";
pub const LN_crl_reason: &[u8; 23] = b"X509v3 CRL Reason Code\0";
pub const NID_crl_reason: u32 = 141;
pub const SN_invalidity_date: &[u8; 15] = b"invalidityDate\0";
pub const LN_invalidity_date: &[u8; 16] = b"Invalidity Date\0";
pub const NID_invalidity_date: u32 = 142;
pub const SN_sxnet: &[u8; 8] = b"SXNetID\0";
pub const LN_sxnet: &[u8; 19] = b"Strong Extranet ID\0";
pub const NID_sxnet: u32 = 143;
pub const SN_pbe_WithSHA1And128BitRC4: &[u8; 17] = b"PBE-SHA1-RC4-128\0";
pub const LN_pbe_WithSHA1And128BitRC4: &[u8; 24] = b"pbeWithSHA1And128BitRC4\0";
pub const NID_pbe_WithSHA1And128BitRC4: u32 = 144;
pub const SN_pbe_WithSHA1And40BitRC4: &[u8; 16] = b"PBE-SHA1-RC4-40\0";
pub const LN_pbe_WithSHA1And40BitRC4: &[u8; 23] = b"pbeWithSHA1And40BitRC4\0";
pub const NID_pbe_WithSHA1And40BitRC4: u32 = 145;
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 14] = b"PBE-SHA1-3DES\0";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC: &[u8; 33] = b"pbeWithSHA1And3-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC: u32 = 146;
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 14] = b"PBE-SHA1-2DES\0";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC: &[u8; 33] = b"pbeWithSHA1And2-KeyTripleDES-CBC\0";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC: u32 = 147;
pub const SN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 17] = b"PBE-SHA1-RC2-128\0";
pub const LN_pbe_WithSHA1And128BitRC2_CBC: &[u8; 28] = b"pbeWithSHA1And128BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And128BitRC2_CBC: u32 = 148;
pub const SN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 16] = b"PBE-SHA1-RC2-40\0";
pub const LN_pbe_WithSHA1And40BitRC2_CBC: &[u8; 27] = b"pbeWithSHA1And40BitRC2-CBC\0";
pub const NID_pbe_WithSHA1And40BitRC2_CBC: u32 = 149;
pub const LN_keyBag: &[u8; 7] = b"keyBag\0";
pub const NID_keyBag: u32 = 150;
pub const LN_pkcs8ShroudedKeyBag: &[u8; 20] = b"pkcs8ShroudedKeyBag\0";
pub const NID_pkcs8ShroudedKeyBag: u32 = 151;
pub const LN_certBag: &[u8; 8] = b"certBag\0";
pub const NID_certBag: u32 = 152;
pub const LN_crlBag: &[u8; 7] = b"crlBag\0";
pub const NID_crlBag: u32 = 153;
pub const LN_secretBag: &[u8; 10] = b"secretBag\0";
pub const NID_secretBag: u32 = 154;
pub const LN_safeContentsBag: &[u8; 16] = b"safeContentsBag\0";
pub const NID_safeContentsBag: u32 = 155;
pub const LN_friendlyName: &[u8; 13] = b"friendlyName\0";
pub const NID_friendlyName: u32 = 156;
pub const LN_localKeyID: &[u8; 11] = b"localKeyID\0";
pub const NID_localKeyID: u32 = 157;
pub const LN_x509Certificate: &[u8; 16] = b"x509Certificate\0";
pub const NID_x509Certificate: u32 = 158;
pub const LN_sdsiCertificate: &[u8; 16] = b"sdsiCertificate\0";
pub const NID_sdsiCertificate: u32 = 159;
pub const LN_x509Crl: &[u8; 8] = b"x509Crl\0";
pub const NID_x509Crl: u32 = 160;
pub const LN_pbes2: &[u8; 6] = b"PBES2\0";
pub const NID_pbes2: u32 = 161;
pub const LN_pbmac1: &[u8; 7] = b"PBMAC1\0";
pub const NID_pbmac1: u32 = 162;
pub const LN_hmacWithSHA1: &[u8; 13] = b"hmacWithSHA1\0";
pub const NID_hmacWithSHA1: u32 = 163;
pub const SN_id_qt_cps: &[u8; 10] = b"id-qt-cps\0";
pub const LN_id_qt_cps: &[u8; 21] = b"Policy Qualifier CPS\0";
pub const NID_id_qt_cps: u32 = 164;
pub const SN_id_qt_unotice: &[u8; 14] = b"id-qt-unotice\0";
pub const LN_id_qt_unotice: &[u8; 29] = b"Policy Qualifier User Notice\0";
pub const NID_id_qt_unotice: u32 = 165;
pub const SN_rc2_64_cbc: &[u8; 11] = b"RC2-64-CBC\0";
pub const LN_rc2_64_cbc: &[u8; 11] = b"rc2-64-cbc\0";
pub const NID_rc2_64_cbc: u32 = 166;
pub const SN_SMIMECapabilities: &[u8; 11] = b"SMIME-CAPS\0";
pub const LN_SMIMECapabilities: &[u8; 20] = b"S/MIME Capabilities\0";
pub const NID_SMIMECapabilities: u32 = 167;
pub const SN_pbeWithMD2AndRC2_CBC: &[u8; 15] = b"PBE-MD2-RC2-64\0";
pub const LN_pbeWithMD2AndRC2_CBC: &[u8; 21] = b"pbeWithMD2AndRC2-CBC\0";
pub const NID_pbeWithMD2AndRC2_CBC: u32 = 168;
pub const SN_pbeWithMD5AndRC2_CBC: &[u8; 15] = b"PBE-MD5-RC2-64\0";
pub const LN_pbeWithMD5AndRC2_CBC: &[u8; 21] = b"pbeWithMD5AndRC2-CBC\0";
pub const NID_pbeWithMD5AndRC2_CBC: u32 = 169;
pub const SN_pbeWithSHA1AndDES_CBC: &[u8; 13] = b"PBE-SHA1-DES\0";
pub const LN_pbeWithSHA1AndDES_CBC: &[u8; 22] = b"pbeWithSHA1AndDES-CBC\0";
pub const NID_pbeWithSHA1AndDES_CBC: u32 = 170;
pub const SN_ms_ext_req: &[u8; 9] = b"msExtReq\0";
pub const LN_ms_ext_req: &[u8; 28] = b"Microsoft Extension Request\0";
pub const NID_ms_ext_req: u32 = 171;
pub const SN_ext_req: &[u8; 7] = b"extReq\0";
pub const LN_ext_req: &[u8; 18] = b"Extension Request\0";
pub const NID_ext_req: u32 = 172;
pub const SN_name: &[u8; 5] = b"name\0";
pub const LN_name: &[u8; 5] = b"name\0";
pub const NID_name: u32 = 173;
pub const SN_dnQualifier: &[u8; 12] = b"dnQualifier\0";
pub const LN_dnQualifier: &[u8; 12] = b"dnQualifier\0";
pub const NID_dnQualifier: u32 = 174;
pub const SN_id_pe: &[u8; 6] = b"id-pe\0";
pub const NID_id_pe: u32 = 175;
pub const SN_id_ad: &[u8; 6] = b"id-ad\0";
pub const NID_id_ad: u32 = 176;
pub const SN_info_access: &[u8; 20] = b"authorityInfoAccess\0";
pub const LN_info_access: &[u8; 29] = b"Authority Information Access\0";
pub const NID_info_access: u32 = 177;
pub const SN_ad_OCSP: &[u8; 5] = b"OCSP\0";
pub const LN_ad_OCSP: &[u8; 5] = b"OCSP\0";
pub const NID_ad_OCSP: u32 = 178;
pub const SN_ad_ca_issuers: &[u8; 10] = b"caIssuers\0";
pub const LN_ad_ca_issuers: &[u8; 11] = b"CA Issuers\0";
pub const NID_ad_ca_issuers: u32 = 179;
pub const SN_OCSP_sign: &[u8; 12] = b"OCSPSigning\0";
pub const LN_OCSP_sign: &[u8; 13] = b"OCSP Signing\0";
pub const NID_OCSP_sign: u32 = 180;
pub const SN_iso: &[u8; 4] = b"ISO\0";
pub const LN_iso: &[u8; 4] = b"iso\0";
pub const NID_iso: u32 = 181;
pub const OBJ_iso: u32 = 1;
pub const SN_member_body: &[u8; 12] = b"member-body\0";
pub const LN_member_body: &[u8; 16] = b"ISO Member Body\0";
pub const NID_member_body: u32 = 182;
pub const SN_ISO_US: &[u8; 7] = b"ISO-US\0";
pub const LN_ISO_US: &[u8; 19] = b"ISO US Member Body\0";
pub const NID_ISO_US: u32 = 183;
pub const SN_X9_57: &[u8; 6] = b"X9-57\0";
pub const LN_X9_57: &[u8; 6] = b"X9.57\0";
pub const NID_X9_57: u32 = 184;
pub const SN_X9cm: &[u8; 5] = b"X9cm\0";
pub const LN_X9cm: &[u8; 11] = b"X9.57 CM ?\0";
pub const NID_X9cm: u32 = 185;
pub const SN_pkcs1: &[u8; 6] = b"pkcs1\0";
pub const NID_pkcs1: u32 = 186;
pub const SN_pkcs5: &[u8; 6] = b"pkcs5\0";
pub const NID_pkcs5: u32 = 187;
pub const SN_SMIME: &[u8; 6] = b"SMIME\0";
pub const LN_SMIME: &[u8; 7] = b"S/MIME\0";
pub const NID_SMIME: u32 = 188;
pub const SN_id_smime_mod: &[u8; 13] = b"id-smime-mod\0";
pub const NID_id_smime_mod: u32 = 189;
pub const SN_id_smime_ct: &[u8; 12] = b"id-smime-ct\0";
pub const NID_id_smime_ct: u32 = 190;
pub const SN_id_smime_aa: &[u8; 12] = b"id-smime-aa\0";
pub const NID_id_smime_aa: u32 = 191;
pub const SN_id_smime_alg: &[u8; 13] = b"id-smime-alg\0";
pub const NID_id_smime_alg: u32 = 192;
pub const SN_id_smime_cd: &[u8; 12] = b"id-smime-cd\0";
pub const NID_id_smime_cd: u32 = 193;
pub const SN_id_smime_spq: &[u8; 13] = b"id-smime-spq\0";
pub const NID_id_smime_spq: u32 = 194;
pub const SN_id_smime_cti: &[u8; 13] = b"id-smime-cti\0";
pub const NID_id_smime_cti: u32 = 195;
pub const SN_id_smime_mod_cms: &[u8; 17] = b"id-smime-mod-cms\0";
pub const NID_id_smime_mod_cms: u32 = 196;
pub const SN_id_smime_mod_ess: &[u8; 17] = b"id-smime-mod-ess\0";
pub const NID_id_smime_mod_ess: u32 = 197;
pub const SN_id_smime_mod_oid: &[u8; 17] = b"id-smime-mod-oid\0";
pub const NID_id_smime_mod_oid: u32 = 198;
pub const SN_id_smime_mod_msg_v3: &[u8; 20] = b"id-smime-mod-msg-v3\0";
pub const NID_id_smime_mod_msg_v3: u32 = 199;
pub const SN_id_smime_mod_ets_eSignature_88: &[u8; 31] = b"id-smime-mod-ets-eSignature-88\0";
pub const NID_id_smime_mod_ets_eSignature_88: u32 = 200;
pub const SN_id_smime_mod_ets_eSignature_97: &[u8; 31] = b"id-smime-mod-ets-eSignature-97\0";
pub const NID_id_smime_mod_ets_eSignature_97: u32 = 201;
pub const SN_id_smime_mod_ets_eSigPolicy_88: &[u8; 31] = b"id-smime-mod-ets-eSigPolicy-88\0";
pub const NID_id_smime_mod_ets_eSigPolicy_88: u32 = 202;
pub const SN_id_smime_mod_ets_eSigPolicy_97: &[u8; 31] = b"id-smime-mod-ets-eSigPolicy-97\0";
pub const NID_id_smime_mod_ets_eSigPolicy_97: u32 = 203;
pub const SN_id_smime_ct_receipt: &[u8; 20] = b"id-smime-ct-receipt\0";
pub const NID_id_smime_ct_receipt: u32 = 204;
pub const SN_id_smime_ct_authData: &[u8; 21] = b"id-smime-ct-authData\0";
pub const NID_id_smime_ct_authData: u32 = 205;
pub const SN_id_smime_ct_publishCert: &[u8; 24] = b"id-smime-ct-publishCert\0";
pub const NID_id_smime_ct_publishCert: u32 = 206;
pub const SN_id_smime_ct_TSTInfo: &[u8; 20] = b"id-smime-ct-TSTInfo\0";
pub const NID_id_smime_ct_TSTInfo: u32 = 207;
pub const SN_id_smime_ct_TDTInfo: &[u8; 20] = b"id-smime-ct-TDTInfo\0";
pub const NID_id_smime_ct_TDTInfo: u32 = 208;
pub const SN_id_smime_ct_contentInfo: &[u8; 24] = b"id-smime-ct-contentInfo\0";
pub const NID_id_smime_ct_contentInfo: u32 = 209;
pub const SN_id_smime_ct_DVCSRequestData: &[u8; 28] = b"id-smime-ct-DVCSRequestData\0";
pub const NID_id_smime_ct_DVCSRequestData: u32 = 210;
pub const SN_id_smime_ct_DVCSResponseData: &[u8; 29] = b"id-smime-ct-DVCSResponseData\0";
pub const NID_id_smime_ct_DVCSResponseData: u32 = 211;
pub const SN_id_smime_aa_receiptRequest: &[u8; 27] = b"id-smime-aa-receiptRequest\0";
pub const NID_id_smime_aa_receiptRequest: u32 = 212;
pub const SN_id_smime_aa_securityLabel: &[u8; 26] = b"id-smime-aa-securityLabel\0";
pub const NID_id_smime_aa_securityLabel: u32 = 213;
pub const SN_id_smime_aa_mlExpandHistory: &[u8; 28] = b"id-smime-aa-mlExpandHistory\0";
pub const NID_id_smime_aa_mlExpandHistory: u32 = 214;
pub const SN_id_smime_aa_contentHint: &[u8; 24] = b"id-smime-aa-contentHint\0";
pub const NID_id_smime_aa_contentHint: u32 = 215;
pub const SN_id_smime_aa_msgSigDigest: &[u8; 25] = b"id-smime-aa-msgSigDigest\0";
pub const NID_id_smime_aa_msgSigDigest: u32 = 216;
pub const SN_id_smime_aa_encapContentType: &[u8; 29] = b"id-smime-aa-encapContentType\0";
pub const NID_id_smime_aa_encapContentType: u32 = 217;
pub const SN_id_smime_aa_contentIdentifier: &[u8; 30] = b"id-smime-aa-contentIdentifier\0";
pub const NID_id_smime_aa_contentIdentifier: u32 = 218;
pub const SN_id_smime_aa_macValue: &[u8; 21] = b"id-smime-aa-macValue\0";
pub const NID_id_smime_aa_macValue: u32 = 219;
pub const SN_id_smime_aa_equivalentLabels: &[u8; 29] = b"id-smime-aa-equivalentLabels\0";
pub const NID_id_smime_aa_equivalentLabels: u32 = 220;
pub const SN_id_smime_aa_contentReference: &[u8; 29] = b"id-smime-aa-contentReference\0";
pub const NID_id_smime_aa_contentReference: u32 = 221;
pub const SN_id_smime_aa_encrypKeyPref: &[u8; 26] = b"id-smime-aa-encrypKeyPref\0";
pub const NID_id_smime_aa_encrypKeyPref: u32 = 222;
pub const SN_id_smime_aa_signingCertificate: &[u8; 31] = b"id-smime-aa-signingCertificate\0";
pub const NID_id_smime_aa_signingCertificate: u32 = 223;
pub const SN_id_smime_aa_smimeEncryptCerts: &[u8; 30] = b"id-smime-aa-smimeEncryptCerts\0";
pub const NID_id_smime_aa_smimeEncryptCerts: u32 = 224;
pub const SN_id_smime_aa_timeStampToken: &[u8; 27] = b"id-smime-aa-timeStampToken\0";
pub const NID_id_smime_aa_timeStampToken: u32 = 225;
pub const SN_id_smime_aa_ets_sigPolicyId: &[u8; 28] = b"id-smime-aa-ets-sigPolicyId\0";
pub const NID_id_smime_aa_ets_sigPolicyId: u32 = 226;
pub const SN_id_smime_aa_ets_commitmentType: &[u8; 31] = b"id-smime-aa-ets-commitmentType\0";
pub const NID_id_smime_aa_ets_commitmentType: u32 = 227;
pub const SN_id_smime_aa_ets_signerLocation: &[u8; 31] = b"id-smime-aa-ets-signerLocation\0";
pub const NID_id_smime_aa_ets_signerLocation: u32 = 228;
pub const SN_id_smime_aa_ets_signerAttr: &[u8; 27] = b"id-smime-aa-ets-signerAttr\0";
pub const NID_id_smime_aa_ets_signerAttr: u32 = 229;
pub const SN_id_smime_aa_ets_otherSigCert: &[u8; 29] = b"id-smime-aa-ets-otherSigCert\0";
pub const NID_id_smime_aa_ets_otherSigCert: u32 = 230;
pub const SN_id_smime_aa_ets_contentTimestamp: &[u8; 33] = b"id-smime-aa-ets-contentTimestamp\0";
pub const NID_id_smime_aa_ets_contentTimestamp: u32 = 231;
pub const SN_id_smime_aa_ets_CertificateRefs: &[u8; 32] = b"id-smime-aa-ets-CertificateRefs\0";
pub const NID_id_smime_aa_ets_CertificateRefs: u32 = 232;
pub const SN_id_smime_aa_ets_RevocationRefs: &[u8; 31] = b"id-smime-aa-ets-RevocationRefs\0";
pub const NID_id_smime_aa_ets_RevocationRefs: u32 = 233;
pub const SN_id_smime_aa_ets_certValues: &[u8; 27] = b"id-smime-aa-ets-certValues\0";
pub const NID_id_smime_aa_ets_certValues: u32 = 234;
pub const SN_id_smime_aa_ets_revocationValues: &[u8; 33] = b"id-smime-aa-ets-revocationValues\0";
pub const NID_id_smime_aa_ets_revocationValues: u32 = 235;
pub const SN_id_smime_aa_ets_escTimeStamp: &[u8; 29] = b"id-smime-aa-ets-escTimeStamp\0";
pub const NID_id_smime_aa_ets_escTimeStamp: u32 = 236;
pub const SN_id_smime_aa_ets_certCRLTimestamp: &[u8; 33] = b"id-smime-aa-ets-certCRLTimestamp\0";
pub const NID_id_smime_aa_ets_certCRLTimestamp: u32 = 237;
pub const SN_id_smime_aa_ets_archiveTimeStamp: &[u8; 33] = b"id-smime-aa-ets-archiveTimeStamp\0";
pub const NID_id_smime_aa_ets_archiveTimeStamp: u32 = 238;
pub const SN_id_smime_aa_signatureType: &[u8; 26] = b"id-smime-aa-signatureType\0";
pub const NID_id_smime_aa_signatureType: u32 = 239;
pub const SN_id_smime_aa_dvcs_dvc: &[u8; 21] = b"id-smime-aa-dvcs-dvc\0";
pub const NID_id_smime_aa_dvcs_dvc: u32 = 240;
pub const SN_id_smime_alg_ESDHwith3DES: &[u8; 26] = b"id-smime-alg-ESDHwith3DES\0";
pub const NID_id_smime_alg_ESDHwith3DES: u32 = 241;
pub const SN_id_smime_alg_ESDHwithRC2: &[u8; 25] = b"id-smime-alg-ESDHwithRC2\0";
pub const NID_id_smime_alg_ESDHwithRC2: u32 = 242;
pub const SN_id_smime_alg_3DESwrap: &[u8; 22] = b"id-smime-alg-3DESwrap\0";
pub const NID_id_smime_alg_3DESwrap: u32 = 243;
pub const SN_id_smime_alg_RC2wrap: &[u8; 21] = b"id-smime-alg-RC2wrap\0";
pub const NID_id_smime_alg_RC2wrap: u32 = 244;
pub const SN_id_smime_alg_ESDH: &[u8; 18] = b"id-smime-alg-ESDH\0";
pub const NID_id_smime_alg_ESDH: u32 = 245;
pub const SN_id_smime_alg_CMS3DESwrap: &[u8; 25] = b"id-smime-alg-CMS3DESwrap\0";
pub const NID_id_smime_alg_CMS3DESwrap: u32 = 246;
pub const SN_id_smime_alg_CMSRC2wrap: &[u8; 24] = b"id-smime-alg-CMSRC2wrap\0";
pub const NID_id_smime_alg_CMSRC2wrap: u32 = 247;
pub const SN_id_smime_cd_ldap: &[u8; 17] = b"id-smime-cd-ldap\0";
pub const NID_id_smime_cd_ldap: u32 = 248;
pub const SN_id_smime_spq_ets_sqt_uri: &[u8; 25] = b"id-smime-spq-ets-sqt-uri\0";
pub const NID_id_smime_spq_ets_sqt_uri: u32 = 249;
pub const SN_id_smime_spq_ets_sqt_unotice: &[u8; 29] = b"id-smime-spq-ets-sqt-unotice\0";
pub const NID_id_smime_spq_ets_sqt_unotice: u32 = 250;
pub const SN_id_smime_cti_ets_proofOfOrigin: &[u8; 31] = b"id-smime-cti-ets-proofOfOrigin\0";
pub const NID_id_smime_cti_ets_proofOfOrigin: u32 = 251;
pub const SN_id_smime_cti_ets_proofOfReceipt: &[u8; 32] = b"id-smime-cti-ets-proofOfReceipt\0";
pub const NID_id_smime_cti_ets_proofOfReceipt: u32 = 252;
pub const SN_id_smime_cti_ets_proofOfDelivery: &[u8; 33] = b"id-smime-cti-ets-proofOfDelivery\0";
pub const NID_id_smime_cti_ets_proofOfDelivery: u32 = 253;
pub const SN_id_smime_cti_ets_proofOfSender: &[u8; 31] = b"id-smime-cti-ets-proofOfSender\0";
pub const NID_id_smime_cti_ets_proofOfSender: u32 = 254;
pub const SN_id_smime_cti_ets_proofOfApproval: &[u8; 33] = b"id-smime-cti-ets-proofOfApproval\0";
pub const NID_id_smime_cti_ets_proofOfApproval: u32 = 255;
pub const SN_id_smime_cti_ets_proofOfCreation: &[u8; 33] = b"id-smime-cti-ets-proofOfCreation\0";
pub const NID_id_smime_cti_ets_proofOfCreation: u32 = 256;
pub const SN_md4: &[u8; 4] = b"MD4\0";
pub const LN_md4: &[u8; 4] = b"md4\0";
pub const NID_md4: u32 = 257;
pub const SN_id_pkix_mod: &[u8; 12] = b"id-pkix-mod\0";
pub const NID_id_pkix_mod: u32 = 258;
pub const SN_id_qt: &[u8; 6] = b"id-qt\0";
pub const NID_id_qt: u32 = 259;
pub const SN_id_it: &[u8; 6] = b"id-it\0";
pub const NID_id_it: u32 = 260;
pub const SN_id_pkip: &[u8; 8] = b"id-pkip\0";
pub const NID_id_pkip: u32 = 261;
pub const SN_id_alg: &[u8; 7] = b"id-alg\0";
pub const NID_id_alg: u32 = 262;
pub const SN_id_cmc: &[u8; 7] = b"id-cmc\0";
pub const NID_id_cmc: u32 = 263;
pub const SN_id_on: &[u8; 6] = b"id-on\0";
pub const NID_id_on: u32 = 264;
pub const SN_id_pda: &[u8; 7] = b"id-pda\0";
pub const NID_id_pda: u32 = 265;
pub const SN_id_aca: &[u8; 7] = b"id-aca\0";
pub const NID_id_aca: u32 = 266;
pub const SN_id_qcs: &[u8; 7] = b"id-qcs\0";
pub const NID_id_qcs: u32 = 267;
pub const SN_id_cct: &[u8; 7] = b"id-cct\0";
pub const NID_id_cct: u32 = 268;
pub const SN_id_pkix1_explicit_88: &[u8; 21] = b"id-pkix1-explicit-88\0";
pub const NID_id_pkix1_explicit_88: u32 = 269;
pub const SN_id_pkix1_implicit_88: &[u8; 21] = b"id-pkix1-implicit-88\0";
pub const NID_id_pkix1_implicit_88: u32 = 270;
pub const SN_id_pkix1_explicit_93: &[u8; 21] = b"id-pkix1-explicit-93\0";
pub const NID_id_pkix1_explicit_93: u32 = 271;
pub const SN_id_pkix1_implicit_93: &[u8; 21] = b"id-pkix1-implicit-93\0";
pub const NID_id_pkix1_implicit_93: u32 = 272;
pub const SN_id_mod_crmf: &[u8; 12] = b"id-mod-crmf\0";
pub const NID_id_mod_crmf: u32 = 273;
pub const SN_id_mod_cmc: &[u8; 11] = b"id-mod-cmc\0";
pub const NID_id_mod_cmc: u32 = 274;
pub const SN_id_mod_kea_profile_88: &[u8; 22] = b"id-mod-kea-profile-88\0";
pub const NID_id_mod_kea_profile_88: u32 = 275;
pub const SN_id_mod_kea_profile_93: &[u8; 22] = b"id-mod-kea-profile-93\0";
pub const NID_id_mod_kea_profile_93: u32 = 276;
pub const SN_id_mod_cmp: &[u8; 11] = b"id-mod-cmp\0";
pub const NID_id_mod_cmp: u32 = 277;
pub const SN_id_mod_qualified_cert_88: &[u8; 25] = b"id-mod-qualified-cert-88\0";
pub const NID_id_mod_qualified_cert_88: u32 = 278;
pub const SN_id_mod_qualified_cert_93: &[u8; 25] = b"id-mod-qualified-cert-93\0";
pub const NID_id_mod_qualified_cert_93: u32 = 279;
pub const SN_id_mod_attribute_cert: &[u8; 22] = b"id-mod-attribute-cert\0";
pub const NID_id_mod_attribute_cert: u32 = 280;
pub const SN_id_mod_timestamp_protocol: &[u8; 26] = b"id-mod-timestamp-protocol\0";
pub const NID_id_mod_timestamp_protocol: u32 = 281;
pub const SN_id_mod_ocsp: &[u8; 12] = b"id-mod-ocsp\0";
pub const NID_id_mod_ocsp: u32 = 282;
pub const SN_id_mod_dvcs: &[u8; 12] = b"id-mod-dvcs\0";
pub const NID_id_mod_dvcs: u32 = 283;
pub const SN_id_mod_cmp2000: &[u8; 15] = b"id-mod-cmp2000\0";
pub const NID_id_mod_cmp2000: u32 = 284;
pub const SN_biometricInfo: &[u8; 14] = b"biometricInfo\0";
pub const LN_biometricInfo: &[u8; 15] = b"Biometric Info\0";
pub const NID_biometricInfo: u32 = 285;
pub const SN_qcStatements: &[u8; 13] = b"qcStatements\0";
pub const NID_qcStatements: u32 = 286;
pub const SN_ac_auditEntity: &[u8; 15] = b"ac-auditEntity\0";
pub const NID_ac_auditEntity: u32 = 287;
pub const SN_ac_targeting: &[u8; 13] = b"ac-targeting\0";
pub const NID_ac_targeting: u32 = 288;
pub const SN_aaControls: &[u8; 11] = b"aaControls\0";
pub const NID_aaControls: u32 = 289;
pub const SN_sbgp_ipAddrBlock: &[u8; 17] = b"sbgp-ipAddrBlock\0";
pub const NID_sbgp_ipAddrBlock: u32 = 290;
pub const SN_sbgp_autonomousSysNum: &[u8; 22] = b"sbgp-autonomousSysNum\0";
pub const NID_sbgp_autonomousSysNum: u32 = 291;
pub const SN_sbgp_routerIdentifier: &[u8; 22] = b"sbgp-routerIdentifier\0";
pub const NID_sbgp_routerIdentifier: u32 = 292;
pub const SN_textNotice: &[u8; 11] = b"textNotice\0";
pub const NID_textNotice: u32 = 293;
pub const SN_ipsecEndSystem: &[u8; 15] = b"ipsecEndSystem\0";
pub const LN_ipsecEndSystem: &[u8; 17] = b"IPSec End System\0";
pub const NID_ipsecEndSystem: u32 = 294;
pub const SN_ipsecTunnel: &[u8; 12] = b"ipsecTunnel\0";
pub const LN_ipsecTunnel: &[u8; 13] = b"IPSec Tunnel\0";
pub const NID_ipsecTunnel: u32 = 295;
pub const SN_ipsecUser: &[u8; 10] = b"ipsecUser\0";
pub const LN_ipsecUser: &[u8; 11] = b"IPSec User\0";
pub const NID_ipsecUser: u32 = 296;
pub const SN_dvcs: &[u8; 5] = b"DVCS\0";
pub const LN_dvcs: &[u8; 5] = b"dvcs\0";
pub const NID_dvcs: u32 = 297;
pub const SN_id_it_caProtEncCert: &[u8; 20] = b"id-it-caProtEncCert\0";
pub const NID_id_it_caProtEncCert: u32 = 298;
pub const SN_id_it_signKeyPairTypes: &[u8; 23] = b"id-it-signKeyPairTypes\0";
pub const NID_id_it_signKeyPairTypes: u32 = 299;
pub const SN_id_it_encKeyPairTypes: &[u8; 22] = b"id-it-encKeyPairTypes\0";
pub const NID_id_it_encKeyPairTypes: u32 = 300;
pub const SN_id_it_preferredSymmAlg: &[u8; 23] = b"id-it-preferredSymmAlg\0";
pub const NID_id_it_preferredSymmAlg: u32 = 301;
pub const SN_id_it_caKeyUpdateInfo: &[u8; 22] = b"id-it-caKeyUpdateInfo\0";
pub const NID_id_it_caKeyUpdateInfo: u32 = 302;
pub const SN_id_it_currentCRL: &[u8; 17] = b"id-it-currentCRL\0";
pub const NID_id_it_currentCRL: u32 = 303;
pub const SN_id_it_unsupportedOIDs: &[u8; 22] = b"id-it-unsupportedOIDs\0";
pub const NID_id_it_unsupportedOIDs: u32 = 304;
pub const SN_id_it_subscriptionRequest: &[u8; 26] = b"id-it-subscriptionRequest\0";
pub const NID_id_it_subscriptionRequest: u32 = 305;
pub const SN_id_it_subscriptionResponse: &[u8; 27] = b"id-it-subscriptionResponse\0";
pub const NID_id_it_subscriptionResponse: u32 = 306;
pub const SN_id_it_keyPairParamReq: &[u8; 22] = b"id-it-keyPairParamReq\0";
pub const NID_id_it_keyPairParamReq: u32 = 307;
pub const SN_id_it_keyPairParamRep: &[u8; 22] = b"id-it-keyPairParamRep\0";
pub const NID_id_it_keyPairParamRep: u32 = 308;
pub const SN_id_it_revPassphrase: &[u8; 20] = b"id-it-revPassphrase\0";
pub const NID_id_it_revPassphrase: u32 = 309;
pub const SN_id_it_implicitConfirm: &[u8; 22] = b"id-it-implicitConfirm\0";
pub const NID_id_it_implicitConfirm: u32 = 310;
pub const SN_id_it_confirmWaitTime: &[u8; 22] = b"id-it-confirmWaitTime\0";
pub const NID_id_it_confirmWaitTime: u32 = 311;
pub const SN_id_it_origPKIMessage: &[u8; 21] = b"id-it-origPKIMessage\0";
pub const NID_id_it_origPKIMessage: u32 = 312;
pub const SN_id_regCtrl: &[u8; 11] = b"id-regCtrl\0";
pub const NID_id_regCtrl: u32 = 313;
pub const SN_id_regInfo: &[u8; 11] = b"id-regInfo\0";
pub const NID_id_regInfo: u32 = 314;
pub const SN_id_regCtrl_regToken: &[u8; 20] = b"id-regCtrl-regToken\0";
pub const NID_id_regCtrl_regToken: u32 = 315;
pub const SN_id_regCtrl_authenticator: &[u8; 25] = b"id-regCtrl-authenticator\0";
pub const NID_id_regCtrl_authenticator: u32 = 316;
pub const SN_id_regCtrl_pkiPublicationInfo: &[u8; 30] = b"id-regCtrl-pkiPublicationInfo\0";
pub const NID_id_regCtrl_pkiPublicationInfo: u32 = 317;
pub const SN_id_regCtrl_pkiArchiveOptions: &[u8; 29] = b"id-regCtrl-pkiArchiveOptions\0";
pub const NID_id_regCtrl_pkiArchiveOptions: u32 = 318;
pub const SN_id_regCtrl_oldCertID: &[u8; 21] = b"id-regCtrl-oldCertID\0";
pub const NID_id_regCtrl_oldCertID: u32 = 319;
pub const SN_id_regCtrl_protocolEncrKey: &[u8; 27] = b"id-regCtrl-protocolEncrKey\0";
pub const NID_id_regCtrl_protocolEncrKey: u32 = 320;
pub const SN_id_regInfo_utf8Pairs: &[u8; 21] = b"id-regInfo-utf8Pairs\0";
pub const NID_id_regInfo_utf8Pairs: u32 = 321;
pub const SN_id_regInfo_certReq: &[u8; 19] = b"id-regInfo-certReq\0";
pub const NID_id_regInfo_certReq: u32 = 322;
pub const SN_id_alg_des40: &[u8; 13] = b"id-alg-des40\0";
pub const NID_id_alg_des40: u32 = 323;
pub const SN_id_alg_noSignature: &[u8; 19] = b"id-alg-noSignature\0";
pub const NID_id_alg_noSignature: u32 = 324;
pub const SN_id_alg_dh_sig_hmac_sha1: &[u8; 24] = b"id-alg-dh-sig-hmac-sha1\0";
pub const NID_id_alg_dh_sig_hmac_sha1: u32 = 325;
pub const SN_id_alg_dh_pop: &[u8; 14] = b"id-alg-dh-pop\0";
pub const NID_id_alg_dh_pop: u32 = 326;
pub const SN_id_cmc_statusInfo: &[u8; 18] = b"id-cmc-statusInfo\0";
pub const NID_id_cmc_statusInfo: u32 = 327;
pub const SN_id_cmc_identification: &[u8; 22] = b"id-cmc-identification\0";
pub const NID_id_cmc_identification: u32 = 328;
pub const SN_id_cmc_identityProof: &[u8; 21] = b"id-cmc-identityProof\0";
pub const NID_id_cmc_identityProof: u32 = 329;
pub const SN_id_cmc_dataReturn: &[u8; 18] = b"id-cmc-dataReturn\0";
pub const NID_id_cmc_dataReturn: u32 = 330;
pub const SN_id_cmc_transactionId: &[u8; 21] = b"id-cmc-transactionId\0";
pub const NID_id_cmc_transactionId: u32 = 331;
pub const SN_id_cmc_senderNonce: &[u8; 19] = b"id-cmc-senderNonce\0";
pub const NID_id_cmc_senderNonce: u32 = 332;
pub const SN_id_cmc_recipientNonce: &[u8; 22] = b"id-cmc-recipientNonce\0";
pub const NID_id_cmc_recipientNonce: u32 = 333;
pub const SN_id_cmc_addExtensions: &[u8; 21] = b"id-cmc-addExtensions\0";
pub const NID_id_cmc_addExtensions: u32 = 334;
pub const SN_id_cmc_encryptedPOP: &[u8; 20] = b"id-cmc-encryptedPOP\0";
pub const NID_id_cmc_encryptedPOP: u32 = 335;
pub const SN_id_cmc_decryptedPOP: &[u8; 20] = b"id-cmc-decryptedPOP\0";
pub const NID_id_cmc_decryptedPOP: u32 = 336;
pub const SN_id_cmc_lraPOPWitness: &[u8; 21] = b"id-cmc-lraPOPWitness\0";
pub const NID_id_cmc_lraPOPWitness: u32 = 337;
pub const SN_id_cmc_getCert: &[u8; 15] = b"id-cmc-getCert\0";
pub const NID_id_cmc_getCert: u32 = 338;
pub const SN_id_cmc_getCRL: &[u8; 14] = b"id-cmc-getCRL\0";
pub const NID_id_cmc_getCRL: u32 = 339;
pub const SN_id_cmc_revokeRequest: &[u8; 21] = b"id-cmc-revokeRequest\0";
pub const NID_id_cmc_revokeRequest: u32 = 340;
pub const SN_id_cmc_regInfo: &[u8; 15] = b"id-cmc-regInfo\0";
pub const NID_id_cmc_regInfo: u32 = 341;
pub const SN_id_cmc_responseInfo: &[u8; 20] = b"id-cmc-responseInfo\0";
pub const NID_id_cmc_responseInfo: u32 = 342;
pub const SN_id_cmc_queryPending: &[u8; 20] = b"id-cmc-queryPending\0";
pub const NID_id_cmc_queryPending: u32 = 343;
pub const SN_id_cmc_popLinkRandom: &[u8; 21] = b"id-cmc-popLinkRandom\0";
pub const NID_id_cmc_popLinkRandom: u32 = 344;
pub const SN_id_cmc_popLinkWitness: &[u8; 22] = b"id-cmc-popLinkWitness\0";
pub const NID_id_cmc_popLinkWitness: u32 = 345;
pub const SN_id_cmc_confirmCertAcceptance: &[u8; 29] = b"id-cmc-confirmCertAcceptance\0";
pub const NID_id_cmc_confirmCertAcceptance: u32 = 346;
pub const SN_id_on_personalData: &[u8; 19] = b"id-on-personalData\0";
pub const NID_id_on_personalData: u32 = 347;
pub const SN_id_pda_dateOfBirth: &[u8; 19] = b"id-pda-dateOfBirth\0";
pub const NID_id_pda_dateOfBirth: u32 = 348;
pub const SN_id_pda_placeOfBirth: &[u8; 20] = b"id-pda-placeOfBirth\0";
pub const NID_id_pda_placeOfBirth: u32 = 349;
pub const SN_id_pda_gender: &[u8; 14] = b"id-pda-gender\0";
pub const NID_id_pda_gender: u32 = 351;
pub const SN_id_pda_countryOfCitizenship: &[u8; 28] = b"id-pda-countryOfCitizenship\0";
pub const NID_id_pda_countryOfCitizenship: u32 = 352;
pub const SN_id_pda_countryOfResidence: &[u8; 26] = b"id-pda-countryOfResidence\0";
pub const NID_id_pda_countryOfResidence: u32 = 353;
pub const SN_id_aca_authenticationInfo: &[u8; 26] = b"id-aca-authenticationInfo\0";
pub const NID_id_aca_authenticationInfo: u32 = 354;
pub const SN_id_aca_accessIdentity: &[u8; 22] = b"id-aca-accessIdentity\0";
pub const NID_id_aca_accessIdentity: u32 = 355;
pub const SN_id_aca_chargingIdentity: &[u8; 24] = b"id-aca-chargingIdentity\0";
pub const NID_id_aca_chargingIdentity: u32 = 356;
pub const SN_id_aca_group: &[u8; 13] = b"id-aca-group\0";
pub const NID_id_aca_group: u32 = 357;
pub const SN_id_aca_role: &[u8; 12] = b"id-aca-role\0";
pub const NID_id_aca_role: u32 = 358;
pub const SN_id_qcs_pkixQCSyntax_v1: &[u8; 23] = b"id-qcs-pkixQCSyntax-v1\0";
pub const NID_id_qcs_pkixQCSyntax_v1: u32 = 359;
pub const SN_id_cct_crs: &[u8; 11] = b"id-cct-crs\0";
pub const NID_id_cct_crs: u32 = 360;
pub const SN_id_cct_PKIData: &[u8; 15] = b"id-cct-PKIData\0";
pub const NID_id_cct_PKIData: u32 = 361;
pub const SN_id_cct_PKIResponse: &[u8; 19] = b"id-cct-PKIResponse\0";
pub const NID_id_cct_PKIResponse: u32 = 362;
pub const SN_ad_timeStamping: &[u8; 16] = b"ad_timestamping\0";
pub const LN_ad_timeStamping: &[u8; 17] = b"AD Time Stamping\0";
pub const NID_ad_timeStamping: u32 = 363;
pub const SN_ad_dvcs: &[u8; 8] = b"AD_DVCS\0";
pub const LN_ad_dvcs: &[u8; 8] = b"ad dvcs\0";
pub const NID_ad_dvcs: u32 = 364;
pub const SN_id_pkix_OCSP_basic: &[u8; 18] = b"basicOCSPResponse\0";
pub const LN_id_pkix_OCSP_basic: &[u8; 20] = b"Basic OCSP Response\0";
pub const NID_id_pkix_OCSP_basic: u32 = 365;
pub const SN_id_pkix_OCSP_Nonce: &[u8; 6] = b"Nonce\0";
pub const LN_id_pkix_OCSP_Nonce: &[u8; 11] = b"OCSP Nonce\0";
pub const NID_id_pkix_OCSP_Nonce: u32 = 366;
pub const SN_id_pkix_OCSP_CrlID: &[u8; 6] = b"CrlID\0";
pub const LN_id_pkix_OCSP_CrlID: &[u8; 12] = b"OCSP CRL ID\0";
pub const NID_id_pkix_OCSP_CrlID: u32 = 367;
pub const SN_id_pkix_OCSP_acceptableResponses: &[u8; 20] = b"acceptableResponses\0";
pub const LN_id_pkix_OCSP_acceptableResponses: &[u8; 26] = b"Acceptable OCSP Responses\0";
pub const NID_id_pkix_OCSP_acceptableResponses: u32 = 368;
pub const SN_id_pkix_OCSP_noCheck: &[u8; 8] = b"noCheck\0";
pub const LN_id_pkix_OCSP_noCheck: &[u8; 14] = b"OCSP No Check\0";
pub const NID_id_pkix_OCSP_noCheck: u32 = 369;
pub const SN_id_pkix_OCSP_archiveCutoff: &[u8; 14] = b"archiveCutoff\0";
pub const LN_id_pkix_OCSP_archiveCutoff: &[u8; 20] = b"OCSP Archive Cutoff\0";
pub const NID_id_pkix_OCSP_archiveCutoff: u32 = 370;
pub const SN_id_pkix_OCSP_serviceLocator: &[u8; 15] = b"serviceLocator\0";
pub const LN_id_pkix_OCSP_serviceLocator: &[u8; 21] = b"OCSP Service Locator\0";
pub const NID_id_pkix_OCSP_serviceLocator: u32 = 371;
pub const SN_id_pkix_OCSP_extendedStatus: &[u8; 15] = b"extendedStatus\0";
pub const LN_id_pkix_OCSP_extendedStatus: &[u8; 21] = b"Extended OCSP Status\0";
pub const NID_id_pkix_OCSP_extendedStatus: u32 = 372;
pub const SN_id_pkix_OCSP_valid: &[u8; 6] = b"valid\0";
pub const NID_id_pkix_OCSP_valid: u32 = 373;
pub const SN_id_pkix_OCSP_path: &[u8; 5] = b"path\0";
pub const NID_id_pkix_OCSP_path: u32 = 374;
pub const SN_id_pkix_OCSP_trustRoot: &[u8; 10] = b"trustRoot\0";
pub const LN_id_pkix_OCSP_trustRoot: &[u8; 11] = b"Trust Root\0";
pub const NID_id_pkix_OCSP_trustRoot: u32 = 375;
pub const SN_algorithm: &[u8; 10] = b"algorithm\0";
pub const LN_algorithm: &[u8; 10] = b"algorithm\0";
pub const NID_algorithm: u32 = 376;
pub const SN_rsaSignature: &[u8; 13] = b"rsaSignature\0";
pub const NID_rsaSignature: u32 = 377;
pub const SN_X500algorithms: &[u8; 15] = b"X500algorithms\0";
pub const LN_X500algorithms: &[u8; 32] = b"directory services - algorithms\0";
pub const NID_X500algorithms: u32 = 378;
pub const SN_org: &[u8; 4] = b"ORG\0";
pub const LN_org: &[u8; 4] = b"org\0";
pub const NID_org: u32 = 379;
pub const SN_dod: &[u8; 4] = b"DOD\0";
pub const LN_dod: &[u8; 4] = b"dod\0";
pub const NID_dod: u32 = 380;
pub const SN_iana: &[u8; 5] = b"IANA\0";
pub const LN_iana: &[u8; 5] = b"iana\0";
pub const NID_iana: u32 = 381;
pub const SN_Directory: &[u8; 10] = b"directory\0";
pub const LN_Directory: &[u8; 10] = b"Directory\0";
pub const NID_Directory: u32 = 382;
pub const SN_Management: &[u8; 5] = b"mgmt\0";
pub const LN_Management: &[u8; 11] = b"Management\0";
pub const NID_Management: u32 = 383;
pub const SN_Experimental: &[u8; 13] = b"experimental\0";
pub const LN_Experimental: &[u8; 13] = b"Experimental\0";
pub const NID_Experimental: u32 = 384;
pub const SN_Private: &[u8; 8] = b"private\0";
pub const LN_Private: &[u8; 8] = b"Private\0";
pub const NID_Private: u32 = 385;
pub const SN_Security: &[u8; 9] = b"security\0";
pub const LN_Security: &[u8; 9] = b"Security\0";
pub const NID_Security: u32 = 386;
pub const SN_SNMPv2: &[u8; 7] = b"snmpv2\0";
pub const LN_SNMPv2: &[u8; 7] = b"SNMPv2\0";
pub const NID_SNMPv2: u32 = 387;
pub const LN_Mail: &[u8; 5] = b"Mail\0";
pub const NID_Mail: u32 = 388;
pub const SN_Enterprises: &[u8; 12] = b"enterprises\0";
pub const LN_Enterprises: &[u8; 12] = b"Enterprises\0";
pub const NID_Enterprises: u32 = 389;
pub const SN_dcObject: &[u8; 9] = b"dcobject\0";
pub const LN_dcObject: &[u8; 9] = b"dcObject\0";
pub const NID_dcObject: u32 = 390;
pub const SN_domainComponent: &[u8; 3] = b"DC\0";
pub const LN_domainComponent: &[u8; 16] = b"domainComponent\0";
pub const NID_domainComponent: u32 = 391;
pub const SN_Domain: &[u8; 7] = b"domain\0";
pub const LN_Domain: &[u8; 7] = b"Domain\0";
pub const NID_Domain: u32 = 392;
pub const SN_selected_attribute_types: &[u8; 25] = b"selected-attribute-types\0";
pub const LN_selected_attribute_types: &[u8; 25] = b"Selected Attribute Types\0";
pub const NID_selected_attribute_types: u32 = 394;
pub const SN_clearance: &[u8; 10] = b"clearance\0";
pub const NID_clearance: u32 = 395;
pub const SN_md4WithRSAEncryption: &[u8; 8] = b"RSA-MD4\0";
pub const LN_md4WithRSAEncryption: &[u8; 21] = b"md4WithRSAEncryption\0";
pub const NID_md4WithRSAEncryption: u32 = 396;
pub const SN_ac_proxying: &[u8; 12] = b"ac-proxying\0";
pub const NID_ac_proxying: u32 = 397;
pub const SN_sinfo_access: &[u8; 18] = b"subjectInfoAccess\0";
pub const LN_sinfo_access: &[u8; 27] = b"Subject Information Access\0";
pub const NID_sinfo_access: u32 = 398;
pub const SN_id_aca_encAttrs: &[u8; 16] = b"id-aca-encAttrs\0";
pub const NID_id_aca_encAttrs: u32 = 399;
pub const SN_role: &[u8; 5] = b"role\0";
pub const LN_role: &[u8; 5] = b"role\0";
pub const NID_role: u32 = 400;
pub const SN_policy_constraints: &[u8; 18] = b"policyConstraints\0";
pub const LN_policy_constraints: &[u8; 26] = b"X509v3 Policy Constraints\0";
pub const NID_policy_constraints: u32 = 401;
pub const SN_target_information: &[u8; 18] = b"targetInformation\0";
pub const LN_target_information: &[u8; 20] = b"X509v3 AC Targeting\0";
pub const NID_target_information: u32 = 402;
pub const SN_no_rev_avail: &[u8; 11] = b"noRevAvail\0";
pub const LN_no_rev_avail: &[u8; 31] = b"X509v3 No Revocation Available\0";
pub const NID_no_rev_avail: u32 = 403;
pub const SN_ansi_X9_62: &[u8; 11] = b"ansi-X9-62\0";
pub const LN_ansi_X9_62: &[u8; 11] = b"ANSI X9.62\0";
pub const NID_ansi_X9_62: u32 = 405;
pub const SN_X9_62_prime_field: &[u8; 12] = b"prime-field\0";
pub const NID_X9_62_prime_field: u32 = 406;
pub const SN_X9_62_characteristic_two_field: &[u8; 25] = b"characteristic-two-field\0";
pub const NID_X9_62_characteristic_two_field: u32 = 407;
pub const SN_X9_62_id_ecPublicKey: &[u8; 15] = b"id-ecPublicKey\0";
pub const NID_X9_62_id_ecPublicKey: u32 = 408;
pub const SN_X9_62_prime192v1: &[u8; 11] = b"prime192v1\0";
pub const NID_X9_62_prime192v1: u32 = 409;
pub const SN_X9_62_prime192v2: &[u8; 11] = b"prime192v2\0";
pub const NID_X9_62_prime192v2: u32 = 410;
pub const SN_X9_62_prime192v3: &[u8; 11] = b"prime192v3\0";
pub const NID_X9_62_prime192v3: u32 = 411;
pub const SN_X9_62_prime239v1: &[u8; 11] = b"prime239v1\0";
pub const NID_X9_62_prime239v1: u32 = 412;
pub const SN_X9_62_prime239v2: &[u8; 11] = b"prime239v2\0";
pub const NID_X9_62_prime239v2: u32 = 413;
pub const SN_X9_62_prime239v3: &[u8; 11] = b"prime239v3\0";
pub const NID_X9_62_prime239v3: u32 = 414;
pub const SN_X9_62_prime256v1: &[u8; 11] = b"prime256v1\0";
pub const NID_X9_62_prime256v1: u32 = 415;
pub const SN_ecdsa_with_SHA1: &[u8; 16] = b"ecdsa-with-SHA1\0";
pub const NID_ecdsa_with_SHA1: u32 = 416;
pub const SN_ms_csp_name: &[u8; 8] = b"CSPName\0";
pub const LN_ms_csp_name: &[u8; 19] = b"Microsoft CSP Name\0";
pub const NID_ms_csp_name: u32 = 417;
pub const SN_aes_128_ecb: &[u8; 12] = b"AES-128-ECB\0";
pub const LN_aes_128_ecb: &[u8; 12] = b"aes-128-ecb\0";
pub const NID_aes_128_ecb: u32 = 418;
pub const SN_aes_128_cbc: &[u8; 12] = b"AES-128-CBC\0";
pub const LN_aes_128_cbc: &[u8; 12] = b"aes-128-cbc\0";
pub const NID_aes_128_cbc: u32 = 419;
pub const SN_aes_128_ofb128: &[u8; 12] = b"AES-128-OFB\0";
pub const LN_aes_128_ofb128: &[u8; 12] = b"aes-128-ofb\0";
pub const NID_aes_128_ofb128: u32 = 420;
pub const SN_aes_128_cfb128: &[u8; 12] = b"AES-128-CFB\0";
pub const LN_aes_128_cfb128: &[u8; 12] = b"aes-128-cfb\0";
pub const NID_aes_128_cfb128: u32 = 421;
pub const SN_aes_192_ecb: &[u8; 12] = b"AES-192-ECB\0";
pub const LN_aes_192_ecb: &[u8; 12] = b"aes-192-ecb\0";
pub const NID_aes_192_ecb: u32 = 422;
pub const SN_aes_192_cbc: &[u8; 12] = b"AES-192-CBC\0";
pub const LN_aes_192_cbc: &[u8; 12] = b"aes-192-cbc\0";
pub const NID_aes_192_cbc: u32 = 423;
pub const SN_aes_192_ofb128: &[u8; 12] = b"AES-192-OFB\0";
pub const LN_aes_192_ofb128: &[u8; 12] = b"aes-192-ofb\0";
pub const NID_aes_192_ofb128: u32 = 424;
pub const SN_aes_192_cfb128: &[u8; 12] = b"AES-192-CFB\0";
pub const LN_aes_192_cfb128: &[u8; 12] = b"aes-192-cfb\0";
pub const NID_aes_192_cfb128: u32 = 425;
pub const SN_aes_256_ecb: &[u8; 12] = b"AES-256-ECB\0";
pub const LN_aes_256_ecb: &[u8; 12] = b"aes-256-ecb\0";
pub const NID_aes_256_ecb: u32 = 426;
pub const SN_aes_256_cbc: &[u8; 12] = b"AES-256-CBC\0";
pub const LN_aes_256_cbc: &[u8; 12] = b"aes-256-cbc\0";
pub const NID_aes_256_cbc: u32 = 427;
pub const SN_aes_256_ofb128: &[u8; 12] = b"AES-256-OFB\0";
pub const LN_aes_256_ofb128: &[u8; 12] = b"aes-256-ofb\0";
pub const NID_aes_256_ofb128: u32 = 428;
pub const SN_aes_256_cfb128: &[u8; 12] = b"AES-256-CFB\0";
pub const LN_aes_256_cfb128: &[u8; 12] = b"aes-256-cfb\0";
pub const NID_aes_256_cfb128: u32 = 429;
pub const SN_hold_instruction_code: &[u8; 20] = b"holdInstructionCode\0";
pub const LN_hold_instruction_code: &[u8; 22] = b"Hold Instruction Code\0";
pub const NID_hold_instruction_code: u32 = 430;
pub const SN_hold_instruction_none: &[u8; 20] = b"holdInstructionNone\0";
pub const LN_hold_instruction_none: &[u8; 22] = b"Hold Instruction None\0";
pub const NID_hold_instruction_none: u32 = 431;
pub const SN_hold_instruction_call_issuer: &[u8; 26] = b"holdInstructionCallIssuer\0";
pub const LN_hold_instruction_call_issuer: &[u8; 29] = b"Hold Instruction Call Issuer\0";
pub const NID_hold_instruction_call_issuer: u32 = 432;
pub const SN_hold_instruction_reject: &[u8; 22] = b"holdInstructionReject\0";
pub const LN_hold_instruction_reject: &[u8; 24] = b"Hold Instruction Reject\0";
pub const NID_hold_instruction_reject: u32 = 433;
pub const SN_data: &[u8; 5] = b"data\0";
pub const NID_data: u32 = 434;
pub const SN_pss: &[u8; 4] = b"pss\0";
pub const NID_pss: u32 = 435;
pub const SN_ucl: &[u8; 4] = b"ucl\0";
pub const NID_ucl: u32 = 436;
pub const SN_pilot: &[u8; 6] = b"pilot\0";
pub const NID_pilot: u32 = 437;
pub const LN_pilotAttributeType: &[u8; 19] = b"pilotAttributeType\0";
pub const NID_pilotAttributeType: u32 = 438;
pub const LN_pilotAttributeSyntax: &[u8; 21] = b"pilotAttributeSyntax\0";
pub const NID_pilotAttributeSyntax: u32 = 439;
pub const LN_pilotObjectClass: &[u8; 17] = b"pilotObjectClass\0";
pub const NID_pilotObjectClass: u32 = 440;
pub const LN_pilotGroups: &[u8; 12] = b"pilotGroups\0";
pub const NID_pilotGroups: u32 = 441;
pub const LN_iA5StringSyntax: &[u8; 16] = b"iA5StringSyntax\0";
pub const NID_iA5StringSyntax: u32 = 442;
pub const LN_caseIgnoreIA5StringSyntax: &[u8; 26] = b"caseIgnoreIA5StringSyntax\0";
pub const NID_caseIgnoreIA5StringSyntax: u32 = 443;
pub const LN_pilotObject: &[u8; 12] = b"pilotObject\0";
pub const NID_pilotObject: u32 = 444;
pub const LN_pilotPerson: &[u8; 12] = b"pilotPerson\0";
pub const NID_pilotPerson: u32 = 445;
pub const SN_account: &[u8; 8] = b"account\0";
pub const NID_account: u32 = 446;
pub const SN_document: &[u8; 9] = b"document\0";
pub const NID_document: u32 = 447;
pub const SN_room: &[u8; 5] = b"room\0";
pub const NID_room: u32 = 448;
pub const LN_documentSeries: &[u8; 15] = b"documentSeries\0";
pub const NID_documentSeries: u32 = 449;
pub const LN_rFC822localPart: &[u8; 16] = b"rFC822localPart\0";
pub const NID_rFC822localPart: u32 = 450;
pub const LN_dNSDomain: &[u8; 10] = b"dNSDomain\0";
pub const NID_dNSDomain: u32 = 451;
pub const LN_domainRelatedObject: &[u8; 20] = b"domainRelatedObject\0";
pub const NID_domainRelatedObject: u32 = 452;
pub const LN_friendlyCountry: &[u8; 16] = b"friendlyCountry\0";
pub const NID_friendlyCountry: u32 = 453;
pub const LN_simpleSecurityObject: &[u8; 21] = b"simpleSecurityObject\0";
pub const NID_simpleSecurityObject: u32 = 454;
pub const LN_pilotOrganization: &[u8; 18] = b"pilotOrganization\0";
pub const NID_pilotOrganization: u32 = 455;
pub const LN_pilotDSA: &[u8; 9] = b"pilotDSA\0";
pub const NID_pilotDSA: u32 = 456;
pub const LN_qualityLabelledData: &[u8; 20] = b"qualityLabelledData\0";
pub const NID_qualityLabelledData: u32 = 457;
pub const SN_userId: &[u8; 4] = b"UID\0";
pub const LN_userId: &[u8; 7] = b"userId\0";
pub const NID_userId: u32 = 458;
pub const LN_textEncodedORAddress: &[u8; 21] = b"textEncodedORAddress\0";
pub const NID_textEncodedORAddress: u32 = 459;
pub const SN_rfc822Mailbox: &[u8; 5] = b"mail\0";
pub const LN_rfc822Mailbox: &[u8; 14] = b"rfc822Mailbox\0";
pub const NID_rfc822Mailbox: u32 = 460;
pub const SN_info: &[u8; 5] = b"info\0";
pub const NID_info: u32 = 461;
pub const LN_favouriteDrink: &[u8; 15] = b"favouriteDrink\0";
pub const NID_favouriteDrink: u32 = 462;
pub const LN_roomNumber: &[u8; 11] = b"roomNumber\0";
pub const NID_roomNumber: u32 = 463;
pub const SN_photo: &[u8; 6] = b"photo\0";
pub const NID_photo: u32 = 464;
pub const LN_userClass: &[u8; 10] = b"userClass\0";
pub const NID_userClass: u32 = 465;
pub const SN_host: &[u8; 5] = b"host\0";
pub const NID_host: u32 = 466;
pub const SN_manager: &[u8; 8] = b"manager\0";
pub const NID_manager: u32 = 467;
pub const LN_documentIdentifier: &[u8; 19] = b"documentIdentifier\0";
pub const NID_documentIdentifier: u32 = 468;
pub const LN_documentTitle: &[u8; 14] = b"documentTitle\0";
pub const NID_documentTitle: u32 = 469;
pub const LN_documentVersion: &[u8; 16] = b"documentVersion\0";
pub const NID_documentVersion: u32 = 470;
pub const LN_documentAuthor: &[u8; 15] = b"documentAuthor\0";
pub const NID_documentAuthor: u32 = 471;
pub const LN_documentLocation: &[u8; 17] = b"documentLocation\0";
pub const NID_documentLocation: u32 = 472;
pub const LN_homeTelephoneNumber: &[u8; 20] = b"homeTelephoneNumber\0";
pub const NID_homeTelephoneNumber: u32 = 473;
pub const SN_secretary: &[u8; 10] = b"secretary\0";
pub const NID_secretary: u32 = 474;
pub const LN_otherMailbox: &[u8; 13] = b"otherMailbox\0";
pub const NID_otherMailbox: u32 = 475;
pub const LN_lastModifiedTime: &[u8; 17] = b"lastModifiedTime\0";
pub const NID_lastModifiedTime: u32 = 476;
pub const LN_lastModifiedBy: &[u8; 15] = b"lastModifiedBy\0";
pub const NID_lastModifiedBy: u32 = 477;
pub const LN_aRecord: &[u8; 8] = b"aRecord\0";
pub const NID_aRecord: u32 = 478;
pub const LN_pilotAttributeType27: &[u8; 21] = b"pilotAttributeType27\0";
pub const NID_pilotAttributeType27: u32 = 479;
pub const LN_mXRecord: &[u8; 9] = b"mXRecord\0";
pub const NID_mXRecord: u32 = 480;
pub const LN_nSRecord: &[u8; 9] = b"nSRecord\0";
pub const NID_nSRecord: u32 = 481;
pub const LN_sOARecord: &[u8; 10] = b"sOARecord\0";
pub const NID_sOARecord: u32 = 482;
pub const LN_cNAMERecord: &[u8; 12] = b"cNAMERecord\0";
pub const NID_cNAMERecord: u32 = 483;
pub const LN_associatedDomain: &[u8; 17] = b"associatedDomain\0";
pub const NID_associatedDomain: u32 = 484;
pub const LN_associatedName: &[u8; 15] = b"associatedName\0";
pub const NID_associatedName: u32 = 485;
pub const LN_homePostalAddress: &[u8; 18] = b"homePostalAddress\0";
pub const NID_homePostalAddress: u32 = 486;
pub const LN_personalTitle: &[u8; 14] = b"personalTitle\0";
pub const NID_personalTitle: u32 = 487;
pub const LN_mobileTelephoneNumber: &[u8; 22] = b"mobileTelephoneNumber\0";
pub const NID_mobileTelephoneNumber: u32 = 488;
pub const LN_pagerTelephoneNumber: &[u8; 21] = b"pagerTelephoneNumber\0";
pub const NID_pagerTelephoneNumber: u32 = 489;
pub const LN_friendlyCountryName: &[u8; 20] = b"friendlyCountryName\0";
pub const NID_friendlyCountryName: u32 = 490;
pub const LN_organizationalStatus: &[u8; 21] = b"organizationalStatus\0";
pub const NID_organizationalStatus: u32 = 491;
pub const LN_janetMailbox: &[u8; 13] = b"janetMailbox\0";
pub const NID_janetMailbox: u32 = 492;
pub const LN_mailPreferenceOption: &[u8; 21] = b"mailPreferenceOption\0";
pub const NID_mailPreferenceOption: u32 = 493;
pub const LN_buildingName: &[u8; 13] = b"buildingName\0";
pub const NID_buildingName: u32 = 494;
pub const LN_dSAQuality: &[u8; 11] = b"dSAQuality\0";
pub const NID_dSAQuality: u32 = 495;
pub const LN_singleLevelQuality: &[u8; 19] = b"singleLevelQuality\0";
pub const NID_singleLevelQuality: u32 = 496;
pub const LN_subtreeMinimumQuality: &[u8; 22] = b"subtreeMinimumQuality\0";
pub const NID_subtreeMinimumQuality: u32 = 497;
pub const LN_subtreeMaximumQuality: &[u8; 22] = b"subtreeMaximumQuality\0";
pub const NID_subtreeMaximumQuality: u32 = 498;
pub const LN_personalSignature: &[u8; 18] = b"personalSignature\0";
pub const NID_personalSignature: u32 = 499;
pub const LN_dITRedirect: &[u8; 12] = b"dITRedirect\0";
pub const NID_dITRedirect: u32 = 500;
pub const SN_audio: &[u8; 6] = b"audio\0";
pub const NID_audio: u32 = 501;
pub const LN_documentPublisher: &[u8; 18] = b"documentPublisher\0";
pub const NID_documentPublisher: u32 = 502;
pub const LN_x500UniqueIdentifier: &[u8; 21] = b"x500UniqueIdentifier\0";
pub const NID_x500UniqueIdentifier: u32 = 503;
pub const SN_mime_mhs: &[u8; 9] = b"mime-mhs\0";
pub const LN_mime_mhs: &[u8; 9] = b"MIME MHS\0";
pub const NID_mime_mhs: u32 = 504;
pub const SN_mime_mhs_headings: &[u8; 18] = b"mime-mhs-headings\0";
pub const LN_mime_mhs_headings: &[u8; 18] = b"mime-mhs-headings\0";
pub const NID_mime_mhs_headings: u32 = 505;
pub const SN_mime_mhs_bodies: &[u8; 16] = b"mime-mhs-bodies\0";
pub const LN_mime_mhs_bodies: &[u8; 16] = b"mime-mhs-bodies\0";
pub const NID_mime_mhs_bodies: u32 = 506;
pub const SN_id_hex_partial_message: &[u8; 23] = b"id-hex-partial-message\0";
pub const LN_id_hex_partial_message: &[u8; 23] = b"id-hex-partial-message\0";
pub const NID_id_hex_partial_message: u32 = 507;
pub const SN_id_hex_multipart_message: &[u8; 25] = b"id-hex-multipart-message\0";
pub const LN_id_hex_multipart_message: &[u8; 25] = b"id-hex-multipart-message\0";
pub const NID_id_hex_multipart_message: u32 = 508;
pub const LN_generationQualifier: &[u8; 20] = b"generationQualifier\0";
pub const NID_generationQualifier: u32 = 509;
pub const LN_pseudonym: &[u8; 10] = b"pseudonym\0";
pub const NID_pseudonym: u32 = 510;
pub const SN_id_set: &[u8; 7] = b"id-set\0";
pub const LN_id_set: &[u8; 31] = b"Secure Electronic Transactions\0";
pub const NID_id_set: u32 = 512;
pub const SN_set_ctype: &[u8; 10] = b"set-ctype\0";
pub const LN_set_ctype: &[u8; 14] = b"content types\0";
pub const NID_set_ctype: u32 = 513;
pub const SN_set_msgExt: &[u8; 11] = b"set-msgExt\0";
pub const LN_set_msgExt: &[u8; 19] = b"message extensions\0";
pub const NID_set_msgExt: u32 = 514;
pub const SN_set_attr: &[u8; 9] = b"set-attr\0";
pub const NID_set_attr: u32 = 515;
pub const SN_set_policy: &[u8; 11] = b"set-policy\0";
pub const NID_set_policy: u32 = 516;
pub const SN_set_certExt: &[u8; 12] = b"set-certExt\0";
pub const LN_set_certExt: &[u8; 23] = b"certificate extensions\0";
pub const NID_set_certExt: u32 = 517;
pub const SN_set_brand: &[u8; 10] = b"set-brand\0";
pub const NID_set_brand: u32 = 518;
pub const SN_setct_PANData: &[u8; 14] = b"setct-PANData\0";
pub const NID_setct_PANData: u32 = 519;
pub const SN_setct_PANToken: &[u8; 15] = b"setct-PANToken\0";
pub const NID_setct_PANToken: u32 = 520;
pub const SN_setct_PANOnly: &[u8; 14] = b"setct-PANOnly\0";
pub const NID_setct_PANOnly: u32 = 521;
pub const SN_setct_OIData: &[u8; 13] = b"setct-OIData\0";
pub const NID_setct_OIData: u32 = 522;
pub const SN_setct_PI: &[u8; 9] = b"setct-PI\0";
pub const NID_setct_PI: u32 = 523;
pub const SN_setct_PIData: &[u8; 13] = b"setct-PIData\0";
pub const NID_setct_PIData: u32 = 524;
pub const SN_setct_PIDataUnsigned: &[u8; 21] = b"setct-PIDataUnsigned\0";
pub const NID_setct_PIDataUnsigned: u32 = 525;
pub const SN_setct_HODInput: &[u8; 15] = b"setct-HODInput\0";
pub const NID_setct_HODInput: u32 = 526;
pub const SN_setct_AuthResBaggage: &[u8; 21] = b"setct-AuthResBaggage\0";
pub const NID_setct_AuthResBaggage: u32 = 527;
pub const SN_setct_AuthRevReqBaggage: &[u8; 24] = b"setct-AuthRevReqBaggage\0";
pub const NID_setct_AuthRevReqBaggage: u32 = 528;
pub const SN_setct_AuthRevResBaggage: &[u8; 24] = b"setct-AuthRevResBaggage\0";
pub const NID_setct_AuthRevResBaggage: u32 = 529;
pub const SN_setct_CapTokenSeq: &[u8; 18] = b"setct-CapTokenSeq\0";
pub const NID_setct_CapTokenSeq: u32 = 530;
pub const SN_setct_PInitResData: &[u8; 19] = b"setct-PInitResData\0";
pub const NID_setct_PInitResData: u32 = 531;
pub const SN_setct_PI_TBS: &[u8; 13] = b"setct-PI-TBS\0";
pub const NID_setct_PI_TBS: u32 = 532;
pub const SN_setct_PResData: &[u8; 15] = b"setct-PResData\0";
pub const NID_setct_PResData: u32 = 533;
pub const SN_setct_AuthReqTBS: &[u8; 17] = b"setct-AuthReqTBS\0";
pub const NID_setct_AuthReqTBS: u32 = 534;
pub const SN_setct_AuthResTBS: &[u8; 17] = b"setct-AuthResTBS\0";
pub const NID_setct_AuthResTBS: u32 = 535;
pub const SN_setct_AuthResTBSX: &[u8; 18] = b"setct-AuthResTBSX\0";
pub const NID_setct_AuthResTBSX: u32 = 536;
pub const SN_setct_AuthTokenTBS: &[u8; 19] = b"setct-AuthTokenTBS\0";
pub const NID_setct_AuthTokenTBS: u32 = 537;
pub const SN_setct_CapTokenData: &[u8; 19] = b"setct-CapTokenData\0";
pub const NID_setct_CapTokenData: u32 = 538;
pub const SN_setct_CapTokenTBS: &[u8; 18] = b"setct-CapTokenTBS\0";
pub const NID_setct_CapTokenTBS: u32 = 539;
pub const SN_setct_AcqCardCodeMsg: &[u8; 21] = b"setct-AcqCardCodeMsg\0";
pub const NID_setct_AcqCardCodeMsg: u32 = 540;
pub const SN_setct_AuthRevReqTBS: &[u8; 20] = b"setct-AuthRevReqTBS\0";
pub const NID_setct_AuthRevReqTBS: u32 = 541;
pub const SN_setct_AuthRevResData: &[u8; 21] = b"setct-AuthRevResData\0";
pub const NID_setct_AuthRevResData: u32 = 542;
pub const SN_setct_AuthRevResTBS: &[u8; 20] = b"setct-AuthRevResTBS\0";
pub const NID_setct_AuthRevResTBS: u32 = 543;
pub const SN_setct_CapReqTBS: &[u8; 16] = b"setct-CapReqTBS\0";
pub const NID_setct_CapReqTBS: u32 = 544;
pub const SN_setct_CapReqTBSX: &[u8; 17] = b"setct-CapReqTBSX\0";
pub const NID_setct_CapReqTBSX: u32 = 545;
pub const SN_setct_CapResData: &[u8; 17] = b"setct-CapResData\0";
pub const NID_setct_CapResData: u32 = 546;
pub const SN_setct_CapRevReqTBS: &[u8; 19] = b"setct-CapRevReqTBS\0";
pub const NID_setct_CapRevReqTBS: u32 = 547;
pub const SN_setct_CapRevReqTBSX: &[u8; 20] = b"setct-CapRevReqTBSX\0";
pub const NID_setct_CapRevReqTBSX: u32 = 548;
pub const SN_setct_CapRevResData: &[u8; 20] = b"setct-CapRevResData\0";
pub const NID_setct_CapRevResData: u32 = 549;
pub const SN_setct_CredReqTBS: &[u8; 17] = b"setct-CredReqTBS\0";
pub const NID_setct_CredReqTBS: u32 = 550;
pub const SN_setct_CredReqTBSX: &[u8; 18] = b"setct-CredReqTBSX\0";
pub const NID_setct_CredReqTBSX: u32 = 551;
pub const SN_setct_CredResData: &[u8; 18] = b"setct-CredResData\0";
pub const NID_setct_CredResData: u32 = 552;
pub const SN_setct_CredRevReqTBS: &[u8; 20] = b"setct-CredRevReqTBS\0";
pub const NID_setct_CredRevReqTBS: u32 = 553;
pub const SN_setct_CredRevReqTBSX: &[u8; 21] = b"setct-CredRevReqTBSX\0";
pub const NID_setct_CredRevReqTBSX: u32 = 554;
pub const SN_setct_CredRevResData: &[u8; 21] = b"setct-CredRevResData\0";
pub const NID_setct_CredRevResData: u32 = 555;
pub const SN_setct_PCertReqData: &[u8; 19] = b"setct-PCertReqData\0";
pub const NID_setct_PCertReqData: u32 = 556;
pub const SN_setct_PCertResTBS: &[u8; 18] = b"setct-PCertResTBS\0";
pub const NID_setct_PCertResTBS: u32 = 557;
pub const SN_setct_BatchAdminReqData: &[u8; 24] = b"setct-BatchAdminReqData\0";
pub const NID_setct_BatchAdminReqData: u32 = 558;
pub const SN_setct_BatchAdminResData: &[u8; 24] = b"setct-BatchAdminResData\0";
pub const NID_setct_BatchAdminResData: u32 = 559;
pub const SN_setct_CardCInitResTBS: &[u8; 22] = b"setct-CardCInitResTBS\0";
pub const NID_setct_CardCInitResTBS: u32 = 560;
pub const SN_setct_MeAqCInitResTBS: &[u8; 22] = b"setct-MeAqCInitResTBS\0";
pub const NID_setct_MeAqCInitResTBS: u32 = 561;
pub const SN_setct_RegFormResTBS: &[u8; 20] = b"setct-RegFormResTBS\0";
pub const NID_setct_RegFormResTBS: u32 = 562;
pub const SN_setct_CertReqData: &[u8; 18] = b"setct-CertReqData\0";
pub const NID_setct_CertReqData: u32 = 563;
pub const SN_setct_CertReqTBS: &[u8; 17] = b"setct-CertReqTBS\0";
pub const NID_setct_CertReqTBS: u32 = 564;
pub const SN_setct_CertResData: &[u8; 18] = b"setct-CertResData\0";
pub const NID_setct_CertResData: u32 = 565;
pub const SN_setct_CertInqReqTBS: &[u8; 20] = b"setct-CertInqReqTBS\0";
pub const NID_setct_CertInqReqTBS: u32 = 566;
pub const SN_setct_ErrorTBS: &[u8; 15] = b"setct-ErrorTBS\0";
pub const NID_setct_ErrorTBS: u32 = 567;
pub const SN_setct_PIDualSignedTBE: &[u8; 22] = b"setct-PIDualSignedTBE\0";
pub const NID_setct_PIDualSignedTBE: u32 = 568;
pub const SN_setct_PIUnsignedTBE: &[u8; 20] = b"setct-PIUnsignedTBE\0";
pub const NID_setct_PIUnsignedTBE: u32 = 569;
pub const SN_setct_AuthReqTBE: &[u8; 17] = b"setct-AuthReqTBE\0";
pub const NID_setct_AuthReqTBE: u32 = 570;
pub const SN_setct_AuthResTBE: &[u8; 17] = b"setct-AuthResTBE\0";
pub const NID_setct_AuthResTBE: u32 = 571;
pub const SN_setct_AuthResTBEX: &[u8; 18] = b"setct-AuthResTBEX\0";
pub const NID_setct_AuthResTBEX: u32 = 572;
pub const SN_setct_AuthTokenTBE: &[u8; 19] = b"setct-AuthTokenTBE\0";
pub const NID_setct_AuthTokenTBE: u32 = 573;
pub const SN_setct_CapTokenTBE: &[u8; 18] = b"setct-CapTokenTBE\0";
pub const NID_setct_CapTokenTBE: u32 = 574;
pub const SN_setct_CapTokenTBEX: &[u8; 19] = b"setct-CapTokenTBEX\0";
pub const NID_setct_CapTokenTBEX: u32 = 575;
pub const SN_setct_AcqCardCodeMsgTBE: &[u8; 24] = b"setct-AcqCardCodeMsgTBE\0";
pub const NID_setct_AcqCardCodeMsgTBE: u32 = 576;
pub const SN_setct_AuthRevReqTBE: &[u8; 20] = b"setct-AuthRevReqTBE\0";
pub const NID_setct_AuthRevReqTBE: u32 = 577;
pub const SN_setct_AuthRevResTBE: &[u8; 20] = b"setct-AuthRevResTBE\0";
pub const NID_setct_AuthRevResTBE: u32 = 578;
pub const SN_setct_AuthRevResTBEB: &[u8; 21] = b"setct-AuthRevResTBEB\0";
pub const NID_setct_AuthRevResTBEB: u32 = 579;
pub const SN_setct_CapReqTBE: &[u8; 16] = b"setct-CapReqTBE\0";
pub const NID_setct_CapReqTBE: u32 = 580;
pub const SN_setct_CapReqTBEX: &[u8; 17] = b"setct-CapReqTBEX\0";
pub const NID_setct_CapReqTBEX: u32 = 581;
pub const SN_setct_CapResTBE: &[u8; 16] = b"setct-CapResTBE\0";
pub const NID_setct_CapResTBE: u32 = 582;
pub const SN_setct_CapRevReqTBE: &[u8; 19] = b"setct-CapRevReqTBE\0";
pub const NID_setct_CapRevReqTBE: u32 = 583;
pub const SN_setct_CapRevReqTBEX: &[u8; 20] = b"setct-CapRevReqTBEX\0";
pub const NID_setct_CapRevReqTBEX: u32 = 584;
pub const SN_setct_CapRevResTBE: &[u8; 19] = b"setct-CapRevResTBE\0";
pub const NID_setct_CapRevResTBE: u32 = 585;
pub const SN_setct_CredReqTBE: &[u8; 17] = b"setct-CredReqTBE\0";
pub const NID_setct_CredReqTBE: u32 = 586;
pub const SN_setct_CredReqTBEX: &[u8; 18] = b"setct-CredReqTBEX\0";
pub const NID_setct_CredReqTBEX: u32 = 587;
pub const SN_setct_CredResTBE: &[u8; 17] = b"setct-CredResTBE\0";
pub const NID_setct_CredResTBE: u32 = 588;
pub const SN_setct_CredRevReqTBE: &[u8; 20] = b"setct-CredRevReqTBE\0";
pub const NID_setct_CredRevReqTBE: u32 = 589;
pub const SN_setct_CredRevReqTBEX: &[u8; 21] = b"setct-CredRevReqTBEX\0";
pub const NID_setct_CredRevReqTBEX: u32 = 590;
pub const SN_setct_CredRevResTBE: &[u8; 20] = b"setct-CredRevResTBE\0";
pub const NID_setct_CredRevResTBE: u32 = 591;
pub const SN_setct_BatchAdminReqTBE: &[u8; 23] = b"setct-BatchAdminReqTBE\0";
pub const NID_setct_BatchAdminReqTBE: u32 = 592;
pub const SN_setct_BatchAdminResTBE: &[u8; 23] = b"setct-BatchAdminResTBE\0";
pub const NID_setct_BatchAdminResTBE: u32 = 593;
pub const SN_setct_RegFormReqTBE: &[u8; 20] = b"setct-RegFormReqTBE\0";
pub const NID_setct_RegFormReqTBE: u32 = 594;
pub const SN_setct_CertReqTBE: &[u8; 17] = b"setct-CertReqTBE\0";
pub const NID_setct_CertReqTBE: u32 = 595;
pub const SN_setct_CertReqTBEX: &[u8; 18] = b"setct-CertReqTBEX\0";
pub const NID_setct_CertReqTBEX: u32 = 596;
pub const SN_setct_CertResTBE: &[u8; 17] = b"setct-CertResTBE\0";
pub const NID_setct_CertResTBE: u32 = 597;
pub const SN_setct_CRLNotificationTBS: &[u8; 25] = b"setct-CRLNotificationTBS\0";
pub const NID_setct_CRLNotificationTBS: u32 = 598;
pub const SN_setct_CRLNotificationResTBS: &[u8; 28] = b"setct-CRLNotificationResTBS\0";
pub const NID_setct_CRLNotificationResTBS: u32 = 599;
pub const SN_setct_BCIDistributionTBS: &[u8; 25] = b"setct-BCIDistributionTBS\0";
pub const NID_setct_BCIDistributionTBS: u32 = 600;
pub const SN_setext_genCrypt: &[u8; 16] = b"setext-genCrypt\0";
pub const LN_setext_genCrypt: &[u8; 19] = b"generic cryptogram\0";
pub const NID_setext_genCrypt: u32 = 601;
pub const SN_setext_miAuth: &[u8; 14] = b"setext-miAuth\0";
pub const LN_setext_miAuth: &[u8; 24] = b"merchant initiated auth\0";
pub const NID_setext_miAuth: u32 = 602;
pub const SN_setext_pinSecure: &[u8; 17] = b"setext-pinSecure\0";
pub const NID_setext_pinSecure: u32 = 603;
pub const SN_setext_pinAny: &[u8; 14] = b"setext-pinAny\0";
pub const NID_setext_pinAny: u32 = 604;
pub const SN_setext_track2: &[u8; 14] = b"setext-track2\0";
pub const NID_setext_track2: u32 = 605;
pub const SN_setext_cv: &[u8; 10] = b"setext-cv\0";
pub const LN_setext_cv: &[u8; 24] = b"additional verification\0";
pub const NID_setext_cv: u32 = 606;
pub const SN_set_policy_root: &[u8; 16] = b"set-policy-root\0";
pub const NID_set_policy_root: u32 = 607;
pub const SN_setCext_hashedRoot: &[u8; 19] = b"setCext-hashedRoot\0";
pub const NID_setCext_hashedRoot: u32 = 608;
pub const SN_setCext_certType: &[u8; 17] = b"setCext-certType\0";
pub const NID_setCext_certType: u32 = 609;
pub const SN_setCext_merchData: &[u8; 18] = b"setCext-merchData\0";
pub const NID_setCext_merchData: u32 = 610;
pub const SN_setCext_cCertRequired: &[u8; 22] = b"setCext-cCertRequired\0";
pub const NID_setCext_cCertRequired: u32 = 611;
pub const SN_setCext_tunneling: &[u8; 18] = b"setCext-tunneling\0";
pub const NID_setCext_tunneling: u32 = 612;
pub const SN_setCext_setExt: &[u8; 15] = b"setCext-setExt\0";
pub const NID_setCext_setExt: u32 = 613;
pub const SN_setCext_setQualf: &[u8; 17] = b"setCext-setQualf\0";
pub const NID_setCext_setQualf: u32 = 614;
pub const SN_setCext_PGWYcapabilities: &[u8; 25] = b"setCext-PGWYcapabilities\0";
pub const NID_setCext_PGWYcapabilities: u32 = 615;
pub const SN_setCext_TokenIdentifier: &[u8; 24] = b"setCext-TokenIdentifier\0";
pub const NID_setCext_TokenIdentifier: u32 = 616;
pub const SN_setCext_Track2Data: &[u8; 19] = b"setCext-Track2Data\0";
pub const NID_setCext_Track2Data: u32 = 617;
pub const SN_setCext_TokenType: &[u8; 18] = b"setCext-TokenType\0";
pub const NID_setCext_TokenType: u32 = 618;
pub const SN_setCext_IssuerCapabilities: &[u8; 27] = b"setCext-IssuerCapabilities\0";
pub const NID_setCext_IssuerCapabilities: u32 = 619;
pub const SN_setAttr_Cert: &[u8; 13] = b"setAttr-Cert\0";
pub const NID_setAttr_Cert: u32 = 620;
pub const SN_setAttr_PGWYcap: &[u8; 16] = b"setAttr-PGWYcap\0";
pub const LN_setAttr_PGWYcap: &[u8; 29] = b"payment gateway capabilities\0";
pub const NID_setAttr_PGWYcap: u32 = 621;
pub const SN_setAttr_TokenType: &[u8; 18] = b"setAttr-TokenType\0";
pub const NID_setAttr_TokenType: u32 = 622;
pub const SN_setAttr_IssCap: &[u8; 15] = b"setAttr-IssCap\0";
pub const LN_setAttr_IssCap: &[u8; 20] = b"issuer capabilities\0";
pub const NID_setAttr_IssCap: u32 = 623;
pub const SN_set_rootKeyThumb: &[u8; 17] = b"set-rootKeyThumb\0";
pub const NID_set_rootKeyThumb: u32 = 624;
pub const SN_set_addPolicy: &[u8; 14] = b"set-addPolicy\0";
pub const NID_set_addPolicy: u32 = 625;
pub const SN_setAttr_Token_EMV: &[u8; 18] = b"setAttr-Token-EMV\0";
pub const NID_setAttr_Token_EMV: u32 = 626;
pub const SN_setAttr_Token_B0Prime: &[u8; 22] = b"setAttr-Token-B0Prime\0";
pub const NID_setAttr_Token_B0Prime: u32 = 627;
pub const SN_setAttr_IssCap_CVM: &[u8; 19] = b"setAttr-IssCap-CVM\0";
pub const NID_setAttr_IssCap_CVM: u32 = 628;
pub const SN_setAttr_IssCap_T2: &[u8; 18] = b"setAttr-IssCap-T2\0";
pub const NID_setAttr_IssCap_T2: u32 = 629;
pub const SN_setAttr_IssCap_Sig: &[u8; 19] = b"setAttr-IssCap-Sig\0";
pub const NID_setAttr_IssCap_Sig: u32 = 630;
pub const SN_setAttr_GenCryptgrm: &[u8; 20] = b"setAttr-GenCryptgrm\0";
pub const LN_setAttr_GenCryptgrm: &[u8; 20] = b"generate cryptogram\0";
pub const NID_setAttr_GenCryptgrm: u32 = 631;
pub const SN_setAttr_T2Enc: &[u8; 14] = b"setAttr-T2Enc\0";
pub const LN_setAttr_T2Enc: &[u8; 18] = b"encrypted track 2\0";
pub const NID_setAttr_T2Enc: u32 = 632;
pub const SN_setAttr_T2cleartxt: &[u8; 19] = b"setAttr-T2cleartxt\0";
pub const LN_setAttr_T2cleartxt: &[u8; 18] = b"cleartext track 2\0";
pub const NID_setAttr_T2cleartxt: u32 = 633;
pub const SN_setAttr_TokICCsig: &[u8; 18] = b"setAttr-TokICCsig\0";
pub const LN_setAttr_TokICCsig: &[u8; 23] = b"ICC or token signature\0";
pub const NID_setAttr_TokICCsig: u32 = 634;
pub const SN_setAttr_SecDevSig: &[u8; 18] = b"setAttr-SecDevSig\0";
pub const LN_setAttr_SecDevSig: &[u8; 24] = b"secure device signature\0";
pub const NID_setAttr_SecDevSig: u32 = 635;
pub const SN_set_brand_IATA_ATA: &[u8; 19] = b"set-brand-IATA-ATA\0";
pub const NID_set_brand_IATA_ATA: u32 = 636;
pub const SN_set_brand_Diners: &[u8; 17] = b"set-brand-Diners\0";
pub const NID_set_brand_Diners: u32 = 637;
pub const SN_set_brand_AmericanExpress: &[u8; 26] = b"set-brand-AmericanExpress\0";
pub const NID_set_brand_AmericanExpress: u32 = 638;
pub const SN_set_brand_JCB: &[u8; 14] = b"set-brand-JCB\0";
pub const NID_set_brand_JCB: u32 = 639;
pub const SN_set_brand_Visa: &[u8; 15] = b"set-brand-Visa\0";
pub const NID_set_brand_Visa: u32 = 640;
pub const SN_set_brand_MasterCard: &[u8; 21] = b"set-brand-MasterCard\0";
pub const NID_set_brand_MasterCard: u32 = 641;
pub const SN_set_brand_Novus: &[u8; 16] = b"set-brand-Novus\0";
pub const NID_set_brand_Novus: u32 = 642;
pub const SN_des_cdmf: &[u8; 9] = b"DES-CDMF\0";
pub const LN_des_cdmf: &[u8; 9] = b"des-cdmf\0";
pub const NID_des_cdmf: u32 = 643;
pub const SN_rsaOAEPEncryptionSET: &[u8; 21] = b"rsaOAEPEncryptionSET\0";
pub const NID_rsaOAEPEncryptionSET: u32 = 644;
pub const SN_itu_t: &[u8; 6] = b"ITU-T\0";
pub const LN_itu_t: &[u8; 6] = b"itu-t\0";
pub const NID_itu_t: u32 = 645;
pub const OBJ_itu_t: u32 = 0;
pub const SN_joint_iso_itu_t: &[u8; 16] = b"JOINT-ISO-ITU-T\0";
pub const LN_joint_iso_itu_t: &[u8; 16] = b"joint-iso-itu-t\0";
pub const NID_joint_iso_itu_t: u32 = 646;
pub const OBJ_joint_iso_itu_t: u32 = 2;
pub const SN_international_organizations: &[u8; 28] = b"international-organizations\0";
pub const LN_international_organizations: &[u8; 28] = b"International Organizations\0";
pub const NID_international_organizations: u32 = 647;
pub const SN_ms_smartcard_login: &[u8; 17] = b"msSmartcardLogin\0";
pub const LN_ms_smartcard_login: &[u8; 25] = b"Microsoft Smartcardlogin\0";
pub const NID_ms_smartcard_login: u32 = 648;
pub const SN_ms_upn: &[u8; 6] = b"msUPN\0";
pub const LN_ms_upn: &[u8; 35] = b"Microsoft Universal Principal Name\0";
pub const NID_ms_upn: u32 = 649;
pub const SN_aes_128_cfb1: &[u8; 13] = b"AES-128-CFB1\0";
pub const LN_aes_128_cfb1: &[u8; 13] = b"aes-128-cfb1\0";
pub const NID_aes_128_cfb1: u32 = 650;
pub const SN_aes_192_cfb1: &[u8; 13] = b"AES-192-CFB1\0";
pub const LN_aes_192_cfb1: &[u8; 13] = b"aes-192-cfb1\0";
pub const NID_aes_192_cfb1: u32 = 651;
pub const SN_aes_256_cfb1: &[u8; 13] = b"AES-256-CFB1\0";
pub const LN_aes_256_cfb1: &[u8; 13] = b"aes-256-cfb1\0";
pub const NID_aes_256_cfb1: u32 = 652;
pub const SN_aes_128_cfb8: &[u8; 13] = b"AES-128-CFB8\0";
pub const LN_aes_128_cfb8: &[u8; 13] = b"aes-128-cfb8\0";
pub const NID_aes_128_cfb8: u32 = 653;
pub const SN_aes_192_cfb8: &[u8; 13] = b"AES-192-CFB8\0";
pub const LN_aes_192_cfb8: &[u8; 13] = b"aes-192-cfb8\0";
pub const NID_aes_192_cfb8: u32 = 654;
pub const SN_aes_256_cfb8: &[u8; 13] = b"AES-256-CFB8\0";
pub const LN_aes_256_cfb8: &[u8; 13] = b"aes-256-cfb8\0";
pub const NID_aes_256_cfb8: u32 = 655;
pub const SN_des_cfb1: &[u8; 9] = b"DES-CFB1\0";
pub const LN_des_cfb1: &[u8; 9] = b"des-cfb1\0";
pub const NID_des_cfb1: u32 = 656;
pub const SN_des_cfb8: &[u8; 9] = b"DES-CFB8\0";
pub const LN_des_cfb8: &[u8; 9] = b"des-cfb8\0";
pub const NID_des_cfb8: u32 = 657;
pub const SN_des_ede3_cfb1: &[u8; 14] = b"DES-EDE3-CFB1\0";
pub const LN_des_ede3_cfb1: &[u8; 14] = b"des-ede3-cfb1\0";
pub const NID_des_ede3_cfb1: u32 = 658;
pub const SN_des_ede3_cfb8: &[u8; 14] = b"DES-EDE3-CFB8\0";
pub const LN_des_ede3_cfb8: &[u8; 14] = b"des-ede3-cfb8\0";
pub const NID_des_ede3_cfb8: u32 = 659;
pub const SN_streetAddress: &[u8; 7] = b"street\0";
pub const LN_streetAddress: &[u8; 14] = b"streetAddress\0";
pub const NID_streetAddress: u32 = 660;
pub const LN_postalCode: &[u8; 11] = b"postalCode\0";
pub const NID_postalCode: u32 = 661;
pub const SN_id_ppl: &[u8; 7] = b"id-ppl\0";
pub const NID_id_ppl: u32 = 662;
pub const SN_proxyCertInfo: &[u8; 14] = b"proxyCertInfo\0";
pub const LN_proxyCertInfo: &[u8; 30] = b"Proxy Certificate Information\0";
pub const NID_proxyCertInfo: u32 = 663;
pub const SN_id_ppl_anyLanguage: &[u8; 19] = b"id-ppl-anyLanguage\0";
pub const LN_id_ppl_anyLanguage: &[u8; 13] = b"Any language\0";
pub const NID_id_ppl_anyLanguage: u32 = 664;
pub const SN_id_ppl_inheritAll: &[u8; 18] = b"id-ppl-inheritAll\0";
pub const LN_id_ppl_inheritAll: &[u8; 12] = b"Inherit all\0";
pub const NID_id_ppl_inheritAll: u32 = 665;
pub const SN_name_constraints: &[u8; 16] = b"nameConstraints\0";
pub const LN_name_constraints: &[u8; 24] = b"X509v3 Name Constraints\0";
pub const NID_name_constraints: u32 = 666;
pub const SN_Independent: &[u8; 19] = b"id-ppl-independent\0";
pub const LN_Independent: &[u8; 12] = b"Independent\0";
pub const NID_Independent: u32 = 667;
pub const SN_sha256WithRSAEncryption: &[u8; 11] = b"RSA-SHA256\0";
pub const LN_sha256WithRSAEncryption: &[u8; 24] = b"sha256WithRSAEncryption\0";
pub const NID_sha256WithRSAEncryption: u32 = 668;
pub const SN_sha384WithRSAEncryption: &[u8; 11] = b"RSA-SHA384\0";
pub const LN_sha384WithRSAEncryption: &[u8; 24] = b"sha384WithRSAEncryption\0";
pub const NID_sha384WithRSAEncryption: u32 = 669;
pub const SN_sha512WithRSAEncryption: &[u8; 11] = b"RSA-SHA512\0";
pub const LN_sha512WithRSAEncryption: &[u8; 24] = b"sha512WithRSAEncryption\0";
pub const NID_sha512WithRSAEncryption: u32 = 670;
pub const SN_sha224WithRSAEncryption: &[u8; 11] = b"RSA-SHA224\0";
pub const LN_sha224WithRSAEncryption: &[u8; 24] = b"sha224WithRSAEncryption\0";
pub const NID_sha224WithRSAEncryption: u32 = 671;
pub const SN_sha256: &[u8; 7] = b"SHA256\0";
pub const LN_sha256: &[u8; 7] = b"sha256\0";
pub const NID_sha256: u32 = 672;
pub const SN_sha384: &[u8; 7] = b"SHA384\0";
pub const LN_sha384: &[u8; 7] = b"sha384\0";
pub const NID_sha384: u32 = 673;
pub const SN_sha512: &[u8; 7] = b"SHA512\0";
pub const LN_sha512: &[u8; 7] = b"sha512\0";
pub const NID_sha512: u32 = 674;
pub const SN_sha224: &[u8; 7] = b"SHA224\0";
pub const LN_sha224: &[u8; 7] = b"sha224\0";
pub const NID_sha224: u32 = 675;
pub const SN_identified_organization: &[u8; 24] = b"identified-organization\0";
pub const NID_identified_organization: u32 = 676;
pub const SN_certicom_arc: &[u8; 13] = b"certicom-arc\0";
pub const NID_certicom_arc: u32 = 677;
pub const SN_wap: &[u8; 4] = b"wap\0";
pub const NID_wap: u32 = 678;
pub const SN_wap_wsg: &[u8; 8] = b"wap-wsg\0";
pub const NID_wap_wsg: u32 = 679;
pub const SN_X9_62_id_characteristic_two_basis: &[u8; 28] = b"id-characteristic-two-basis\0";
pub const NID_X9_62_id_characteristic_two_basis: u32 = 680;
pub const SN_X9_62_onBasis: &[u8; 8] = b"onBasis\0";
pub const NID_X9_62_onBasis: u32 = 681;
pub const SN_X9_62_tpBasis: &[u8; 8] = b"tpBasis\0";
pub const NID_X9_62_tpBasis: u32 = 682;
pub const SN_X9_62_ppBasis: &[u8; 8] = b"ppBasis\0";
pub const NID_X9_62_ppBasis: u32 = 683;
pub const SN_X9_62_c2pnb163v1: &[u8; 11] = b"c2pnb163v1\0";
pub const NID_X9_62_c2pnb163v1: u32 = 684;
pub const SN_X9_62_c2pnb163v2: &[u8; 11] = b"c2pnb163v2\0";
pub const NID_X9_62_c2pnb163v2: u32 = 685;
pub const SN_X9_62_c2pnb163v3: &[u8; 11] = b"c2pnb163v3\0";
pub const NID_X9_62_c2pnb163v3: u32 = 686;
pub const SN_X9_62_c2pnb176v1: &[u8; 11] = b"c2pnb176v1\0";
pub const NID_X9_62_c2pnb176v1: u32 = 687;
pub const SN_X9_62_c2tnb191v1: &[u8; 11] = b"c2tnb191v1\0";
pub const NID_X9_62_c2tnb191v1: u32 = 688;
pub const SN_X9_62_c2tnb191v2: &[u8; 11] = b"c2tnb191v2\0";
pub const NID_X9_62_c2tnb191v2: u32 = 689;
pub const SN_X9_62_c2tnb191v3: &[u8; 11] = b"c2tnb191v3\0";
pub const NID_X9_62_c2tnb191v3: u32 = 690;
pub const SN_X9_62_c2onb191v4: &[u8; 11] = b"c2onb191v4\0";
pub const NID_X9_62_c2onb191v4: u32 = 691;
pub const SN_X9_62_c2onb191v5: &[u8; 11] = b"c2onb191v5\0";
pub const NID_X9_62_c2onb191v5: u32 = 692;
pub const SN_X9_62_c2pnb208w1: &[u8; 11] = b"c2pnb208w1\0";
pub const NID_X9_62_c2pnb208w1: u32 = 693;
pub const SN_X9_62_c2tnb239v1: &[u8; 11] = b"c2tnb239v1\0";
pub const NID_X9_62_c2tnb239v1: u32 = 694;
pub const SN_X9_62_c2tnb239v2: &[u8; 11] = b"c2tnb239v2\0";
pub const NID_X9_62_c2tnb239v2: u32 = 695;
pub const SN_X9_62_c2tnb239v3: &[u8; 11] = b"c2tnb239v3\0";
pub const NID_X9_62_c2tnb239v3: u32 = 696;
pub const SN_X9_62_c2onb239v4: &[u8; 11] = b"c2onb239v4\0";
pub const NID_X9_62_c2onb239v4: u32 = 697;
pub const SN_X9_62_c2onb239v5: &[u8; 11] = b"c2onb239v5\0";
pub const NID_X9_62_c2onb239v5: u32 = 698;
pub const SN_X9_62_c2pnb272w1: &[u8; 11] = b"c2pnb272w1\0";
pub const NID_X9_62_c2pnb272w1: u32 = 699;
pub const SN_X9_62_c2pnb304w1: &[u8; 11] = b"c2pnb304w1\0";
pub const NID_X9_62_c2pnb304w1: u32 = 700;
pub const SN_X9_62_c2tnb359v1: &[u8; 11] = b"c2tnb359v1\0";
pub const NID_X9_62_c2tnb359v1: u32 = 701;
pub const SN_X9_62_c2pnb368w1: &[u8; 11] = b"c2pnb368w1\0";
pub const NID_X9_62_c2pnb368w1: u32 = 702;
pub const SN_X9_62_c2tnb431r1: &[u8; 11] = b"c2tnb431r1\0";
pub const NID_X9_62_c2tnb431r1: u32 = 703;
pub const SN_secp112r1: &[u8; 10] = b"secp112r1\0";
pub const NID_secp112r1: u32 = 704;
pub const SN_secp112r2: &[u8; 10] = b"secp112r2\0";
pub const NID_secp112r2: u32 = 705;
pub const SN_secp128r1: &[u8; 10] = b"secp128r1\0";
pub const NID_secp128r1: u32 = 706;
pub const SN_secp128r2: &[u8; 10] = b"secp128r2\0";
pub const NID_secp128r2: u32 = 707;
pub const SN_secp160k1: &[u8; 10] = b"secp160k1\0";
pub const NID_secp160k1: u32 = 708;
pub const SN_secp160r1: &[u8; 10] = b"secp160r1\0";
pub const NID_secp160r1: u32 = 709;
pub const SN_secp160r2: &[u8; 10] = b"secp160r2\0";
pub const NID_secp160r2: u32 = 710;
pub const SN_secp192k1: &[u8; 10] = b"secp192k1\0";
pub const NID_secp192k1: u32 = 711;
pub const SN_secp224k1: &[u8; 10] = b"secp224k1\0";
pub const NID_secp224k1: u32 = 712;
pub const SN_secp224r1: &[u8; 10] = b"secp224r1\0";
pub const NID_secp224r1: u32 = 713;
pub const SN_secp256k1: &[u8; 10] = b"secp256k1\0";
pub const NID_secp256k1: u32 = 714;
pub const SN_secp384r1: &[u8; 10] = b"secp384r1\0";
pub const NID_secp384r1: u32 = 715;
pub const SN_secp521r1: &[u8; 10] = b"secp521r1\0";
pub const NID_secp521r1: u32 = 716;
pub const SN_sect113r1: &[u8; 10] = b"sect113r1\0";
pub const NID_sect113r1: u32 = 717;
pub const SN_sect113r2: &[u8; 10] = b"sect113r2\0";
pub const NID_sect113r2: u32 = 718;
pub const SN_sect131r1: &[u8; 10] = b"sect131r1\0";
pub const NID_sect131r1: u32 = 719;
pub const SN_sect131r2: &[u8; 10] = b"sect131r2\0";
pub const NID_sect131r2: u32 = 720;
pub const SN_sect163k1: &[u8; 10] = b"sect163k1\0";
pub const NID_sect163k1: u32 = 721;
pub const SN_sect163r1: &[u8; 10] = b"sect163r1\0";
pub const NID_sect163r1: u32 = 722;
pub const SN_sect163r2: &[u8; 10] = b"sect163r2\0";
pub const NID_sect163r2: u32 = 723;
pub const SN_sect193r1: &[u8; 10] = b"sect193r1\0";
pub const NID_sect193r1: u32 = 724;
pub const SN_sect193r2: &[u8; 10] = b"sect193r2\0";
pub const NID_sect193r2: u32 = 725;
pub const SN_sect233k1: &[u8; 10] = b"sect233k1\0";
pub const NID_sect233k1: u32 = 726;
pub const SN_sect233r1: &[u8; 10] = b"sect233r1\0";
pub const NID_sect233r1: u32 = 727;
pub const SN_sect239k1: &[u8; 10] = b"sect239k1\0";
pub const NID_sect239k1: u32 = 728;
pub const SN_sect283k1: &[u8; 10] = b"sect283k1\0";
pub const NID_sect283k1: u32 = 729;
pub const SN_sect283r1: &[u8; 10] = b"sect283r1\0";
pub const NID_sect283r1: u32 = 730;
pub const SN_sect409k1: &[u8; 10] = b"sect409k1\0";
pub const NID_sect409k1: u32 = 731;
pub const SN_sect409r1: &[u8; 10] = b"sect409r1\0";
pub const NID_sect409r1: u32 = 732;
pub const SN_sect571k1: &[u8; 10] = b"sect571k1\0";
pub const NID_sect571k1: u32 = 733;
pub const SN_sect571r1: &[u8; 10] = b"sect571r1\0";
pub const NID_sect571r1: u32 = 734;
pub const SN_wap_wsg_idm_ecid_wtls1: &[u8; 23] = b"wap-wsg-idm-ecid-wtls1\0";
pub const NID_wap_wsg_idm_ecid_wtls1: u32 = 735;
pub const SN_wap_wsg_idm_ecid_wtls3: &[u8; 23] = b"wap-wsg-idm-ecid-wtls3\0";
pub const NID_wap_wsg_idm_ecid_wtls3: u32 = 736;
pub const SN_wap_wsg_idm_ecid_wtls4: &[u8; 23] = b"wap-wsg-idm-ecid-wtls4\0";
pub const NID_wap_wsg_idm_ecid_wtls4: u32 = 737;
pub const SN_wap_wsg_idm_ecid_wtls5: &[u8; 23] = b"wap-wsg-idm-ecid-wtls5\0";
pub const NID_wap_wsg_idm_ecid_wtls5: u32 = 738;
pub const SN_wap_wsg_idm_ecid_wtls6: &[u8; 23] = b"wap-wsg-idm-ecid-wtls6\0";
pub const NID_wap_wsg_idm_ecid_wtls6: u32 = 739;
pub const SN_wap_wsg_idm_ecid_wtls7: &[u8; 23] = b"wap-wsg-idm-ecid-wtls7\0";
pub const NID_wap_wsg_idm_ecid_wtls7: u32 = 740;
pub const SN_wap_wsg_idm_ecid_wtls8: &[u8; 23] = b"wap-wsg-idm-ecid-wtls8\0";
pub const NID_wap_wsg_idm_ecid_wtls8: u32 = 741;
pub const SN_wap_wsg_idm_ecid_wtls9: &[u8; 23] = b"wap-wsg-idm-ecid-wtls9\0";
pub const NID_wap_wsg_idm_ecid_wtls9: u32 = 742;
pub const SN_wap_wsg_idm_ecid_wtls10: &[u8; 24] = b"wap-wsg-idm-ecid-wtls10\0";
pub const NID_wap_wsg_idm_ecid_wtls10: u32 = 743;
pub const SN_wap_wsg_idm_ecid_wtls11: &[u8; 24] = b"wap-wsg-idm-ecid-wtls11\0";
pub const NID_wap_wsg_idm_ecid_wtls11: u32 = 744;
pub const SN_wap_wsg_idm_ecid_wtls12: &[u8; 24] = b"wap-wsg-idm-ecid-wtls12\0";
pub const NID_wap_wsg_idm_ecid_wtls12: u32 = 745;
pub const SN_any_policy: &[u8; 10] = b"anyPolicy\0";
pub const LN_any_policy: &[u8; 18] = b"X509v3 Any Policy\0";
pub const NID_any_policy: u32 = 746;
pub const SN_policy_mappings: &[u8; 15] = b"policyMappings\0";
pub const LN_policy_mappings: &[u8; 23] = b"X509v3 Policy Mappings\0";
pub const NID_policy_mappings: u32 = 747;
pub const SN_inhibit_any_policy: &[u8; 17] = b"inhibitAnyPolicy\0";
pub const LN_inhibit_any_policy: &[u8; 26] = b"X509v3 Inhibit Any Policy\0";
pub const NID_inhibit_any_policy: u32 = 748;
pub const SN_ipsec3: &[u8; 14] = b"Oakley-EC2N-3\0";
pub const LN_ipsec3: &[u8; 7] = b"ipsec3\0";
pub const NID_ipsec3: u32 = 749;
pub const SN_ipsec4: &[u8; 14] = b"Oakley-EC2N-4\0";
pub const LN_ipsec4: &[u8; 7] = b"ipsec4\0";
pub const NID_ipsec4: u32 = 750;
pub const SN_camellia_128_cbc: &[u8; 17] = b"CAMELLIA-128-CBC\0";
pub const LN_camellia_128_cbc: &[u8; 17] = b"camellia-128-cbc\0";
pub const NID_camellia_128_cbc: u32 = 751;
pub const SN_camellia_192_cbc: &[u8; 17] = b"CAMELLIA-192-CBC\0";
pub const LN_camellia_192_cbc: &[u8; 17] = b"camellia-192-cbc\0";
pub const NID_camellia_192_cbc: u32 = 752;
pub const SN_camellia_256_cbc: &[u8; 17] = b"CAMELLIA-256-CBC\0";
pub const LN_camellia_256_cbc: &[u8; 17] = b"camellia-256-cbc\0";
pub const NID_camellia_256_cbc: u32 = 753;
pub const SN_camellia_128_ecb: &[u8; 17] = b"CAMELLIA-128-ECB\0";
pub const LN_camellia_128_ecb: &[u8; 17] = b"camellia-128-ecb\0";
pub const NID_camellia_128_ecb: u32 = 754;
pub const SN_camellia_192_ecb: &[u8; 17] = b"CAMELLIA-192-ECB\0";
pub const LN_camellia_192_ecb: &[u8; 17] = b"camellia-192-ecb\0";
pub const NID_camellia_192_ecb: u32 = 755;
pub const SN_camellia_256_ecb: &[u8; 17] = b"CAMELLIA-256-ECB\0";
pub const LN_camellia_256_ecb: &[u8; 17] = b"camellia-256-ecb\0";
pub const NID_camellia_256_ecb: u32 = 756;
pub const SN_camellia_128_cfb128: &[u8; 17] = b"CAMELLIA-128-CFB\0";
pub const LN_camellia_128_cfb128: &[u8; 17] = b"camellia-128-cfb\0";
pub const NID_camellia_128_cfb128: u32 = 757;
pub const SN_camellia_192_cfb128: &[u8; 17] = b"CAMELLIA-192-CFB\0";
pub const LN_camellia_192_cfb128: &[u8; 17] = b"camellia-192-cfb\0";
pub const NID_camellia_192_cfb128: u32 = 758;
pub const SN_camellia_256_cfb128: &[u8; 17] = b"CAMELLIA-256-CFB\0";
pub const LN_camellia_256_cfb128: &[u8; 17] = b"camellia-256-cfb\0";
pub const NID_camellia_256_cfb128: u32 = 759;
pub const SN_camellia_128_cfb1: &[u8; 18] = b"CAMELLIA-128-CFB1\0";
pub const LN_camellia_128_cfb1: &[u8; 18] = b"camellia-128-cfb1\0";
pub const NID_camellia_128_cfb1: u32 = 760;
pub const SN_camellia_192_cfb1: &[u8; 18] = b"CAMELLIA-192-CFB1\0";
pub const LN_camellia_192_cfb1: &[u8; 18] = b"camellia-192-cfb1\0";
pub const NID_camellia_192_cfb1: u32 = 761;
pub const SN_camellia_256_cfb1: &[u8; 18] = b"CAMELLIA-256-CFB1\0";
pub const LN_camellia_256_cfb1: &[u8; 18] = b"camellia-256-cfb1\0";
pub const NID_camellia_256_cfb1: u32 = 762;
pub const SN_camellia_128_cfb8: &[u8; 18] = b"CAMELLIA-128-CFB8\0";
pub const LN_camellia_128_cfb8: &[u8; 18] = b"camellia-128-cfb8\0";
pub const NID_camellia_128_cfb8: u32 = 763;
pub const SN_camellia_192_cfb8: &[u8; 18] = b"CAMELLIA-192-CFB8\0";
pub const LN_camellia_192_cfb8: &[u8; 18] = b"camellia-192-cfb8\0";
pub const NID_camellia_192_cfb8: u32 = 764;
pub const SN_camellia_256_cfb8: &[u8; 18] = b"CAMELLIA-256-CFB8\0";
pub const LN_camellia_256_cfb8: &[u8; 18] = b"camellia-256-cfb8\0";
pub const NID_camellia_256_cfb8: u32 = 765;
pub const SN_camellia_128_ofb128: &[u8; 17] = b"CAMELLIA-128-OFB\0";
pub const LN_camellia_128_ofb128: &[u8; 17] = b"camellia-128-ofb\0";
pub const NID_camellia_128_ofb128: u32 = 766;
pub const SN_camellia_192_ofb128: &[u8; 17] = b"CAMELLIA-192-OFB\0";
pub const LN_camellia_192_ofb128: &[u8; 17] = b"camellia-192-ofb\0";
pub const NID_camellia_192_ofb128: u32 = 767;
pub const SN_camellia_256_ofb128: &[u8; 17] = b"CAMELLIA-256-OFB\0";
pub const LN_camellia_256_ofb128: &[u8; 17] = b"camellia-256-ofb\0";
pub const NID_camellia_256_ofb128: u32 = 768;
pub const SN_subject_directory_attributes: &[u8; 27] = b"subjectDirectoryAttributes\0";
pub const LN_subject_directory_attributes: &[u8; 36] = b"X509v3 Subject Directory Attributes\0";
pub const NID_subject_directory_attributes: u32 = 769;
pub const SN_issuing_distribution_point: &[u8; 25] = b"issuingDistributionPoint\0";
pub const LN_issuing_distribution_point: &[u8; 34] = b"X509v3 Issuing Distribution Point\0";
pub const NID_issuing_distribution_point: u32 = 770;
pub const SN_certificate_issuer: &[u8; 18] = b"certificateIssuer\0";
pub const LN_certificate_issuer: &[u8; 26] = b"X509v3 Certificate Issuer\0";
pub const NID_certificate_issuer: u32 = 771;
pub const SN_kisa: &[u8; 5] = b"KISA\0";
pub const LN_kisa: &[u8; 5] = b"kisa\0";
pub const NID_kisa: u32 = 773;
pub const SN_seed_ecb: &[u8; 9] = b"SEED-ECB\0";
pub const LN_seed_ecb: &[u8; 9] = b"seed-ecb\0";
pub const NID_seed_ecb: u32 = 776;
pub const SN_seed_cbc: &[u8; 9] = b"SEED-CBC\0";
pub const LN_seed_cbc: &[u8; 9] = b"seed-cbc\0";
pub const NID_seed_cbc: u32 = 777;
pub const SN_seed_ofb128: &[u8; 9] = b"SEED-OFB\0";
pub const LN_seed_ofb128: &[u8; 9] = b"seed-ofb\0";
pub const NID_seed_ofb128: u32 = 778;
pub const SN_seed_cfb128: &[u8; 9] = b"SEED-CFB\0";
pub const LN_seed_cfb128: &[u8; 9] = b"seed-cfb\0";
pub const NID_seed_cfb128: u32 = 779;
pub const SN_hmac_md5: &[u8; 9] = b"HMAC-MD5\0";
pub const LN_hmac_md5: &[u8; 9] = b"hmac-md5\0";
pub const NID_hmac_md5: u32 = 780;
pub const SN_hmac_sha1: &[u8; 10] = b"HMAC-SHA1\0";
pub const LN_hmac_sha1: &[u8; 10] = b"hmac-sha1\0";
pub const NID_hmac_sha1: u32 = 781;
pub const SN_id_PasswordBasedMAC: &[u8; 20] = b"id-PasswordBasedMAC\0";
pub const LN_id_PasswordBasedMAC: &[u8; 19] = b"password based MAC\0";
pub const NID_id_PasswordBasedMAC: u32 = 782;
pub const SN_id_DHBasedMac: &[u8; 14] = b"id-DHBasedMac\0";
pub const LN_id_DHBasedMac: &[u8; 25] = b"Diffie-Hellman based MAC\0";
pub const NID_id_DHBasedMac: u32 = 783;
pub const SN_id_it_suppLangTags: &[u8; 19] = b"id-it-suppLangTags\0";
pub const NID_id_it_suppLangTags: u32 = 784;
pub const SN_caRepository: &[u8; 13] = b"caRepository\0";
pub const LN_caRepository: &[u8; 14] = b"CA Repository\0";
pub const NID_caRepository: u32 = 785;
pub const SN_id_smime_ct_compressedData: &[u8; 27] = b"id-smime-ct-compressedData\0";
pub const NID_id_smime_ct_compressedData: u32 = 786;
pub const SN_id_ct_asciiTextWithCRLF: &[u8; 24] = b"id-ct-asciiTextWithCRLF\0";
pub const NID_id_ct_asciiTextWithCRLF: u32 = 787;
pub const SN_id_aes128_wrap: &[u8; 15] = b"id-aes128-wrap\0";
pub const NID_id_aes128_wrap: u32 = 788;
pub const SN_id_aes192_wrap: &[u8; 15] = b"id-aes192-wrap\0";
pub const NID_id_aes192_wrap: u32 = 789;
pub const SN_id_aes256_wrap: &[u8; 15] = b"id-aes256-wrap\0";
pub const NID_id_aes256_wrap: u32 = 790;
pub const SN_ecdsa_with_Recommended: &[u8; 23] = b"ecdsa-with-Recommended\0";
pub const NID_ecdsa_with_Recommended: u32 = 791;
pub const SN_ecdsa_with_Specified: &[u8; 21] = b"ecdsa-with-Specified\0";
pub const NID_ecdsa_with_Specified: u32 = 792;
pub const SN_ecdsa_with_SHA224: &[u8; 18] = b"ecdsa-with-SHA224\0";
pub const NID_ecdsa_with_SHA224: u32 = 793;
pub const SN_ecdsa_with_SHA256: &[u8; 18] = b"ecdsa-with-SHA256\0";
pub const NID_ecdsa_with_SHA256: u32 = 794;
pub const SN_ecdsa_with_SHA384: &[u8; 18] = b"ecdsa-with-SHA384\0";
pub const NID_ecdsa_with_SHA384: u32 = 795;
pub const SN_ecdsa_with_SHA512: &[u8; 18] = b"ecdsa-with-SHA512\0";
pub const NID_ecdsa_with_SHA512: u32 = 796;
pub const LN_hmacWithMD5: &[u8; 12] = b"hmacWithMD5\0";
pub const NID_hmacWithMD5: u32 = 797;
pub const LN_hmacWithSHA224: &[u8; 15] = b"hmacWithSHA224\0";
pub const NID_hmacWithSHA224: u32 = 798;
pub const LN_hmacWithSHA256: &[u8; 15] = b"hmacWithSHA256\0";
pub const NID_hmacWithSHA256: u32 = 799;
pub const LN_hmacWithSHA384: &[u8; 15] = b"hmacWithSHA384\0";
pub const NID_hmacWithSHA384: u32 = 800;
pub const LN_hmacWithSHA512: &[u8; 15] = b"hmacWithSHA512\0";
pub const NID_hmacWithSHA512: u32 = 801;
pub const SN_dsa_with_SHA224: &[u8; 16] = b"dsa_with_SHA224\0";
pub const NID_dsa_with_SHA224: u32 = 802;
pub const SN_dsa_with_SHA256: &[u8; 16] = b"dsa_with_SHA256\0";
pub const NID_dsa_with_SHA256: u32 = 803;
pub const SN_whirlpool: &[u8; 10] = b"whirlpool\0";
pub const NID_whirlpool: u32 = 804;
pub const SN_cryptopro: &[u8; 10] = b"cryptopro\0";
pub const NID_cryptopro: u32 = 805;
pub const SN_cryptocom: &[u8; 10] = b"cryptocom\0";
pub const NID_cryptocom: u32 = 806;
pub const SN_id_GostR3411_94_with_GostR3410_2001: &[u8; 36] =
    b"id-GostR3411-94-with-GostR3410-2001\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001: &[u8; 39] =
    b"GOST R 34.11-94 with GOST R 34.10-2001\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001: u32 = 807;
pub const SN_id_GostR3411_94_with_GostR3410_94: &[u8; 34] = b"id-GostR3411-94-with-GostR3410-94\0";
pub const LN_id_GostR3411_94_with_GostR3410_94: &[u8; 37] =
    b"GOST R 34.11-94 with GOST R 34.10-94\0";
pub const NID_id_GostR3411_94_with_GostR3410_94: u32 = 808;
pub const SN_id_GostR3411_94: &[u8; 10] = b"md_gost94\0";
pub const LN_id_GostR3411_94: &[u8; 16] = b"GOST R 34.11-94\0";
pub const NID_id_GostR3411_94: u32 = 809;
pub const SN_id_HMACGostR3411_94: &[u8; 20] = b"id-HMACGostR3411-94\0";
pub const LN_id_HMACGostR3411_94: &[u8; 19] = b"HMAC GOST 34.11-94\0";
pub const NID_id_HMACGostR3411_94: u32 = 810;
pub const SN_id_GostR3410_2001: &[u8; 9] = b"gost2001\0";
pub const LN_id_GostR3410_2001: &[u8; 18] = b"GOST R 34.10-2001\0";
pub const NID_id_GostR3410_2001: u32 = 811;
pub const SN_id_GostR3410_94: &[u8; 7] = b"gost94\0";
pub const LN_id_GostR3410_94: &[u8; 16] = b"GOST R 34.10-94\0";
pub const NID_id_GostR3410_94: u32 = 812;
pub const SN_id_Gost28147_89: &[u8; 7] = b"gost89\0";
pub const LN_id_Gost28147_89: &[u8; 14] = b"GOST 28147-89\0";
pub const NID_id_Gost28147_89: u32 = 813;
pub const SN_gost89_cnt: &[u8; 11] = b"gost89-cnt\0";
pub const NID_gost89_cnt: u32 = 814;
pub const SN_id_Gost28147_89_MAC: &[u8; 9] = b"gost-mac\0";
pub const LN_id_Gost28147_89_MAC: &[u8; 18] = b"GOST 28147-89 MAC\0";
pub const NID_id_Gost28147_89_MAC: u32 = 815;
pub const SN_id_GostR3411_94_prf: &[u8; 17] = b"prf-gostr3411-94\0";
pub const LN_id_GostR3411_94_prf: &[u8; 20] = b"GOST R 34.11-94 PRF\0";
pub const NID_id_GostR3411_94_prf: u32 = 816;
pub const SN_id_GostR3410_2001DH: &[u8; 20] = b"id-GostR3410-2001DH\0";
pub const LN_id_GostR3410_2001DH: &[u8; 21] = b"GOST R 34.10-2001 DH\0";
pub const NID_id_GostR3410_2001DH: u32 = 817;
pub const SN_id_GostR3410_94DH: &[u8; 18] = b"id-GostR3410-94DH\0";
pub const LN_id_GostR3410_94DH: &[u8; 19] = b"GOST R 34.10-94 DH\0";
pub const NID_id_GostR3410_94DH: u32 = 818;
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing: &[u8; 37] =
    b"id-Gost28147-89-CryptoPro-KeyMeshing\0";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing: u32 = 819;
pub const SN_id_Gost28147_89_None_KeyMeshing: &[u8; 32] = b"id-Gost28147-89-None-KeyMeshing\0";
pub const NID_id_Gost28147_89_None_KeyMeshing: u32 = 820;
pub const SN_id_GostR3411_94_TestParamSet: &[u8; 29] = b"id-GostR3411-94-TestParamSet\0";
pub const NID_id_GostR3411_94_TestParamSet: u32 = 821;
pub const SN_id_GostR3411_94_CryptoProParamSet: &[u8; 34] = b"id-GostR3411-94-CryptoProParamSet\0";
pub const NID_id_GostR3411_94_CryptoProParamSet: u32 = 822;
pub const SN_id_Gost28147_89_TestParamSet: &[u8; 29] = b"id-Gost28147-89-TestParamSet\0";
pub const NID_id_Gost28147_89_TestParamSet: u32 = 823;
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet: &[u8; 37] =
    b"id-Gost28147-89-CryptoPro-A-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet: u32 = 824;
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet: &[u8; 37] =
    b"id-Gost28147-89-CryptoPro-B-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet: u32 = 825;
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet: &[u8; 37] =
    b"id-Gost28147-89-CryptoPro-C-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet: u32 = 826;
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet: &[u8; 37] =
    b"id-Gost28147-89-CryptoPro-D-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet: u32 = 827;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: &[u8; 45] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet: u32 = 828;
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: &[u8; 45] =
    b"id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet: u32 = 829;
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: &[u8; 41] =
    b"id-Gost28147-89-CryptoPro-RIC-1-ParamSet\0";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet: u32 = 830;
pub const SN_id_GostR3410_94_TestParamSet: &[u8; 29] = b"id-GostR3410-94-TestParamSet\0";
pub const NID_id_GostR3410_94_TestParamSet: u32 = 831;
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet: &[u8; 37] =
    b"id-GostR3410-94-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet: u32 = 832;
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet: &[u8; 37] =
    b"id-GostR3410-94-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet: u32 = 833;
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet: &[u8; 37] =
    b"id-GostR3410-94-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet: u32 = 834;
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet: &[u8; 37] =
    b"id-GostR3410-94-CryptoPro-D-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet: u32 = 835;
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet: &[u8; 40] =
    b"id-GostR3410-94-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet: u32 = 836;
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet: &[u8; 40] =
    b"id-GostR3410-94-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet: u32 = 837;
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet: &[u8; 40] =
    b"id-GostR3410-94-CryptoPro-XchC-ParamSet\0";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet: u32 = 838;
pub const SN_id_GostR3410_2001_TestParamSet: &[u8; 31] = b"id-GostR3410-2001-TestParamSet\0";
pub const NID_id_GostR3410_2001_TestParamSet: u32 = 839;
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet: &[u8; 39] =
    b"id-GostR3410-2001-CryptoPro-A-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet: u32 = 840;
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet: &[u8; 39] =
    b"id-GostR3410-2001-CryptoPro-B-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet: u32 = 841;
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet: &[u8; 39] =
    b"id-GostR3410-2001-CryptoPro-C-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet: u32 = 842;
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet: &[u8; 42] =
    b"id-GostR3410-2001-CryptoPro-XchA-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet: u32 = 843;
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet: &[u8; 42] =
    b"id-GostR3410-2001-CryptoPro-XchB-ParamSet\0";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet: u32 = 844;
pub const SN_id_GostR3410_94_a: &[u8; 18] = b"id-GostR3410-94-a\0";
pub const NID_id_GostR3410_94_a: u32 = 845;
pub const SN_id_GostR3410_94_aBis: &[u8; 21] = b"id-GostR3410-94-aBis\0";
pub const NID_id_GostR3410_94_aBis: u32 = 846;
pub const SN_id_GostR3410_94_b: &[u8; 18] = b"id-GostR3410-94-b\0";
pub const NID_id_GostR3410_94_b: u32 = 847;
pub const SN_id_GostR3410_94_bBis: &[u8; 21] = b"id-GostR3410-94-bBis\0";
pub const NID_id_GostR3410_94_bBis: u32 = 848;
pub const SN_id_Gost28147_89_cc: &[u8; 19] = b"id-Gost28147-89-cc\0";
pub const LN_id_Gost28147_89_cc: &[u8; 33] = b"GOST 28147-89 Cryptocom ParamSet\0";
pub const NID_id_Gost28147_89_cc: u32 = 849;
pub const SN_id_GostR3410_94_cc: &[u8; 9] = b"gost94cc\0";
pub const LN_id_GostR3410_94_cc: &[u8; 24] = b"GOST 34.10-94 Cryptocom\0";
pub const NID_id_GostR3410_94_cc: u32 = 850;
pub const SN_id_GostR3410_2001_cc: &[u8; 11] = b"gost2001cc\0";
pub const LN_id_GostR3410_2001_cc: &[u8; 26] = b"GOST 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3410_2001_cc: u32 = 851;
pub const SN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 37] =
    b"id-GostR3411-94-with-GostR3410-94-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc: &[u8; 47] =
    b"GOST R 34.11-94 with GOST R 34.10-94 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc: u32 = 852;
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 39] =
    b"id-GostR3411-94-with-GostR3410-2001-cc\0";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc: &[u8; 49] =
    b"GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom\0";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc: u32 = 853;
pub const SN_id_GostR3410_2001_ParamSet_cc: &[u8; 30] = b"id-GostR3410-2001-ParamSet-cc\0";
pub const LN_id_GostR3410_2001_ParamSet_cc: &[u8; 41] =
    b"GOST R 3410-2001 Parameter Set Cryptocom\0";
pub const NID_id_GostR3410_2001_ParamSet_cc: u32 = 854;
pub const SN_hmac: &[u8; 5] = b"HMAC\0";
pub const LN_hmac: &[u8; 5] = b"hmac\0";
pub const NID_hmac: u32 = 855;
pub const SN_LocalKeySet: &[u8; 12] = b"LocalKeySet\0";
pub const LN_LocalKeySet: &[u8; 24] = b"Microsoft Local Key set\0";
pub const NID_LocalKeySet: u32 = 856;
pub const SN_freshest_crl: &[u8; 12] = b"freshestCRL\0";
pub const LN_freshest_crl: &[u8; 20] = b"X509v3 Freshest CRL\0";
pub const NID_freshest_crl: u32 = 857;
pub const SN_id_on_permanentIdentifier: &[u8; 26] = b"id-on-permanentIdentifier\0";
pub const LN_id_on_permanentIdentifier: &[u8; 21] = b"Permanent Identifier\0";
pub const NID_id_on_permanentIdentifier: u32 = 858;
pub const LN_searchGuide: &[u8; 12] = b"searchGuide\0";
pub const NID_searchGuide: u32 = 859;
pub const LN_businessCategory: &[u8; 17] = b"businessCategory\0";
pub const NID_businessCategory: u32 = 860;
pub const LN_postalAddress: &[u8; 14] = b"postalAddress\0";
pub const NID_postalAddress: u32 = 861;
pub const LN_postOfficeBox: &[u8; 14] = b"postOfficeBox\0";
pub const NID_postOfficeBox: u32 = 862;
pub const LN_physicalDeliveryOfficeName: &[u8; 27] = b"physicalDeliveryOfficeName\0";
pub const NID_physicalDeliveryOfficeName: u32 = 863;
pub const LN_telephoneNumber: &[u8; 16] = b"telephoneNumber\0";
pub const NID_telephoneNumber: u32 = 864;
pub const LN_telexNumber: &[u8; 12] = b"telexNumber\0";
pub const NID_telexNumber: u32 = 865;
pub const LN_teletexTerminalIdentifier: &[u8; 26] = b"teletexTerminalIdentifier\0";
pub const NID_teletexTerminalIdentifier: u32 = 866;
pub const LN_facsimileTelephoneNumber: &[u8; 25] = b"facsimileTelephoneNumber\0";
pub const NID_facsimileTelephoneNumber: u32 = 867;
pub const LN_x121Address: &[u8; 12] = b"x121Address\0";
pub const NID_x121Address: u32 = 868;
pub const LN_internationaliSDNNumber: &[u8; 24] = b"internationaliSDNNumber\0";
pub const NID_internationaliSDNNumber: u32 = 869;
pub const LN_registeredAddress: &[u8; 18] = b"registeredAddress\0";
pub const NID_registeredAddress: u32 = 870;
pub const LN_destinationIndicator: &[u8; 21] = b"destinationIndicator\0";
pub const NID_destinationIndicator: u32 = 871;
pub const LN_preferredDeliveryMethod: &[u8; 24] = b"preferredDeliveryMethod\0";
pub const NID_preferredDeliveryMethod: u32 = 872;
pub const LN_presentationAddress: &[u8; 20] = b"presentationAddress\0";
pub const NID_presentationAddress: u32 = 873;
pub const LN_supportedApplicationContext: &[u8; 28] = b"supportedApplicationContext\0";
pub const NID_supportedApplicationContext: u32 = 874;
pub const SN_member: &[u8; 7] = b"member\0";
pub const NID_member: u32 = 875;
pub const SN_owner: &[u8; 6] = b"owner\0";
pub const NID_owner: u32 = 876;
pub const LN_roleOccupant: &[u8; 13] = b"roleOccupant\0";
pub const NID_roleOccupant: u32 = 877;
pub const SN_seeAlso: &[u8; 8] = b"seeAlso\0";
pub const NID_seeAlso: u32 = 878;
pub const LN_userPassword: &[u8; 13] = b"userPassword\0";
pub const NID_userPassword: u32 = 879;
pub const LN_userCertificate: &[u8; 16] = b"userCertificate\0";
pub const NID_userCertificate: u32 = 880;
pub const LN_cACertificate: &[u8; 14] = b"cACertificate\0";
pub const NID_cACertificate: u32 = 881;
pub const LN_authorityRevocationList: &[u8; 24] = b"authorityRevocationList\0";
pub const NID_authorityRevocationList: u32 = 882;
pub const LN_certificateRevocationList: &[u8; 26] = b"certificateRevocationList\0";
pub const NID_certificateRevocationList: u32 = 883;
pub const LN_crossCertificatePair: &[u8; 21] = b"crossCertificatePair\0";
pub const NID_crossCertificatePair: u32 = 884;
pub const LN_enhancedSearchGuide: &[u8; 20] = b"enhancedSearchGuide\0";
pub const NID_enhancedSearchGuide: u32 = 885;
pub const LN_protocolInformation: &[u8; 20] = b"protocolInformation\0";
pub const NID_protocolInformation: u32 = 886;
pub const LN_distinguishedName: &[u8; 18] = b"distinguishedName\0";
pub const NID_distinguishedName: u32 = 887;
pub const LN_uniqueMember: &[u8; 13] = b"uniqueMember\0";
pub const NID_uniqueMember: u32 = 888;
pub const LN_houseIdentifier: &[u8; 16] = b"houseIdentifier\0";
pub const NID_houseIdentifier: u32 = 889;
pub const LN_supportedAlgorithms: &[u8; 20] = b"supportedAlgorithms\0";
pub const NID_supportedAlgorithms: u32 = 890;
pub const LN_deltaRevocationList: &[u8; 20] = b"deltaRevocationList\0";
pub const NID_deltaRevocationList: u32 = 891;
pub const SN_dmdName: &[u8; 8] = b"dmdName\0";
pub const NID_dmdName: u32 = 892;
pub const SN_id_alg_PWRI_KEK: &[u8; 16] = b"id-alg-PWRI-KEK\0";
pub const NID_id_alg_PWRI_KEK: u32 = 893;
pub const SN_cmac: &[u8; 5] = b"CMAC\0";
pub const LN_cmac: &[u8; 5] = b"cmac\0";
pub const NID_cmac: u32 = 894;
pub const SN_aes_128_gcm: &[u8; 14] = b"id-aes128-GCM\0";
pub const LN_aes_128_gcm: &[u8; 12] = b"aes-128-gcm\0";
pub const NID_aes_128_gcm: u32 = 895;
pub const SN_aes_128_ccm: &[u8; 14] = b"id-aes128-CCM\0";
pub const LN_aes_128_ccm: &[u8; 12] = b"aes-128-ccm\0";
pub const NID_aes_128_ccm: u32 = 896;
pub const SN_id_aes128_wrap_pad: &[u8; 19] = b"id-aes128-wrap-pad\0";
pub const NID_id_aes128_wrap_pad: u32 = 897;
pub const SN_aes_192_gcm: &[u8; 14] = b"id-aes192-GCM\0";
pub const LN_aes_192_gcm: &[u8; 12] = b"aes-192-gcm\0";
pub const NID_aes_192_gcm: u32 = 898;
pub const SN_aes_192_ccm: &[u8; 14] = b"id-aes192-CCM\0";
pub const LN_aes_192_ccm: &[u8; 12] = b"aes-192-ccm\0";
pub const NID_aes_192_ccm: u32 = 899;
pub const SN_id_aes192_wrap_pad: &[u8; 19] = b"id-aes192-wrap-pad\0";
pub const NID_id_aes192_wrap_pad: u32 = 900;
pub const SN_aes_256_gcm: &[u8; 14] = b"id-aes256-GCM\0";
pub const LN_aes_256_gcm: &[u8; 12] = b"aes-256-gcm\0";
pub const NID_aes_256_gcm: u32 = 901;
pub const SN_aes_256_ccm: &[u8; 14] = b"id-aes256-CCM\0";
pub const LN_aes_256_ccm: &[u8; 12] = b"aes-256-ccm\0";
pub const NID_aes_256_ccm: u32 = 902;
pub const SN_id_aes256_wrap_pad: &[u8; 19] = b"id-aes256-wrap-pad\0";
pub const NID_id_aes256_wrap_pad: u32 = 903;
pub const SN_aes_128_ctr: &[u8; 12] = b"AES-128-CTR\0";
pub const LN_aes_128_ctr: &[u8; 12] = b"aes-128-ctr\0";
pub const NID_aes_128_ctr: u32 = 904;
pub const SN_aes_192_ctr: &[u8; 12] = b"AES-192-CTR\0";
pub const LN_aes_192_ctr: &[u8; 12] = b"aes-192-ctr\0";
pub const NID_aes_192_ctr: u32 = 905;
pub const SN_aes_256_ctr: &[u8; 12] = b"AES-256-CTR\0";
pub const LN_aes_256_ctr: &[u8; 12] = b"aes-256-ctr\0";
pub const NID_aes_256_ctr: u32 = 906;
pub const SN_id_camellia128_wrap: &[u8; 20] = b"id-camellia128-wrap\0";
pub const NID_id_camellia128_wrap: u32 = 907;
pub const SN_id_camellia192_wrap: &[u8; 20] = b"id-camellia192-wrap\0";
pub const NID_id_camellia192_wrap: u32 = 908;
pub const SN_id_camellia256_wrap: &[u8; 20] = b"id-camellia256-wrap\0";
pub const NID_id_camellia256_wrap: u32 = 909;
pub const SN_anyExtendedKeyUsage: &[u8; 20] = b"anyExtendedKeyUsage\0";
pub const LN_anyExtendedKeyUsage: &[u8; 23] = b"Any Extended Key Usage\0";
pub const NID_anyExtendedKeyUsage: u32 = 910;
pub const SN_mgf1: &[u8; 5] = b"MGF1\0";
pub const LN_mgf1: &[u8; 5] = b"mgf1\0";
pub const NID_mgf1: u32 = 911;
pub const SN_rsassaPss: &[u8; 11] = b"RSASSA-PSS\0";
pub const LN_rsassaPss: &[u8; 10] = b"rsassaPss\0";
pub const NID_rsassaPss: u32 = 912;
pub const SN_aes_128_xts: &[u8; 12] = b"AES-128-XTS\0";
pub const LN_aes_128_xts: &[u8; 12] = b"aes-128-xts\0";
pub const NID_aes_128_xts: u32 = 913;
pub const SN_aes_256_xts: &[u8; 12] = b"AES-256-XTS\0";
pub const LN_aes_256_xts: &[u8; 12] = b"aes-256-xts\0";
pub const NID_aes_256_xts: u32 = 914;
pub const SN_rc4_hmac_md5: &[u8; 13] = b"RC4-HMAC-MD5\0";
pub const LN_rc4_hmac_md5: &[u8; 13] = b"rc4-hmac-md5\0";
pub const NID_rc4_hmac_md5: u32 = 915;
pub const SN_aes_128_cbc_hmac_sha1: &[u8; 22] = b"AES-128-CBC-HMAC-SHA1\0";
pub const LN_aes_128_cbc_hmac_sha1: &[u8; 22] = b"aes-128-cbc-hmac-sha1\0";
pub const NID_aes_128_cbc_hmac_sha1: u32 = 916;
pub const SN_aes_192_cbc_hmac_sha1: &[u8; 22] = b"AES-192-CBC-HMAC-SHA1\0";
pub const LN_aes_192_cbc_hmac_sha1: &[u8; 22] = b"aes-192-cbc-hmac-sha1\0";
pub const NID_aes_192_cbc_hmac_sha1: u32 = 917;
pub const SN_aes_256_cbc_hmac_sha1: &[u8; 22] = b"AES-256-CBC-HMAC-SHA1\0";
pub const LN_aes_256_cbc_hmac_sha1: &[u8; 22] = b"aes-256-cbc-hmac-sha1\0";
pub const NID_aes_256_cbc_hmac_sha1: u32 = 918;
pub const SN_rsaesOaep: &[u8; 11] = b"RSAES-OAEP\0";
pub const LN_rsaesOaep: &[u8; 10] = b"rsaesOaep\0";
pub const NID_rsaesOaep: u32 = 919;
pub const SN_dhpublicnumber: &[u8; 15] = b"dhpublicnumber\0";
pub const LN_dhpublicnumber: &[u8; 9] = b"X9.42 DH\0";
pub const NID_dhpublicnumber: u32 = 920;
pub const SN_brainpoolP160r1: &[u8; 16] = b"brainpoolP160r1\0";
pub const NID_brainpoolP160r1: u32 = 921;
pub const SN_brainpoolP160t1: &[u8; 16] = b"brainpoolP160t1\0";
pub const NID_brainpoolP160t1: u32 = 922;
pub const SN_brainpoolP192r1: &[u8; 16] = b"brainpoolP192r1\0";
pub const NID_brainpoolP192r1: u32 = 923;
pub const SN_brainpoolP192t1: &[u8; 16] = b"brainpoolP192t1\0";
pub const NID_brainpoolP192t1: u32 = 924;
pub const SN_brainpoolP224r1: &[u8; 16] = b"brainpoolP224r1\0";
pub const NID_brainpoolP224r1: u32 = 925;
pub const SN_brainpoolP224t1: &[u8; 16] = b"brainpoolP224t1\0";
pub const NID_brainpoolP224t1: u32 = 926;
pub const SN_brainpoolP256r1: &[u8; 16] = b"brainpoolP256r1\0";
pub const NID_brainpoolP256r1: u32 = 927;
pub const SN_brainpoolP256t1: &[u8; 16] = b"brainpoolP256t1\0";
pub const NID_brainpoolP256t1: u32 = 928;
pub const SN_brainpoolP320r1: &[u8; 16] = b"brainpoolP320r1\0";
pub const NID_brainpoolP320r1: u32 = 929;
pub const SN_brainpoolP320t1: &[u8; 16] = b"brainpoolP320t1\0";
pub const NID_brainpoolP320t1: u32 = 930;
pub const SN_brainpoolP384r1: &[u8; 16] = b"brainpoolP384r1\0";
pub const NID_brainpoolP384r1: u32 = 931;
pub const SN_brainpoolP384t1: &[u8; 16] = b"brainpoolP384t1\0";
pub const NID_brainpoolP384t1: u32 = 932;
pub const SN_brainpoolP512r1: &[u8; 16] = b"brainpoolP512r1\0";
pub const NID_brainpoolP512r1: u32 = 933;
pub const SN_brainpoolP512t1: &[u8; 16] = b"brainpoolP512t1\0";
pub const NID_brainpoolP512t1: u32 = 934;
pub const SN_pSpecified: &[u8; 11] = b"PSPECIFIED\0";
pub const LN_pSpecified: &[u8; 11] = b"pSpecified\0";
pub const NID_pSpecified: u32 = 935;
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme: &[u8; 34] = b"dhSinglePass-stdDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme: u32 = 936;
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme: &[u8; 36] =
    b"dhSinglePass-stdDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme: u32 = 937;
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme: &[u8; 36] =
    b"dhSinglePass-stdDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme: u32 = 938;
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme: &[u8; 36] =
    b"dhSinglePass-stdDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme: u32 = 939;
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme: &[u8; 36] =
    b"dhSinglePass-stdDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme: u32 = 940;
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme: &[u8; 39] =
    b"dhSinglePass-cofactorDH-sha1kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme: u32 = 941;
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme: &[u8; 41] =
    b"dhSinglePass-cofactorDH-sha224kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme: u32 = 942;
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme: &[u8; 41] =
    b"dhSinglePass-cofactorDH-sha256kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme: u32 = 943;
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme: &[u8; 41] =
    b"dhSinglePass-cofactorDH-sha384kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme: u32 = 944;
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme: &[u8; 41] =
    b"dhSinglePass-cofactorDH-sha512kdf-scheme\0";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme: u32 = 945;
pub const SN_dh_std_kdf: &[u8; 11] = b"dh-std-kdf\0";
pub const NID_dh_std_kdf: u32 = 946;
pub const SN_dh_cofactor_kdf: &[u8; 16] = b"dh-cofactor-kdf\0";
pub const NID_dh_cofactor_kdf: u32 = 947;
pub const SN_X25519: &[u8; 7] = b"X25519\0";
pub const NID_X25519: u32 = 948;
pub const SN_ED25519: &[u8; 8] = b"ED25519\0";
pub const NID_ED25519: u32 = 949;
pub const SN_chacha20_poly1305: &[u8; 18] = b"ChaCha20-Poly1305\0";
pub const LN_chacha20_poly1305: &[u8; 18] = b"chacha20-poly1305\0";
pub const NID_chacha20_poly1305: u32 = 950;
pub const SN_kx_rsa: &[u8; 6] = b"KxRSA\0";
pub const LN_kx_rsa: &[u8; 7] = b"kx-rsa\0";
pub const NID_kx_rsa: u32 = 951;
pub const SN_kx_ecdhe: &[u8; 8] = b"KxECDHE\0";
pub const LN_kx_ecdhe: &[u8; 9] = b"kx-ecdhe\0";
pub const NID_kx_ecdhe: u32 = 952;
pub const SN_kx_psk: &[u8; 6] = b"KxPSK\0";
pub const LN_kx_psk: &[u8; 7] = b"kx-psk\0";
pub const NID_kx_psk: u32 = 953;
pub const SN_auth_rsa: &[u8; 8] = b"AuthRSA\0";
pub const LN_auth_rsa: &[u8; 9] = b"auth-rsa\0";
pub const NID_auth_rsa: u32 = 954;
pub const SN_auth_ecdsa: &[u8; 10] = b"AuthECDSA\0";
pub const LN_auth_ecdsa: &[u8; 11] = b"auth-ecdsa\0";
pub const NID_auth_ecdsa: u32 = 955;
pub const SN_auth_psk: &[u8; 8] = b"AuthPSK\0";
pub const LN_auth_psk: &[u8; 9] = b"auth-psk\0";
pub const NID_auth_psk: u32 = 956;
pub const SN_kx_any: &[u8; 6] = b"KxANY\0";
pub const LN_kx_any: &[u8; 7] = b"kx-any\0";
pub const NID_kx_any: u32 = 957;
pub const SN_auth_any: &[u8; 8] = b"AuthANY\0";
pub const LN_auth_any: &[u8; 9] = b"auth-any\0";
pub const NID_auth_any: u32 = 958;
pub const SN_ED448: &[u8; 6] = b"ED448\0";
pub const NID_ED448: u32 = 960;
pub const SN_X448: &[u8; 5] = b"X448\0";
pub const NID_X448: u32 = 961;
pub const SN_sha512_256: &[u8; 11] = b"SHA512-256\0";
pub const LN_sha512_256: &[u8; 11] = b"sha512-256\0";
pub const NID_sha512_256: u32 = 962;
pub const SN_aes_128_cbc_hmac_sha256: &[u8; 24] = b"AES-128-CBC-HMAC-SHA256\0";
pub const LN_aes_128_cbc_hmac_sha256: &[u8; 24] = b"aes-128-cbc-hmac-sha256\0";
pub const NID_aes_128_cbc_hmac_sha256: u32 = 963;
pub const SN_aes_256_cbc_hmac_sha256: &[u8; 24] = b"AES-256-CBC-HMAC-SHA256\0";
pub const LN_aes_256_cbc_hmac_sha256: &[u8; 24] = b"aes-256-cbc-hmac-sha256\0";
pub const NID_aes_256_cbc_hmac_sha256: u32 = 964;
pub const SN_sha3_224: &[u8; 9] = b"SHA3-224\0";
pub const LN_sha3_224: &[u8; 9] = b"sha3-224\0";
pub const NID_sha3_224: u32 = 965;
pub const SN_sha3_256: &[u8; 9] = b"SHA3-256\0";
pub const LN_sha3_256: &[u8; 9] = b"sha3-256\0";
pub const NID_sha3_256: u32 = 966;
pub const SN_sha3_384: &[u8; 9] = b"SHA3-384\0";
pub const LN_sha3_384: &[u8; 9] = b"sha3-384\0";
pub const NID_sha3_384: u32 = 967;
pub const SN_sha3_512: &[u8; 9] = b"SHA3-512\0";
pub const LN_sha3_512: &[u8; 9] = b"sha3-512\0";
pub const NID_sha3_512: u32 = 968;
pub const SN_hkdf: &[u8; 5] = b"HKDF\0";
pub const LN_hkdf: &[u8; 5] = b"hkdf\0";
pub const NID_hkdf: u32 = 969;
pub const SN_kem: &[u8; 4] = b"KEM\0";
pub const LN_kem: &[u8; 4] = b"kem\0";
pub const NID_kem: u32 = 970;
pub const SN_KYBER512: &[u8; 9] = b"KYBER512\0";
pub const NID_KYBER512: u32 = 971;
pub const SN_KYBER512_R3: &[u8; 12] = b"KYBER512_R3\0";
pub const NID_KYBER512_R3: u32 = 972;
pub const SN_KYBER768_R3: &[u8; 12] = b"KYBER768_R3\0";
pub const NID_KYBER768_R3: u32 = 973;
pub const SN_KYBER1024_R3: &[u8; 13] = b"KYBER1024_R3\0";
pub const NID_KYBER1024_R3: u32 = 974;
pub const SN_DILITHIUM3_R3: &[u8; 14] = b"DILITHIUM3_R3\0";
pub const NID_DILITHIUM3_R3: u32 = 975;
pub const SN_ffdhe2048: &[u8; 10] = b"ffdhe2048\0";
pub const NID_ffdhe2048: u32 = 976;
pub const SN_ffdhe4096: &[u8; 10] = b"ffdhe4096\0";
pub const NID_ffdhe4096: u32 = 977;
pub const SN_sha512_224: &[u8; 11] = b"SHA512-224\0";
pub const LN_sha512_224: &[u8; 11] = b"sha512-224\0";
pub const NID_sha512_224: u32 = 978;
pub const SN_shake128: &[u8; 9] = b"SHAKE128\0";
pub const LN_shake128: &[u8; 9] = b"shake128\0";
pub const NID_shake128: u32 = 979;
pub const SN_shake256: &[u8; 9] = b"SHAKE256\0";
pub const LN_shake256: &[u8; 9] = b"shake256\0";
pub const NID_shake256: u32 = 980;
pub const SN_SecP256r1Kyber768Draft00: &[u8; 25] = b"SecP256r1Kyber768Draft00\0";
pub const NID_SecP256r1Kyber768Draft00: u32 = 981;
pub const SN_X25519Kyber768Draft00: &[u8; 22] = b"X25519Kyber768Draft00\0";
pub const NID_X25519Kyber768Draft00: u32 = 982;
pub const SN_ffdhe3072: &[u8; 10] = b"ffdhe3072\0";
pub const NID_ffdhe3072: u32 = 983;
pub const SN_ffdhe8192: &[u8; 10] = b"ffdhe8192\0";
pub const NID_ffdhe8192: u32 = 984;
pub const SN_MLKEM512IPD: &[u8; 12] = b"MLKEM512IPD\0";
pub const NID_MLKEM512IPD: u32 = 985;
pub const SN_MLKEM768IPD: &[u8; 12] = b"MLKEM768IPD\0";
pub const NID_MLKEM768IPD: u32 = 986;
pub const SN_MLKEM1024IPD: &[u8; 13] = b"MLKEM1024IPD\0";
pub const NID_MLKEM1024IPD: u32 = 987;
pub const OBJ_NAME_TYPE_MD_METH: u32 = 1;
pub const OBJ_NAME_TYPE_CIPHER_METH: u32 = 2;
pub const OBJ_R_UNKNOWN_NID: u32 = 100;
pub const OBJ_R_INVALID_OID_STRING: u32 = 101;
pub const EVP_PKEY_NONE: u32 = 0;
pub const EVP_PKEY_RSA: u32 = 6;
pub const EVP_PKEY_RSA_PSS: u32 = 912;
pub const EVP_PKEY_EC: u32 = 408;
pub const EVP_PKEY_ED25519: u32 = 949;
pub const EVP_PKEY_X25519: u32 = 948;
pub const EVP_PKEY_HKDF: u32 = 969;
pub const EVP_PKEY_HMAC: u32 = 855;
pub const EVP_PKEY_KEM: u32 = 970;
pub const PKCS5_SALT_LEN: u32 = 8;
pub const EVP_PKEY_RSA2: u32 = 19;
pub const EVP_PKEY_X448: u32 = 961;
pub const EVP_PKEY_ED448: u32 = 960;
pub const EVP_PKEY_DSA: u32 = 116;
pub const EVP_PKEY_DH: u32 = 28;
pub const HKDF_R_OUTPUT_TOO_LARGE: u32 = 100;
pub const MD5_CBLOCK: u32 = 64;
pub const MD5_DIGEST_LENGTH: u32 = 16;
pub const HMAC_MAX_PRECOMPUTED_KEY_SIZE: u32 = 128;
pub const HMAC_R_MISSING_PARAMETERS: u32 = 100;
pub const HMAC_R_BUFFER_TOO_SMALL: u32 = 102;
pub const HMAC_R_SET_PRECOMPUTED_KEY_EXPORT_NOT_CALLED: u32 = 103;
pub const HMAC_R_NOT_CALLED_JUST_AFTER_INIT: u32 = 104;
pub const EVP_HPKE_DHKEM_X25519_HKDF_SHA256: u32 = 32;
pub const EVP_HPKE_MAX_PUBLIC_KEY_LENGTH: u32 = 32;
pub const EVP_HPKE_MAX_PRIVATE_KEY_LENGTH: u32 = 32;
pub const EVP_HPKE_MAX_ENC_LENGTH: u32 = 32;
pub const EVP_HPKE_HKDF_SHA256: u32 = 1;
pub const EVP_HPKE_AES_128_GCM: u32 = 1;
pub const EVP_HPKE_AES_256_GCM: u32 = 2;
pub const EVP_HPKE_CHACHA20_POLY1305: u32 = 3;
pub const EVP_HPKE_MAX_OVERHEAD: u32 = 64;
pub const HRSS_SAMPLE_BYTES: u32 = 700;
pub const HRSS_GENERATE_KEY_BYTES: u32 = 1432;
pub const HRSS_ENCAP_BYTES: u32 = 1400;
pub const HRSS_PUBLIC_KEY_BYTES: u32 = 1138;
pub const HRSS_CIPHERTEXT_BYTES: u32 = 1138;
pub const HRSS_KEY_BYTES: u32 = 32;
pub const HRSS_POLY3_BYTES: u32 = 140;
pub const HRSS_PRIVATE_KEY_BYTES: u32 = 1452;
pub const EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND: u32 = 0;
pub const EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY: u32 = 1;
pub const EVP_PKEY_HKDEF_MODE_EXPAND_ONLY: u32 = 2;
pub const MD4_CBLOCK: u32 = 64;
pub const MD4_DIGEST_LENGTH: u32 = 16;
pub const PKCS7_DETACHED: u32 = 64;
pub const PKCS7_BINARY: u32 = 128;
pub const PKCS7_NOATTR: u32 = 256;
pub const PKCS7_PARTIAL: u32 = 16384;
pub const PKCS7_TEXT: u32 = 1;
pub const PKCS7_NOCERTS: u32 = 2;
pub const PKCS7_NOSMIMECAP: u32 = 512;
pub const PKCS7_STREAM: u32 = 4096;
pub const PKCS7_NOSIGS: u32 = 4;
pub const PKCS7_NOCHAIN: u32 = 8;
pub const PKCS7_NOINTERN: u32 = 16;
pub const PKCS7_NOVERIFY: u32 = 32;
pub const PKCS7_R_BAD_PKCS7_VERSION: u32 = 100;
pub const PKCS7_R_NOT_PKCS7_SIGNED_DATA: u32 = 101;
pub const PKCS7_R_NO_CERTIFICATES_INCLUDED: u32 = 102;
pub const PKCS7_R_NO_CRLS_INCLUDED: u32 = 103;
pub const RSA_PKCS1_PADDING: u32 = 1;
pub const RSA_NO_PADDING: u32 = 3;
pub const RSA_PKCS1_OAEP_PADDING: u32 = 4;
pub const RSA_PKCS1_PSS_PADDING: u32 = 6;
pub const RSA_PSS_SALTLEN_DIGEST: i32 = -1;
pub const RSA_FLAG_OPAQUE: u32 = 1;
pub const RSA_FLAG_NO_BLINDING: u32 = 8;
pub const RSA_FLAG_EXT_PKEY: u32 = 32;
pub const RSA_FLAG_NO_PUBLIC_EXPONENT: u32 = 64;
pub const RSA_FLAG_LARGE_PUBLIC_EXPONENT: u32 = 128;
pub const RSA_3: u32 = 3;
pub const RSA_F4: u32 = 65537;
pub const RSA_METHOD_FLAG_NO_CHECK: u32 = 1;
pub const RSA_R_BAD_ENCODING: u32 = 100;
pub const RSA_R_BAD_E_VALUE: u32 = 101;
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT: u32 = 102;
pub const RSA_R_BAD_PAD_BYTE_COUNT: u32 = 103;
pub const RSA_R_BAD_RSA_PARAMETERS: u32 = 104;
pub const RSA_R_BAD_SIGNATURE: u32 = 105;
pub const RSA_R_BAD_VERSION: u32 = 106;
pub const RSA_R_BLOCK_TYPE_IS_NOT_01: u32 = 107;
pub const RSA_R_BN_NOT_INITIALIZED: u32 = 108;
pub const RSA_R_CANNOT_RECOVER_MULTI_PRIME_KEY: u32 = 109;
pub const RSA_R_CRT_PARAMS_ALREADY_GIVEN: u32 = 110;
pub const RSA_R_CRT_VALUES_INCORRECT: u32 = 111;
pub const RSA_R_DATA_LEN_NOT_EQUAL_TO_MOD_LEN: u32 = 112;
pub const RSA_R_DATA_TOO_LARGE: u32 = 113;
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE: u32 = 114;
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS: u32 = 115;
pub const RSA_R_DATA_TOO_SMALL: u32 = 116;
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE: u32 = 117;
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY: u32 = 118;
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1: u32 = 119;
pub const RSA_R_EMPTY_PUBLIC_KEY: u32 = 120;
pub const RSA_R_ENCODE_ERROR: u32 = 121;
pub const RSA_R_FIRST_OCTET_INVALID: u32 = 122;
pub const RSA_R_INCONSISTENT_SET_OF_CRT_VALUES: u32 = 123;
pub const RSA_R_INTERNAL_ERROR: u32 = 124;
pub const RSA_R_INVALID_MESSAGE_LENGTH: u32 = 125;
pub const RSA_R_KEY_SIZE_TOO_SMALL: u32 = 126;
pub const RSA_R_LAST_OCTET_INVALID: u32 = 127;
pub const RSA_R_MODULUS_TOO_LARGE: u32 = 128;
pub const RSA_R_MUST_HAVE_AT_LEAST_TWO_PRIMES: u32 = 129;
pub const RSA_R_NO_PUBLIC_EXPONENT: u32 = 130;
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING: u32 = 131;
pub const RSA_R_N_NOT_EQUAL_P_Q: u32 = 132;
pub const RSA_R_OAEP_DECODING_ERROR: u32 = 133;
pub const RSA_R_ONLY_ONE_OF_P_Q_GIVEN: u32 = 134;
pub const RSA_R_OUTPUT_BUFFER_TOO_SMALL: u32 = 135;
pub const RSA_R_PADDING_CHECK_FAILED: u32 = 136;
pub const RSA_R_PKCS_DECODING_ERROR: u32 = 137;
pub const RSA_R_SLEN_CHECK_FAILED: u32 = 138;
pub const RSA_R_SLEN_RECOVERY_FAILED: u32 = 139;
pub const RSA_R_TOO_LONG: u32 = 140;
pub const RSA_R_TOO_MANY_ITERATIONS: u32 = 141;
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE: u32 = 142;
pub const RSA_R_UNKNOWN_PADDING_TYPE: u32 = 143;
pub const RSA_R_VALUE_MISSING: u32 = 144;
pub const RSA_R_WRONG_SIGNATURE_LENGTH: u32 = 145;
pub const RSA_R_PUBLIC_KEY_VALIDATION_FAILED: u32 = 146;
pub const RSA_R_D_OUT_OF_RANGE: u32 = 147;
pub const RSA_R_BLOCK_TYPE_IS_NOT_02: u32 = 148;
pub const RSA_R_MISMATCHED_SIGNATURE: u32 = 248;
pub const RSA_F_RSA_OSSL_PRIVATE_ENCRYPT: u32 = 0;
pub const X509V3_R_BAD_IP_ADDRESS: u32 = 100;
pub const X509V3_R_BAD_OBJECT: u32 = 101;
pub const X509V3_R_BN_DEC2BN_ERROR: u32 = 102;
pub const X509V3_R_BN_TO_ASN1_INTEGER_ERROR: u32 = 103;
pub const X509V3_R_CANNOT_FIND_FREE_FUNCTION: u32 = 104;
pub const X509V3_R_DIRNAME_ERROR: u32 = 105;
pub const X509V3_R_DISTPOINT_ALREADY_SET: u32 = 106;
pub const X509V3_R_DUPLICATE_ZONE_ID: u32 = 107;
pub const X509V3_R_ERROR_CONVERTING_ZONE: u32 = 108;
pub const X509V3_R_ERROR_CREATING_EXTENSION: u32 = 109;
pub const X509V3_R_ERROR_IN_EXTENSION: u32 = 110;
pub const X509V3_R_EXPECTED_A_SECTION_NAME: u32 = 111;
pub const X509V3_R_EXTENSION_EXISTS: u32 = 112;
pub const X509V3_R_EXTENSION_NAME_ERROR: u32 = 113;
pub const X509V3_R_EXTENSION_NOT_FOUND: u32 = 114;
pub const X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED: u32 = 115;
pub const X509V3_R_EXTENSION_VALUE_ERROR: u32 = 116;
pub const X509V3_R_ILLEGAL_EMPTY_EXTENSION: u32 = 117;
pub const X509V3_R_ILLEGAL_HEX_DIGIT: u32 = 118;
pub const X509V3_R_INCORRECT_POLICY_SYNTAX_TAG: u32 = 119;
pub const X509V3_R_INVALID_BOOLEAN_STRING: u32 = 120;
pub const X509V3_R_INVALID_EXTENSION_STRING: u32 = 121;
pub const X509V3_R_INVALID_MULTIPLE_RDNS: u32 = 122;
pub const X509V3_R_INVALID_NAME: u32 = 123;
pub const X509V3_R_INVALID_NULL_ARGUMENT: u32 = 124;
pub const X509V3_R_INVALID_NULL_NAME: u32 = 125;
pub const X509V3_R_INVALID_NULL_VALUE: u32 = 126;
pub const X509V3_R_INVALID_NUMBER: u32 = 127;
pub const X509V3_R_INVALID_NUMBERS: u32 = 128;
pub const X509V3_R_INVALID_OBJECT_IDENTIFIER: u32 = 129;
pub const X509V3_R_INVALID_OPTION: u32 = 130;
pub const X509V3_R_INVALID_POLICY_IDENTIFIER: u32 = 131;
pub const X509V3_R_INVALID_PROXY_POLICY_SETTING: u32 = 132;
pub const X509V3_R_INVALID_PURPOSE: u32 = 133;
pub const X509V3_R_INVALID_SECTION: u32 = 134;
pub const X509V3_R_INVALID_SYNTAX: u32 = 135;
pub const X509V3_R_ISSUER_DECODE_ERROR: u32 = 136;
pub const X509V3_R_MISSING_VALUE: u32 = 137;
pub const X509V3_R_NEED_ORGANIZATION_AND_NUMBERS: u32 = 138;
pub const X509V3_R_NO_CONFIG_DATABASE: u32 = 139;
pub const X509V3_R_NO_ISSUER_CERTIFICATE: u32 = 140;
pub const X509V3_R_NO_ISSUER_DETAILS: u32 = 141;
pub const X509V3_R_NO_POLICY_IDENTIFIER: u32 = 142;
pub const X509V3_R_NO_PROXY_CERT_POLICY_LANGUAGE_DEFINED: u32 = 143;
pub const X509V3_R_NO_PUBLIC_KEY: u32 = 144;
pub const X509V3_R_NO_SUBJECT_DETAILS: u32 = 145;
pub const X509V3_R_ODD_NUMBER_OF_DIGITS: u32 = 146;
pub const X509V3_R_OPERATION_NOT_DEFINED: u32 = 147;
pub const X509V3_R_OTHERNAME_ERROR: u32 = 148;
pub const X509V3_R_POLICY_LANGUAGE_ALREADY_DEFINED: u32 = 149;
pub const X509V3_R_POLICY_PATH_LENGTH: u32 = 150;
pub const X509V3_R_POLICY_PATH_LENGTH_ALREADY_DEFINED: u32 = 151;
pub const X509V3_R_POLICY_WHEN_PROXY_LANGUAGE_REQUIRES_NO_POLICY: u32 = 152;
pub const X509V3_R_SECTION_NOT_FOUND: u32 = 153;
pub const X509V3_R_UNABLE_TO_GET_ISSUER_DETAILS: u32 = 154;
pub const X509V3_R_UNABLE_TO_GET_ISSUER_KEYID: u32 = 155;
pub const X509V3_R_UNKNOWN_BIT_STRING_ARGUMENT: u32 = 156;
pub const X509V3_R_UNKNOWN_EXTENSION: u32 = 157;
pub const X509V3_R_UNKNOWN_EXTENSION_NAME: u32 = 158;
pub const X509V3_R_UNKNOWN_OPTION: u32 = 159;
pub const X509V3_R_UNSUPPORTED_OPTION: u32 = 160;
pub const X509V3_R_UNSUPPORTED_TYPE: u32 = 161;
pub const X509V3_R_USER_TOO_LONG: u32 = 162;
pub const X509V3_R_INVALID_VALUE: u32 = 163;
pub const X509V3_R_TRAILING_DATA_IN_EXTENSION: u32 = 164;
pub const X509_VERSION_1: u32 = 0;
pub const X509_VERSION_2: u32 = 1;
pub const X509_VERSION_3: u32 = 2;
pub const EXFLAG_BCONS: u32 = 1;
pub const EXFLAG_KUSAGE: u32 = 2;
pub const EXFLAG_XKUSAGE: u32 = 4;
pub const EXFLAG_NSCERT: u32 = 8;
pub const EXFLAG_CA: u32 = 16;
pub const EXFLAG_SI: u32 = 32;
pub const EXFLAG_V1: u32 = 64;
pub const EXFLAG_INVALID: u32 = 128;
pub const EXFLAG_SET: u32 = 256;
pub const EXFLAG_CRITICAL: u32 = 512;
pub const EXFLAG_SS: u32 = 8192;
pub const X509v3_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const X509v3_KU_NON_REPUDIATION: u32 = 64;
pub const X509v3_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const X509v3_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const X509v3_KU_KEY_AGREEMENT: u32 = 8;
pub const X509v3_KU_KEY_CERT_SIGN: u32 = 4;
pub const X509v3_KU_CRL_SIGN: u32 = 2;
pub const X509v3_KU_ENCIPHER_ONLY: u32 = 1;
pub const X509v3_KU_DECIPHER_ONLY: u32 = 32768;
pub const XKU_SSL_SERVER: u32 = 1;
pub const XKU_SSL_CLIENT: u32 = 2;
pub const XKU_SMIME: u32 = 4;
pub const XKU_CODE_SIGN: u32 = 8;
pub const XKU_SGC: u32 = 16;
pub const XKU_OCSP_SIGN: u32 = 32;
pub const XKU_TIMESTAMP: u32 = 64;
pub const XKU_DVCS: u32 = 128;
pub const XKU_ANYEKU: u32 = 256;
pub const X509_SIG_INFO_VALID: u32 = 1;
pub const X509_SIG_INFO_TLS: u32 = 2;
pub const X509_CRL_VERSION_1: u32 = 0;
pub const X509_CRL_VERSION_2: u32 = 1;
pub const X509_REQ_VERSION_1: u32 = 0;
pub const GEN_OTHERNAME: u32 = 0;
pub const GEN_EMAIL: u32 = 1;
pub const GEN_DNS: u32 = 2;
pub const GEN_X400: u32 = 3;
pub const GEN_DIRNAME: u32 = 4;
pub const GEN_EDIPARTY: u32 = 5;
pub const GEN_URI: u32 = 6;
pub const GEN_IPADD: u32 = 7;
pub const GEN_RID: u32 = 8;
pub const X509_FLAG_COMPAT: u32 = 0;
pub const X509_FLAG_NO_HEADER: u32 = 1;
pub const X509_FLAG_NO_VERSION: u32 = 2;
pub const X509_FLAG_NO_SERIAL: u32 = 4;
pub const X509_FLAG_NO_SIGNAME: u32 = 8;
pub const X509_FLAG_NO_ISSUER: u32 = 16;
pub const X509_FLAG_NO_VALIDITY: u32 = 32;
pub const X509_FLAG_NO_SUBJECT: u32 = 64;
pub const X509_FLAG_NO_PUBKEY: u32 = 128;
pub const X509_FLAG_NO_EXTENSIONS: u32 = 256;
pub const X509_FLAG_NO_SIGDUMP: u32 = 512;
pub const X509_FLAG_NO_AUX: u32 = 1024;
pub const X509_FLAG_NO_ATTRIBUTES: u32 = 2048;
pub const X509_FLAG_NO_IDS: u32 = 4096;
pub const X509V3_EXT_UNKNOWN_MASK: u32 = 983040;
pub const X509V3_EXT_DEFAULT: u32 = 0;
pub const X509V3_EXT_ERROR_UNKNOWN: u32 = 65536;
pub const X509V3_EXT_PARSE_UNKNOWN: u32 = 131072;
pub const X509V3_EXT_DUMP_UNKNOWN: u32 = 196608;
pub const XN_FLAG_COMPAT: u32 = 0;
pub const XN_FLAG_SEP_MASK: u32 = 983040;
pub const XN_FLAG_SEP_COMMA_PLUS: u32 = 65536;
pub const XN_FLAG_SEP_CPLUS_SPC: u32 = 131072;
pub const XN_FLAG_SEP_SPLUS_SPC: u32 = 196608;
pub const XN_FLAG_SEP_MULTILINE: u32 = 262144;
pub const XN_FLAG_DN_REV: u32 = 1048576;
pub const XN_FLAG_FN_MASK: u32 = 6291456;
pub const XN_FLAG_FN_SN: u32 = 0;
pub const XN_FLAG_FN_LN: u32 = 2097152;
pub const XN_FLAG_FN_OID: u32 = 4194304;
pub const XN_FLAG_FN_NONE: u32 = 6291456;
pub const XN_FLAG_SPC_EQ: u32 = 8388608;
pub const XN_FLAG_DUMP_UNKNOWN_FIELDS: u32 = 16777216;
pub const XN_FLAG_FN_ALIGN: u32 = 33554432;
pub const XN_FLAG_RFC2253: u32 = 17892119;
pub const XN_FLAG_ONELINE: u32 = 8520479;
pub const XN_FLAG_MULTILINE: u32 = 44302342;
pub const X509V3_CTX_TEST: u32 = 1;
pub const X509_TRUST_DEFAULT: i32 = -1;
pub const X509_TRUST_COMPAT: u32 = 1;
pub const X509_TRUST_SSL_CLIENT: u32 = 2;
pub const X509_TRUST_SSL_SERVER: u32 = 3;
pub const X509_TRUST_EMAIL: u32 = 4;
pub const X509_TRUST_OBJECT_SIGN: u32 = 5;
pub const X509_TRUST_TSA: u32 = 8;
pub const X509_TRUST_TRUSTED: u32 = 1;
pub const X509_TRUST_REJECTED: u32 = 2;
pub const X509_TRUST_UNTRUSTED: u32 = 3;
pub const X509_LU_NONE: u32 = 0;
pub const X509_LU_X509: u32 = 1;
pub const X509_LU_CRL: u32 = 2;
pub const X509_LU_PKEY: u32 = 3;
pub const X509_L_FILE_LOAD: u32 = 1;
pub const X509_L_ADD_DIR: u32 = 2;
pub const X509_FILETYPE_PEM: u32 = 1;
pub const X509_FILETYPE_ASN1: u32 = 2;
pub const X509_FILETYPE_DEFAULT: u32 = 3;
pub const X509_V_OK: u32 = 0;
pub const X509_V_ERR_UNSPECIFIED: u32 = 1;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: u32 = 2;
pub const X509_V_ERR_UNABLE_TO_GET_CRL: u32 = 3;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: u32 = 4;
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: u32 = 5;
pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: u32 = 6;
pub const X509_V_ERR_CERT_SIGNATURE_FAILURE: u32 = 7;
pub const X509_V_ERR_CRL_SIGNATURE_FAILURE: u32 = 8;
pub const X509_V_ERR_CERT_NOT_YET_VALID: u32 = 9;
pub const X509_V_ERR_CERT_HAS_EXPIRED: u32 = 10;
pub const X509_V_ERR_CRL_NOT_YET_VALID: u32 = 11;
pub const X509_V_ERR_CRL_HAS_EXPIRED: u32 = 12;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: u32 = 13;
pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: u32 = 14;
pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: u32 = 15;
pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: u32 = 16;
pub const X509_V_ERR_OUT_OF_MEM: u32 = 17;
pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: u32 = 18;
pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: u32 = 19;
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: u32 = 20;
pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: u32 = 21;
pub const X509_V_ERR_CERT_CHAIN_TOO_LONG: u32 = 22;
pub const X509_V_ERR_CERT_REVOKED: u32 = 23;
pub const X509_V_ERR_INVALID_CA: u32 = 24;
pub const X509_V_ERR_PATH_LENGTH_EXCEEDED: u32 = 25;
pub const X509_V_ERR_INVALID_PURPOSE: u32 = 26;
pub const X509_V_ERR_CERT_UNTRUSTED: u32 = 27;
pub const X509_V_ERR_CERT_REJECTED: u32 = 28;
pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH: u32 = 29;
pub const X509_V_ERR_AKID_SKID_MISMATCH: u32 = 30;
pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: u32 = 31;
pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN: u32 = 32;
pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER: u32 = 33;
pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION: u32 = 34;
pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN: u32 = 35;
pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: u32 = 36;
pub const X509_V_ERR_INVALID_NON_CA: u32 = 37;
pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED: u32 = 38;
pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: u32 = 39;
pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED: u32 = 40;
pub const X509_V_ERR_INVALID_EXTENSION: u32 = 41;
pub const X509_V_ERR_INVALID_POLICY_EXTENSION: u32 = 42;
pub const X509_V_ERR_NO_EXPLICIT_POLICY: u32 = 43;
pub const X509_V_ERR_DIFFERENT_CRL_SCOPE: u32 = 44;
pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE: u32 = 45;
pub const X509_V_ERR_UNNESTED_RESOURCE: u32 = 46;
pub const X509_V_ERR_PERMITTED_VIOLATION: u32 = 47;
pub const X509_V_ERR_EXCLUDED_VIOLATION: u32 = 48;
pub const X509_V_ERR_SUBTREE_MINMAX: u32 = 49;
pub const X509_V_ERR_APPLICATION_VERIFICATION: u32 = 50;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE: u32 = 51;
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: u32 = 52;
pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX: u32 = 53;
pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR: u32 = 54;
pub const X509_V_ERR_HOSTNAME_MISMATCH: u32 = 62;
pub const X509_V_ERR_EMAIL_MISMATCH: u32 = 63;
pub const X509_V_ERR_IP_ADDRESS_MISMATCH: u32 = 64;
pub const X509_V_ERR_INVALID_CALL: u32 = 65;
pub const X509_V_ERR_STORE_LOOKUP: u32 = 66;
pub const X509_V_ERR_NAME_CONSTRAINTS_WITHOUT_SANS: u32 = 67;
pub const X509_V_FLAG_CB_ISSUER_CHECK: u32 = 1;
pub const X509_V_FLAG_USE_CHECK_TIME: u32 = 2;
pub const X509_V_FLAG_CRL_CHECK: u32 = 4;
pub const X509_V_FLAG_CRL_CHECK_ALL: u32 = 8;
pub const X509_V_FLAG_IGNORE_CRITICAL: u32 = 16;
pub const X509_V_FLAG_X509_STRICT: u32 = 0;
pub const X509_V_FLAG_ALLOW_PROXY_CERTS: u32 = 64;
pub const X509_V_FLAG_POLICY_CHECK: u32 = 128;
pub const X509_V_FLAG_EXPLICIT_POLICY: u32 = 256;
pub const X509_V_FLAG_INHIBIT_ANY: u32 = 512;
pub const X509_V_FLAG_INHIBIT_MAP: u32 = 1024;
pub const X509_V_FLAG_NOTIFY_POLICY: u32 = 2048;
pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT: u32 = 4096;
pub const X509_V_FLAG_USE_DELTAS: u32 = 8192;
pub const X509_V_FLAG_CHECK_SS_SIGNATURE: u32 = 16384;
pub const X509_V_FLAG_TRUSTED_FIRST: u32 = 32768;
pub const X509_V_FLAG_PARTIAL_CHAIN: u32 = 524288;
pub const X509_V_FLAG_NO_ALT_CHAINS: u32 = 1048576;
pub const X509_V_FLAG_NO_CHECK_TIME: u32 = 2097152;
pub const X509_V_FLAG_POLICY_MASK: u32 = 1920;
pub const X509V3_EXT_CTX_DEP: u32 = 2;
pub const X509V3_EXT_MULTILINE: u32 = 4;
pub const CRLDP_ALL_REASONS: u32 = 32895;
pub const NS_SSL_CLIENT: u32 = 128;
pub const NS_SSL_SERVER: u32 = 64;
pub const NS_SMIME: u32 = 32;
pub const NS_OBJSIGN: u32 = 16;
pub const NS_SSL_CA: u32 = 4;
pub const NS_SMIME_CA: u32 = 2;
pub const NS_OBJSIGN_CA: u32 = 1;
pub const NS_ANY_CA: u32 = 7;
pub const X509_PURPOSE_SSL_CLIENT: u32 = 1;
pub const X509_PURPOSE_SSL_SERVER: u32 = 2;
pub const X509_PURPOSE_NS_SSL_SERVER: u32 = 3;
pub const X509_PURPOSE_SMIME_SIGN: u32 = 4;
pub const X509_PURPOSE_SMIME_ENCRYPT: u32 = 5;
pub const X509_PURPOSE_CRL_SIGN: u32 = 6;
pub const X509_PURPOSE_ANY: u32 = 7;
pub const X509_PURPOSE_OCSP_HELPER: u32 = 8;
pub const X509_PURPOSE_TIMESTAMP_SIGN: u32 = 9;
pub const X509V3_ADD_OP_MASK: u32 = 15;
pub const X509V3_ADD_DEFAULT: u32 = 0;
pub const X509V3_ADD_APPEND: u32 = 1;
pub const X509V3_ADD_REPLACE: u32 = 2;
pub const X509V3_ADD_REPLACE_EXISTING: u32 = 3;
pub const X509V3_ADD_KEEP_EXISTING: u32 = 4;
pub const X509V3_ADD_DELETE: u32 = 5;
pub const X509V3_ADD_SILENT: u32 = 16;
pub const X509_CHECK_FLAG_NO_WILDCARDS: u32 = 2;
pub const X509_CHECK_FLAG_NEVER_CHECK_SUBJECT: u32 = 32;
pub const X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS: u32 = 0;
pub const X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT: u32 = 0;
pub const X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS: u32 = 0;
pub const X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS: u32 = 0;
pub const X509_R_AKID_MISMATCH: u32 = 100;
pub const X509_R_BAD_PKCS7_VERSION: u32 = 101;
pub const X509_R_BAD_X509_FILETYPE: u32 = 102;
pub const X509_R_BASE64_DECODE_ERROR: u32 = 103;
pub const X509_R_CANT_CHECK_DH_KEY: u32 = 104;
pub const X509_R_CERT_ALREADY_IN_HASH_TABLE: u32 = 105;
pub const X509_R_CRL_ALREADY_DELTA: u32 = 106;
pub const X509_R_CRL_VERIFY_FAILURE: u32 = 107;
pub const X509_R_IDP_MISMATCH: u32 = 108;
pub const X509_R_INVALID_BIT_STRING_BITS_LEFT: u32 = 109;
pub const X509_R_INVALID_DIRECTORY: u32 = 110;
pub const X509_R_INVALID_FIELD_NAME: u32 = 111;
pub const X509_R_INVALID_PSS_PARAMETERS: u32 = 112;
pub const X509_R_INVALID_TRUST: u32 = 113;
pub const X509_R_ISSUER_MISMATCH: u32 = 114;
pub const X509_R_KEY_TYPE_MISMATCH: u32 = 115;
pub const X509_R_KEY_VALUES_MISMATCH: u32 = 116;
pub const X509_R_LOADING_CERT_DIR: u32 = 117;
pub const X509_R_LOADING_DEFAULTS: u32 = 118;
pub const X509_R_NEWER_CRL_NOT_NEWER: u32 = 119;
pub const X509_R_NOT_PKCS7_SIGNED_DATA: u32 = 120;
pub const X509_R_NO_CERTIFICATES_INCLUDED: u32 = 121;
pub const X509_R_NO_CERT_SET_FOR_US_TO_VERIFY: u32 = 122;
pub const X509_R_NO_CRLS_INCLUDED: u32 = 123;
pub const X509_R_NO_CRL_NUMBER: u32 = 124;
pub const X509_R_PUBLIC_KEY_DECODE_ERROR: u32 = 125;
pub const X509_R_PUBLIC_KEY_ENCODE_ERROR: u32 = 126;
pub const X509_R_SHOULD_RETRY: u32 = 127;
pub const X509_R_UNKNOWN_KEY_TYPE: u32 = 128;
pub const X509_R_UNKNOWN_NID: u32 = 129;
pub const X509_R_UNKNOWN_PURPOSE_ID: u32 = 130;
pub const X509_R_UNKNOWN_TRUST_ID: u32 = 131;
pub const X509_R_UNSUPPORTED_ALGORITHM: u32 = 132;
pub const X509_R_WRONG_LOOKUP_TYPE: u32 = 133;
pub const X509_R_WRONG_TYPE: u32 = 134;
pub const X509_R_NAME_TOO_LONG: u32 = 135;
pub const X509_R_INVALID_PARAMETER: u32 = 136;
pub const X509_R_SIGNATURE_ALGORITHM_MISMATCH: u32 = 137;
pub const X509_R_DELTA_CRL_WITHOUT_CRL_NUMBER: u32 = 138;
pub const X509_R_INVALID_FIELD_FOR_VERSION: u32 = 139;
pub const X509_R_INVALID_VERSION: u32 = 140;
pub const X509_R_NO_CERTIFICATE_FOUND: u32 = 141;
pub const X509_R_NO_CERTIFICATE_OR_CRL_FOUND: u32 = 142;
pub const X509_R_NO_CRL_FOUND: u32 = 143;
pub const X509_R_INVALID_POLICY_EXTENSION: u32 = 144;
pub const X509_R_UNKNOWN_SIGID_ALGS: u32 = 145;
pub const CRL_REASON_NONE: i32 = -1;
pub const CRL_REASON_UNSPECIFIED: u32 = 0;
pub const CRL_REASON_KEY_COMPROMISE: u32 = 1;
pub const CRL_REASON_CA_COMPROMISE: u32 = 2;
pub const CRL_REASON_AFFILIATION_CHANGED: u32 = 3;
pub const CRL_REASON_SUPERSEDED: u32 = 4;
pub const CRL_REASON_CESSATION_OF_OPERATION: u32 = 5;
pub const CRL_REASON_CERTIFICATE_HOLD: u32 = 6;
pub const CRL_REASON_REMOVE_FROM_CRL: u32 = 8;
pub const CRL_REASON_PRIVILEGE_WITHDRAWN: u32 = 9;
pub const CRL_REASON_AA_COMPROMISE: u32 = 10;
pub const KU_DIGITAL_SIGNATURE: u32 = 128;
pub const KU_NON_REPUDIATION: u32 = 64;
pub const KU_KEY_ENCIPHERMENT: u32 = 32;
pub const KU_DATA_ENCIPHERMENT: u32 = 16;
pub const KU_KEY_AGREEMENT: u32 = 8;
pub const KU_KEY_CERT_SIGN: u32 = 4;
pub const KU_CRL_SIGN: u32 = 2;
pub const KU_ENCIPHER_ONLY: u32 = 1;
pub const KU_DECIPHER_ONLY: u32 = 32768;
pub const OCSP_NOCERTS: u32 = 1;
pub const OCSP_NOINTERN: u32 = 2;
pub const OCSP_NOCHAIN: u32 = 8;
pub const OCSP_NOVERIFY: u32 = 16;
pub const OCSP_NOEXPLICIT: u32 = 32;
pub const OCSP_TRUSTOTHER: u32 = 512;
pub const OCSP_RESPONSE_STATUS_SUCCESSFUL: u32 = 0;
pub const OCSP_RESPONSE_STATUS_MALFORMEDREQUEST: u32 = 1;
pub const OCSP_RESPONSE_STATUS_INTERNALERROR: u32 = 2;
pub const OCSP_RESPONSE_STATUS_TRYLATER: u32 = 3;
pub const OCSP_RESPONSE_STATUS_SIGREQUIRED: u32 = 5;
pub const OCSP_RESPONSE_STATUS_UNAUTHORIZED: u32 = 6;
pub const V_OCSP_RESPID_NAME: u32 = 0;
pub const V_OCSP_RESPID_KEY: u32 = 1;
pub const V_OCSP_CERTSTATUS_GOOD: u32 = 0;
pub const V_OCSP_CERTSTATUS_REVOKED: u32 = 1;
pub const V_OCSP_CERTSTATUS_UNKNOWN: u32 = 2;
pub const OCSP_NONCE_EQUAL: u32 = 1;
pub const OCSP_NONCE_BOTH_ABSENT: u32 = 2;
pub const OCSP_NONCE_RESPONSE_ONLY: u32 = 3;
pub const OCSP_NONCE_NOT_EQUAL: u32 = 0;
pub const OCSP_NONCE_REQUEST_ONLY: i32 = -1;
pub const OCSP_R_CERTIFICATE_VERIFY_ERROR: u32 = 101;
pub const OCSP_R_DIGEST_ERR: u32 = 102;
pub const OCSP_R_MISSING_OCSPSIGNING_USAGE: u32 = 103;
pub const OCSP_R_NOT_BASIC_RESPONSE: u32 = 104;
pub const OCSP_R_NO_CERTIFICATES_IN_CHAIN: u32 = 105;
pub const OCSP_R_NO_RESPONSE_DATA: u32 = 108;
pub const OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE: u32 = 110;
pub const OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA: u32 = 111;
pub const OCSP_R_ROOT_CA_NOT_TRUSTED: u32 = 112;
pub const OCSP_R_SERVER_RESPONSE_PARSE_ERROR: u32 = 115;
pub const OCSP_R_SIGNATURE_FAILURE: u32 = 117;
pub const OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND: u32 = 118;
pub const OCSP_R_UNKNOWN_MESSAGE_DIGEST: u32 = 119;
pub const OCSP_R_UNKNOWN_NID: u32 = 120;
pub const OCSP_R_ERROR_PARSING_URL: u32 = 121;
pub const OCSP_R_ERROR_IN_NEXTUPDATE_FIELD: u32 = 122;
pub const OCSP_R_ERROR_IN_THISUPDATE_FIELD: u32 = 123;
pub const OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE: u32 = 124;
pub const OCSP_R_STATUS_EXPIRED: u32 = 125;
pub const OCSP_R_STATUS_NOT_YET_VALID: u32 = 126;
pub const OCSP_R_STATUS_TOO_OLD: u32 = 127;
pub const OCSP_R_NO_SIGNER_KEY: u32 = 130;
pub const OCSP_R_OCSP_REQUEST_DUPLICATE_SIGNATURE: u32 = 131;
pub const PEM_BUFSIZE: u32 = 1024;
pub const PEM_STRING_X509_OLD: &[u8; 17] = b"X509 CERTIFICATE\0";
pub const PEM_STRING_X509: &[u8; 12] = b"CERTIFICATE\0";
pub const PEM_STRING_X509_PAIR: &[u8; 17] = b"CERTIFICATE PAIR\0";
pub const PEM_STRING_X509_TRUSTED: &[u8; 20] = b"TRUSTED CERTIFICATE\0";
pub const PEM_STRING_X509_REQ_OLD: &[u8; 24] = b"NEW CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_REQ: &[u8; 20] = b"CERTIFICATE REQUEST\0";
pub const PEM_STRING_X509_CRL: &[u8; 9] = b"X509 CRL\0";
pub const PEM_STRING_EVP_PKEY: &[u8; 16] = b"ANY PRIVATE KEY\0";
pub const PEM_STRING_PUBLIC: &[u8; 11] = b"PUBLIC KEY\0";
pub const PEM_STRING_RSA: &[u8; 16] = b"RSA PRIVATE KEY\0";
pub const PEM_STRING_RSA_PUBLIC: &[u8; 15] = b"RSA PUBLIC KEY\0";
pub const PEM_STRING_DSA: &[u8; 16] = b"DSA PRIVATE KEY\0";
pub const PEM_STRING_DSA_PUBLIC: &[u8; 15] = b"DSA PUBLIC KEY\0";
pub const PEM_STRING_EC: &[u8; 15] = b"EC PRIVATE KEY\0";
pub const PEM_STRING_PKCS7: &[u8; 6] = b"PKCS7\0";
pub const PEM_STRING_PKCS7_SIGNED: &[u8; 20] = b"PKCS #7 SIGNED DATA\0";
pub const PEM_STRING_PKCS8: &[u8; 22] = b"ENCRYPTED PRIVATE KEY\0";
pub const PEM_STRING_PKCS8INF: &[u8; 12] = b"PRIVATE KEY\0";
pub const PEM_STRING_DHPARAMS: &[u8; 14] = b"DH PARAMETERS\0";
pub const PEM_STRING_SSL_SESSION: &[u8; 23] = b"SSL SESSION PARAMETERS\0";
pub const PEM_STRING_DSAPARAMS: &[u8; 15] = b"DSA PARAMETERS\0";
pub const PEM_STRING_ECDSA_PUBLIC: &[u8; 17] = b"ECDSA PUBLIC KEY\0";
pub const PEM_STRING_ECPARAMETERS: &[u8; 14] = b"EC PARAMETERS\0";
pub const PEM_STRING_ECPRIVATEKEY: &[u8; 15] = b"EC PRIVATE KEY\0";
pub const PEM_STRING_CMS: &[u8; 4] = b"CMS\0";
pub const PEM_TYPE_ENCRYPTED: u32 = 10;
pub const PEM_TYPE_MIC_ONLY: u32 = 20;
pub const PEM_TYPE_MIC_CLEAR: u32 = 30;
pub const PEM_TYPE_CLEAR: u32 = 40;
pub const PEM_R_BAD_BASE64_DECODE: u32 = 100;
pub const PEM_R_BAD_DECRYPT: u32 = 101;
pub const PEM_R_BAD_END_LINE: u32 = 102;
pub const PEM_R_BAD_IV_CHARS: u32 = 103;
pub const PEM_R_BAD_PASSWORD_READ: u32 = 104;
pub const PEM_R_CIPHER_IS_NULL: u32 = 105;
pub const PEM_R_ERROR_CONVERTING_PRIVATE_KEY: u32 = 106;
pub const PEM_R_NOT_DEK_INFO: u32 = 107;
pub const PEM_R_NOT_ENCRYPTED: u32 = 108;
pub const PEM_R_NOT_PROC_TYPE: u32 = 109;
pub const PEM_R_NO_START_LINE: u32 = 110;
pub const PEM_R_READ_KEY: u32 = 111;
pub const PEM_R_SHORT_HEADER: u32 = 112;
pub const PEM_R_UNSUPPORTED_CIPHER: u32 = 113;
pub const PEM_R_UNSUPPORTED_ENCRYPTION: u32 = 114;
pub const PEM_R_PROBLEMS_GETTING_PASSWORD: u32 = 115;
pub const PKCS12_DEFAULT_ITER: u32 = 2048;
pub const PKCS8_R_BAD_PKCS12_DATA: u32 = 100;
pub const PKCS8_R_BAD_PKCS12_VERSION: u32 = 101;
pub const PKCS8_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER: u32 = 102;
pub const PKCS8_R_CRYPT_ERROR: u32 = 103;
pub const PKCS8_R_DECODE_ERROR: u32 = 104;
pub const PKCS8_R_ENCODE_ERROR: u32 = 105;
pub const PKCS8_R_ENCRYPT_ERROR: u32 = 106;
pub const PKCS8_R_ERROR_SETTING_CIPHER_PARAMS: u32 = 107;
pub const PKCS8_R_INCORRECT_PASSWORD: u32 = 108;
pub const PKCS8_R_KEYGEN_FAILURE: u32 = 109;
pub const PKCS8_R_KEY_GEN_ERROR: u32 = 110;
pub const PKCS8_R_METHOD_NOT_SUPPORTED: u32 = 111;
pub const PKCS8_R_MISSING_MAC: u32 = 112;
pub const PKCS8_R_MULTIPLE_PRIVATE_KEYS_IN_PKCS12: u32 = 113;
pub const PKCS8_R_PKCS12_PUBLIC_KEY_INTEGRITY_NOT_SUPPORTED: u32 = 114;
pub const PKCS8_R_PKCS12_TOO_DEEPLY_NESTED: u32 = 115;
pub const PKCS8_R_PRIVATE_KEY_DECODE_ERROR: u32 = 116;
pub const PKCS8_R_PRIVATE_KEY_ENCODE_ERROR: u32 = 117;
pub const PKCS8_R_TOO_LONG: u32 = 118;
pub const PKCS8_R_UNKNOWN_ALGORITHM: u32 = 119;
pub const PKCS8_R_UNKNOWN_CIPHER: u32 = 120;
pub const PKCS8_R_UNKNOWN_CIPHER_ALGORITHM: u32 = 121;
pub const PKCS8_R_UNKNOWN_DIGEST: u32 = 122;
pub const PKCS8_R_UNKNOWN_HASH: u32 = 123;
pub const PKCS8_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM: u32 = 124;
pub const PKCS8_R_UNSUPPORTED_KEYLENGTH: u32 = 125;
pub const PKCS8_R_UNSUPPORTED_SALT_TYPE: u32 = 126;
pub const PKCS8_R_UNSUPPORTED_CIPHER: u32 = 127;
pub const PKCS8_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION: u32 = 128;
pub const PKCS8_R_BAD_ITERATION_COUNT: u32 = 129;
pub const PKCS8_R_UNSUPPORTED_PRF: u32 = 130;
pub const PKCS8_R_INVALID_CHARACTERS: u32 = 131;
pub const PKCS8_R_UNSUPPORTED_OPTIONS: u32 = 132;
pub const PKCS8_R_AMBIGUOUS_FRIENDLY_NAME: u32 = 133;
pub const PKCS12_R_MAC_VERIFY_FAILURE: u32 = 108;
pub const RIPEMD160_CBLOCK: u32 = 64;
pub const RIPEMD160_LBLOCK: u32 = 16;
pub const RIPEMD160_DIGEST_LENGTH: u32 = 20;
pub const AWSLC_MODE_STRING: &[u8; 8] = b"AWS-LC \0";
pub const AWSLC_VERSION_STRING: &[u8; 14] = b"AWS-LC 1.32.0\0";
pub const EVP_KDF_SSHKDF_TYPE_INITIAL_IV_CLI_TO_SRV: u32 = 65;
pub const EVP_KDF_SSHKDF_TYPE_INITIAL_IV_SRV_TO_CLI: u32 = 66;
pub const EVP_KDF_SSHKDF_TYPE_ENCRYPTION_KEY_CLI_TO_SRV: u32 = 67;
pub const EVP_KDF_SSHKDF_TYPE_ENCRYPTION_KEY_SRV_TO_CLI: u32 = 68;
pub const EVP_KDF_SSHKDF_TYPE_INTEGRITY_KEY_CLI_TO_SRV: u32 = 69;
pub const EVP_KDF_SSHKDF_TYPE_INTEGRITY_KEY_SRV_TO_CLI: u32 = 70;
pub const SSL2_MT_CLIENT_HELLO: u32 = 1;
pub const SSL2_VERSION: u32 = 2;
pub const SSL3_CK_SCSV: u32 = 50331903;
pub const SSL3_CK_FALLBACK_SCSV: u32 = 50353664;
pub const SSL3_CK_RSA_NULL_MD5: u32 = 50331649;
pub const SSL3_CK_RSA_NULL_SHA: u32 = 50331650;
pub const SSL3_CK_RSA_RC4_40_MD5: u32 = 50331651;
pub const SSL3_CK_RSA_RC4_128_MD5: u32 = 50331652;
pub const SSL3_CK_RSA_RC4_128_SHA: u32 = 50331653;
pub const SSL3_CK_RSA_RC2_40_MD5: u32 = 50331654;
pub const SSL3_CK_RSA_IDEA_128_SHA: u32 = 50331655;
pub const SSL3_CK_RSA_DES_40_CBC_SHA: u32 = 50331656;
pub const SSL3_CK_RSA_DES_64_CBC_SHA: u32 = 50331657;
pub const SSL3_CK_RSA_DES_192_CBC3_SHA: u32 = 50331658;
pub const SSL3_CK_DH_DSS_DES_40_CBC_SHA: u32 = 50331659;
pub const SSL3_CK_DH_DSS_DES_64_CBC_SHA: u32 = 50331660;
pub const SSL3_CK_DH_DSS_DES_192_CBC3_SHA: u32 = 50331661;
pub const SSL3_CK_DH_RSA_DES_40_CBC_SHA: u32 = 50331662;
pub const SSL3_CK_DH_RSA_DES_64_CBC_SHA: u32 = 50331663;
pub const SSL3_CK_DH_RSA_DES_192_CBC3_SHA: u32 = 50331664;
pub const SSL3_CK_EDH_DSS_DES_40_CBC_SHA: u32 = 50331665;
pub const SSL3_CK_EDH_DSS_DES_64_CBC_SHA: u32 = 50331666;
pub const SSL3_CK_EDH_DSS_DES_192_CBC3_SHA: u32 = 50331667;
pub const SSL3_CK_EDH_RSA_DES_40_CBC_SHA: u32 = 50331668;
pub const SSL3_CK_EDH_RSA_DES_64_CBC_SHA: u32 = 50331669;
pub const SSL3_CK_EDH_RSA_DES_192_CBC3_SHA: u32 = 50331670;
pub const SSL3_CK_ADH_RC4_40_MD5: u32 = 50331671;
pub const SSL3_CK_ADH_RC4_128_MD5: u32 = 50331672;
pub const SSL3_CK_ADH_DES_40_CBC_SHA: u32 = 50331673;
pub const SSL3_CK_ADH_DES_64_CBC_SHA: u32 = 50331674;
pub const SSL3_CK_ADH_DES_192_CBC_SHA: u32 = 50331675;
pub const SSL3_TXT_RSA_NULL_MD5: &[u8; 9] = b"NULL-MD5\0";
pub const SSL3_TXT_RSA_NULL_SHA: &[u8; 9] = b"NULL-SHA\0";
pub const SSL3_TXT_RSA_RC4_40_MD5: &[u8; 12] = b"EXP-RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_MD5: &[u8; 8] = b"RC4-MD5\0";
pub const SSL3_TXT_RSA_RC4_128_SHA: &[u8; 8] = b"RC4-SHA\0";
pub const SSL3_TXT_RSA_RC2_40_MD5: &[u8; 16] = b"EXP-RC2-CBC-MD5\0";
pub const SSL3_TXT_RSA_IDEA_128_SHA: &[u8; 13] = b"IDEA-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_40_CBC_SHA: &[u8; 16] = b"EXP-DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_64_CBC_SHA: &[u8; 12] = b"DES-CBC-SHA\0";
pub const SSL3_TXT_RSA_DES_192_CBC3_SHA: &[u8; 13] = b"DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_40_CBC_SHA: &[u8; 23] = b"EXP-DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_64_CBC_SHA: &[u8; 19] = b"DH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_DSS_DES_192_CBC3_SHA: &[u8; 20] = b"DH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_40_CBC_SHA: &[u8; 23] = b"EXP-DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_64_CBC_SHA: &[u8; 19] = b"DH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_DH_RSA_DES_192_CBC3_SHA: &[u8; 20] = b"DH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_40_CBC_SHA: &[u8; 24] = b"EXP-EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_64_CBC_SHA: &[u8; 20] = b"EDH-DSS-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA: &[u8; 21] = b"EDH-DSS-DES-CBC3-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_40_CBC_SHA: &[u8; 24] = b"EXP-EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_64_CBC_SHA: &[u8; 20] = b"EDH-RSA-DES-CBC-SHA\0";
pub const SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA: &[u8; 21] = b"EDH-RSA-DES-CBC3-SHA\0";
pub const SSL3_TXT_ADH_RC4_40_MD5: &[u8; 16] = b"EXP-ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_RC4_128_MD5: &[u8; 12] = b"ADH-RC4-MD5\0";
pub const SSL3_TXT_ADH_DES_40_CBC_SHA: &[u8; 20] = b"EXP-ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_64_CBC_SHA: &[u8; 16] = b"ADH-DES-CBC-SHA\0";
pub const SSL3_TXT_ADH_DES_192_CBC_SHA: &[u8; 17] = b"ADH-DES-CBC3-SHA\0";
pub const SSL3_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL3_MASTER_SECRET_SIZE: u32 = 48;
pub const SSL3_RANDOM_SIZE: u32 = 32;
pub const SSL3_SESSION_ID_SIZE: u32 = 32;
pub const SSL3_RT_HEADER_LENGTH: u32 = 5;
pub const SSL3_HM_HEADER_LENGTH: u32 = 4;
pub const SSL3_ALIGN_PAYLOAD: u32 = 8;
pub const SSL3_RT_MAX_MD_SIZE: u32 = 64;
pub const SSL_RT_MAX_CIPHER_BLOCK_SIZE: u32 = 16;
pub const SSL3_RT_MAX_PLAIN_LENGTH: u32 = 16384;
pub const SSL3_RT_MAX_COMPRESSED_OVERHEAD: u32 = 1024;
pub const SSL3_RT_MAX_ENCRYPTED_OVERHEAD: u32 = 320;
pub const SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD: u32 = 88;
pub const SSL3_RT_MAX_COMPRESSED_LENGTH: u32 = 16384;
pub const SSL3_RT_MAX_ENCRYPTED_LENGTH: u32 = 16704;
pub const SSL3_RT_MAX_PACKET_SIZE: u32 = 16709;
pub const SSL3_MD_CLIENT_FINISHED_CONST: &[u8; 5] = b"CLNT\0";
pub const SSL3_MD_SERVER_FINISHED_CONST: &[u8; 5] = b"SRVR\0";
pub const SSL3_RT_CHANGE_CIPHER_SPEC: u32 = 20;
pub const SSL3_RT_ALERT: u32 = 21;
pub const SSL3_RT_HANDSHAKE: u32 = 22;
pub const SSL3_RT_APPLICATION_DATA: u32 = 23;
pub const SSL3_RT_HEADER: u32 = 256;
pub const SSL3_RT_CLIENT_HELLO_INNER: u32 = 257;
pub const SSL3_AL_WARNING: u32 = 1;
pub const SSL3_AL_FATAL: u32 = 2;
pub const SSL3_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL3_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL3_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL3_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL3_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL3_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL3_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL3_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL3_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL3_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL3_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL3_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL3_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const SSL3_CT_RSA_SIGN: u32 = 1;
pub const SSL3_MT_HELLO_REQUEST: u32 = 0;
pub const SSL3_MT_CLIENT_HELLO: u32 = 1;
pub const SSL3_MT_SERVER_HELLO: u32 = 2;
pub const SSL3_MT_NEW_SESSION_TICKET: u32 = 4;
pub const SSL3_MT_END_OF_EARLY_DATA: u32 = 5;
pub const SSL3_MT_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const SSL3_MT_CERTIFICATE: u32 = 11;
pub const SSL3_MT_SERVER_KEY_EXCHANGE: u32 = 12;
pub const SSL3_MT_CERTIFICATE_REQUEST: u32 = 13;
pub const SSL3_MT_SERVER_HELLO_DONE: u32 = 14;
pub const SSL3_MT_CERTIFICATE_VERIFY: u32 = 15;
pub const SSL3_MT_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const SSL3_MT_FINISHED: u32 = 20;
pub const SSL3_MT_CERTIFICATE_STATUS: u32 = 22;
pub const SSL3_MT_SUPPLEMENTAL_DATA: u32 = 23;
pub const SSL3_MT_KEY_UPDATE: u32 = 24;
pub const SSL3_MT_COMPRESSED_CERTIFICATE: u32 = 25;
pub const SSL3_MT_NEXT_PROTO: u32 = 67;
pub const SSL3_MT_CHANNEL_ID: u32 = 203;
pub const SSL3_MT_MESSAGE_HASH: u32 = 254;
pub const DTLS1_MT_HELLO_VERIFY_REQUEST: u32 = 3;
pub const SSL3_MT_SERVER_DONE: u32 = 14;
pub const SSL3_MT_NEWSESSION_TICKET: u32 = 4;
pub const SSL3_MT_CCS: u32 = 1;
pub const TLS1_AD_END_OF_EARLY_DATA: u32 = 1;
pub const TLS1_AD_DECRYPTION_FAILED: u32 = 21;
pub const TLS1_AD_RECORD_OVERFLOW: u32 = 22;
pub const TLS1_AD_UNKNOWN_CA: u32 = 48;
pub const TLS1_AD_ACCESS_DENIED: u32 = 49;
pub const TLS1_AD_DECODE_ERROR: u32 = 50;
pub const TLS1_AD_DECRYPT_ERROR: u32 = 51;
pub const TLS1_AD_EXPORT_RESTRICTION: u32 = 60;
pub const TLS1_AD_PROTOCOL_VERSION: u32 = 70;
pub const TLS1_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const TLS1_AD_INTERNAL_ERROR: u32 = 80;
pub const TLS1_AD_USER_CANCELLED: u32 = 90;
pub const TLS1_AD_NO_RENEGOTIATION: u32 = 100;
pub const TLS1_AD_MISSING_EXTENSION: u32 = 109;
pub const TLS1_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const TLS1_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const TLS1_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const TLS1_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const TLS1_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const TLS1_AD_CERTIFICATE_REQUIRED: u32 = 116;
pub const TLS1_AD_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const TLS1_AD_ECH_REQUIRED: u32 = 121;
pub const TLSEXT_TYPE_server_name: u32 = 0;
pub const TLSEXT_TYPE_status_request: u32 = 5;
pub const TLSEXT_TYPE_ec_point_formats: u32 = 11;
pub const TLSEXT_TYPE_signature_algorithms: u32 = 13;
pub const TLSEXT_TYPE_srtp: u32 = 14;
pub const TLSEXT_TYPE_application_layer_protocol_negotiation: u32 = 16;
pub const TLSEXT_TYPE_padding: u32 = 21;
pub const TLSEXT_TYPE_extended_master_secret: u32 = 23;
pub const TLSEXT_TYPE_quic_transport_parameters_legacy: u32 = 65445;
pub const TLSEXT_TYPE_quic_transport_parameters: u32 = 57;
pub const TLSEXT_TYPE_quic_transport_parameters_standard: u32 = 57;
pub const TLSEXT_TYPE_cert_compression: u32 = 27;
pub const TLSEXT_TYPE_session_ticket: u32 = 35;
pub const TLSEXT_TYPE_supported_groups: u32 = 10;
pub const TLSEXT_TYPE_pre_shared_key: u32 = 41;
pub const TLSEXT_TYPE_early_data: u32 = 42;
pub const TLSEXT_TYPE_supported_versions: u32 = 43;
pub const TLSEXT_TYPE_cookie: u32 = 44;
pub const TLSEXT_TYPE_psk_key_exchange_modes: u32 = 45;
pub const TLSEXT_TYPE_certificate_authorities: u32 = 47;
pub const TLSEXT_TYPE_signature_algorithms_cert: u32 = 50;
pub const TLSEXT_TYPE_key_share: u32 = 51;
pub const TLSEXT_TYPE_renegotiate: u32 = 65281;
pub const TLSEXT_TYPE_delegated_credential: u32 = 34;
pub const TLSEXT_TYPE_application_settings_old: u32 = 17513;
pub const TLSEXT_TYPE_application_settings: u32 = 17613;
pub const TLSEXT_TYPE_encrypted_client_hello: u32 = 65037;
pub const TLSEXT_TYPE_ech_outer_extensions: u32 = 64768;
pub const TLSEXT_TYPE_certificate_timestamp: u32 = 18;
pub const TLSEXT_TYPE_next_proto_neg: u32 = 13172;
pub const TLSEXT_TYPE_channel_id: u32 = 30032;
pub const TLSEXT_STATUSTYPE_nothing: i32 = -1;
pub const TLSEXT_STATUSTYPE_ocsp: u32 = 1;
pub const TLSEXT_ECPOINTFORMAT_uncompressed: u32 = 0;
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime: u32 = 1;
pub const TLSEXT_signature_anonymous: u32 = 0;
pub const TLSEXT_signature_rsa: u32 = 1;
pub const TLSEXT_signature_dsa: u32 = 2;
pub const TLSEXT_signature_ecdsa: u32 = 3;
pub const TLSEXT_hash_none: u32 = 0;
pub const TLSEXT_hash_md5: u32 = 1;
pub const TLSEXT_hash_sha1: u32 = 2;
pub const TLSEXT_hash_sha224: u32 = 3;
pub const TLSEXT_hash_sha256: u32 = 4;
pub const TLSEXT_hash_sha384: u32 = 5;
pub const TLSEXT_hash_sha512: u32 = 6;
pub const TLSEXT_cert_compression_zlib: u32 = 1;
pub const TLSEXT_cert_compression_brotli: u32 = 2;
pub const TLSEXT_MAXLEN_host_name: u32 = 255;
pub const TLS1_CK_PSK_WITH_RC4_128_SHA: u32 = 50331786;
pub const TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 50331787;
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA: u32 = 50331788;
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA: u32 = 50331789;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 50380853;
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 50380854;
pub const TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_MD5: u32 = 50331744;
pub const TLS1_CK_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5: u32 = 50331745;
pub const TLS1_CK_RSA_EXPORT1024_WITH_DES_CBC_SHA: u32 = 50331746;
pub const TLS1_CK_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA: u32 = 50331747;
pub const TLS1_CK_RSA_EXPORT1024_WITH_RC4_56_SHA: u32 = 50331748;
pub const TLS1_CK_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA: u32 = 50331749;
pub const TLS1_CK_DHE_DSS_WITH_RC4_128_SHA: u32 = 50331750;
pub const TLS1_CK_RSA_WITH_AES_128_SHA: u32 = 50331695;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA: u32 = 50331696;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA: u32 = 50331697;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA: u32 = 50331698;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA: u32 = 50331699;
pub const TLS1_CK_ADH_WITH_AES_128_SHA: u32 = 50331700;
pub const TLS1_CK_RSA_WITH_AES_256_SHA: u32 = 50331701;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA: u32 = 50331702;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA: u32 = 50331703;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA: u32 = 50331704;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA: u32 = 50331705;
pub const TLS1_CK_ADH_WITH_AES_256_SHA: u32 = 50331706;
pub const TLS1_CK_RSA_WITH_NULL_SHA256: u32 = 50331707;
pub const TLS1_CK_RSA_WITH_AES_128_SHA256: u32 = 50331708;
pub const TLS1_CK_RSA_WITH_AES_256_SHA256: u32 = 50331709;
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA256: u32 = 50331710;
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA256: u32 = 50331711;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: u32 = 50331712;
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331713;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331714;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331715;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331716;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331717;
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: u32 = 50331718;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: u32 = 50331751;
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA256: u32 = 50331752;
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA256: u32 = 50331753;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: u32 = 50331754;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: u32 = 50331755;
pub const TLS1_CK_ADH_WITH_AES_128_SHA256: u32 = 50331756;
pub const TLS1_CK_ADH_WITH_AES_256_SHA256: u32 = 50331757;
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331780;
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331781;
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331782;
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331783;
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331784;
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: u32 = 50331785;
pub const TLS1_CK_RSA_WITH_SEED_SHA: u32 = 50331798;
pub const TLS1_CK_DH_DSS_WITH_SEED_SHA: u32 = 50331799;
pub const TLS1_CK_DH_RSA_WITH_SEED_SHA: u32 = 50331800;
pub const TLS1_CK_DHE_DSS_WITH_SEED_SHA: u32 = 50331801;
pub const TLS1_CK_DHE_RSA_WITH_SEED_SHA: u32 = 50331802;
pub const TLS1_CK_ADH_WITH_SEED_SHA: u32 = 50331803;
pub const TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331804;
pub const TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331805;
pub const TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331806;
pub const TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331807;
pub const TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50331808;
pub const TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50331809;
pub const TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331810;
pub const TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331811;
pub const TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: u32 = 50331812;
pub const TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: u32 = 50331813;
pub const TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: u32 = 50331814;
pub const TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: u32 = 50331815;
pub const TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: u32 = 50380801;
pub const TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 50380802;
pub const TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380803;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380804;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380805;
pub const TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 50380806;
pub const TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 50380807;
pub const TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: u32 = 50380808;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 50380809;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 50380810;
pub const TLS1_CK_ECDH_RSA_WITH_NULL_SHA: u32 = 50380811;
pub const TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: u32 = 50380812;
pub const TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380813;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 50380814;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 50380815;
pub const TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: u32 = 50380816;
pub const TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 50380817;
pub const TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: u32 = 50380818;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 50380819;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 50380820;
pub const TLS1_CK_ECDH_anon_WITH_NULL_SHA: u32 = 50380821;
pub const TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: u32 = 50380822;
pub const TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: u32 = 50380823;
pub const TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: u32 = 50380824;
pub const TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: u32 = 50380825;
pub const TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: u32 = 50380826;
pub const TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 50380827;
pub const TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: u32 = 50380828;
pub const TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: u32 = 50380829;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: u32 = 50380830;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: u32 = 50380831;
pub const TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: u32 = 50380832;
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: u32 = 50380833;
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: u32 = 50380834;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: u32 = 50380835;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: u32 = 50380836;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: u32 = 50380837;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: u32 = 50380838;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: u32 = 50380839;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: u32 = 50380840;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: u32 = 50380841;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: u32 = 50380842;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380843;
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380844;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 50380845;
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 50380846;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380847;
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380848;
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 50380849;
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 50380850;
pub const TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 50384040;
pub const TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 50384041;
pub const TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 50384044;
pub const TLS1_3_CK_AES_128_GCM_SHA256: u32 = 50336513;
pub const TLS1_3_CK_AES_256_GCM_SHA384: u32 = 50336514;
pub const TLS1_3_CK_CHACHA20_POLY1305_SHA256: u32 = 50336515;
pub const TLS1_CK_AES_128_GCM_SHA256: u32 = 50336513;
pub const TLS1_CK_AES_256_GCM_SHA384: u32 = 50336514;
pub const TLS1_CK_CHACHA20_POLY1305_SHA256: u32 = 50336515;
pub const TLS1_TXT_RSA_EXPORT1024_WITH_RC4_56_MD5: &[u8; 16] = b"EXP1024-RC4-MD5\0";
pub const TLS1_TXT_RSA_EXPORT1024_WITH_RC2_CBC_56_MD5: &[u8; 20] = b"EXP1024-RC2-CBC-MD5\0";
pub const TLS1_TXT_RSA_EXPORT1024_WITH_DES_CBC_SHA: &[u8; 20] = b"EXP1024-DES-CBC-SHA\0";
pub const TLS1_TXT_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA: &[u8; 28] =
    b"EXP1024-DHE-DSS-DES-CBC-SHA\0";
pub const TLS1_TXT_RSA_EXPORT1024_WITH_RC4_56_SHA: &[u8; 16] = b"EXP1024-RC4-SHA\0";
pub const TLS1_TXT_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA: &[u8; 24] = b"EXP1024-DHE-DSS-RC4-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA: &[u8; 16] = b"DHE-DSS-RC4-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA: &[u8; 11] = b"AES128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA: &[u8; 18] = b"DH-DSS-AES128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA: &[u8; 18] = b"DH-RSA-AES128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA: &[u8; 19] = b"DHE-DSS-AES128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA: &[u8; 19] = b"DHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA: &[u8; 15] = b"ADH-AES128-SHA\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA: &[u8; 11] = b"AES256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA: &[u8; 18] = b"DH-DSS-AES256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA: &[u8; 18] = b"DH-RSA-AES256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA: &[u8; 19] = b"DHE-DSS-AES256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA: &[u8; 19] = b"DHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA: &[u8; 15] = b"ADH-AES256-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_NULL_SHA: &[u8; 20] = b"ECDH-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA: &[u8; 19] = b"ECDH-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 24] = b"ECDH-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 22] = b"ECDH-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 22] = b"ECDH-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_NULL_SHA: &[u8; 21] = b"ECDHE-ECDSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA: &[u8; 20] = b"ECDHE-ECDSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: &[u8; 25] = b"ECDHE-ECDSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: &[u8; 23] = b"ECDHE-ECDSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: &[u8; 23] = b"ECDHE-ECDSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_NULL_SHA: &[u8; 18] = b"ECDH-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA: &[u8; 17] = b"ECDH-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA: &[u8; 22] = b"ECDH-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_CBC_SHA: &[u8; 20] = b"ECDH-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_CBC_SHA: &[u8; 20] = b"ECDH-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_NULL_SHA: &[u8; 19] = b"ECDHE-RSA-NULL-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA: &[u8; 18] = b"ECDHE-RSA-RC4-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA: &[u8; 23] = b"ECDHE-RSA-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA: &[u8; 21] = b"ECDHE-RSA-AES128-SHA\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA: &[u8; 21] = b"ECDHE-RSA-AES256-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_NULL_SHA: &[u8; 15] = b"AECDH-NULL-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA: &[u8; 14] = b"AECDH-RC4-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA: &[u8; 19] = b"AECDH-DES-CBC3-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_128_CBC_SHA: &[u8; 17] = b"AECDH-AES128-SHA\0";
pub const TLS1_TXT_ECDH_anon_WITH_AES_256_CBC_SHA: &[u8; 17] = b"AECDH-AES256-SHA\0";
pub const TLS1_TXT_PSK_WITH_RC4_128_SHA: &[u8; 12] = b"PSK-RC4-SHA\0";
pub const TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA: &[u8; 21] = b"PSK-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA: &[u8; 19] = b"PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA: &[u8; 19] = b"PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA: &[u8; 25] = b"ECDHE-PSK-AES128-CBC-SHA\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA: &[u8; 25] = b"ECDHE-PSK-AES256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA: &[u8; 21] = b"SRP-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: &[u8; 25] = b"SRP-RSA-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: &[u8; 25] = b"SRP-DSS-3DES-EDE-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_128_CBC_SHA: &[u8; 20] = b"SRP-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: &[u8; 24] = b"SRP-RSA-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: &[u8; 24] = b"SRP-DSS-AES-128-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_WITH_AES_256_CBC_SHA: &[u8; 20] = b"SRP-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: &[u8; 24] = b"SRP-RSA-AES-256-CBC-SHA\0";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: &[u8; 24] = b"SRP-DSS-AES-256-CBC-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 16] = b"CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 23] = b"DH-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 23] = b"DH-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: &[u8; 24] = b"DHE-DSS-CAMELLIA128-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: &[u8; 24] = b"DHE-RSA-CAMELLIA128-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA: &[u8; 20] = b"ADH-CAMELLIA128-SHA\0";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 16] = b"CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 23] = b"DH-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 23] = b"DH-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: &[u8; 24] = b"DHE-DSS-CAMELLIA256-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: &[u8; 24] = b"DHE-RSA-CAMELLIA256-SHA\0";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA: &[u8; 20] = b"ADH-CAMELLIA256-SHA\0";
pub const TLS1_TXT_RSA_WITH_SEED_SHA: &[u8; 9] = b"SEED-SHA\0";
pub const TLS1_TXT_DH_DSS_WITH_SEED_SHA: &[u8; 16] = b"DH-DSS-SEED-SHA\0";
pub const TLS1_TXT_DH_RSA_WITH_SEED_SHA: &[u8; 16] = b"DH-RSA-SEED-SHA\0";
pub const TLS1_TXT_DHE_DSS_WITH_SEED_SHA: &[u8; 17] = b"DHE-DSS-SEED-SHA\0";
pub const TLS1_TXT_DHE_RSA_WITH_SEED_SHA: &[u8; 17] = b"DHE-RSA-SEED-SHA\0";
pub const TLS1_TXT_ADH_WITH_SEED_SHA: &[u8; 13] = b"ADH-SEED-SHA\0";
pub const TLS1_TXT_RSA_WITH_NULL_SHA256: &[u8; 12] = b"NULL-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA256: &[u8; 14] = b"AES128-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA256: &[u8; 14] = b"AES256-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA256: &[u8; 21] = b"DH-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA256: &[u8; 21] = b"DH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA256: &[u8; 22] = b"DHE-DSS-AES128-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256: &[u8; 22] = b"DHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA256: &[u8; 21] = b"DH-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA256: &[u8; 21] = b"DH-RSA-AES256-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA256: &[u8; 22] = b"DHE-DSS-AES256-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256: &[u8; 22] = b"DHE-RSA-AES256-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA256: &[u8; 18] = b"ADH-AES128-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA256: &[u8; 18] = b"ADH-AES256-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_128_GCM_SHA256: &[u8; 18] = b"AES128-GCM-SHA256\0";
pub const TLS1_TXT_RSA_WITH_AES_256_GCM_SHA384: &[u8; 18] = b"AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 26] = b"DHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 26] = b"DHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_GCM_SHA256: &[u8; 25] = b"DH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_GCM_SHA384: &[u8; 25] = b"DH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_GCM_SHA256: &[u8; 26] = b"DHE-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_GCM_SHA384: &[u8; 26] = b"DHE-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_GCM_SHA256: &[u8; 25] = b"DH-DSS-AES128-GCM-SHA256\0";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_GCM_SHA384: &[u8; 25] = b"DH-DSS-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ADH_WITH_AES_128_GCM_SHA256: &[u8; 22] = b"ADH-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ADH_WITH_AES_256_GCM_SHA384: &[u8; 22] = b"ADH-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256: &[u8; 26] = b"ECDHE-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384: &[u8; 26] = b"ECDHE-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_SHA256: &[u8; 25] = b"ECDH-ECDSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_SHA384: &[u8; 25] = b"ECDH-ECDSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_SHA256: &[u8; 24] = b"ECDHE-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384: &[u8; 24] = b"ECDHE-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_SHA256: &[u8; 23] = b"ECDH-RSA-AES128-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_SHA384: &[u8; 23] = b"ECDH-RSA-AES256-SHA384\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 30] =
    b"ECDHE-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 30] =
    b"ECDHE-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: &[u8; 29] =
    b"ECDH-ECDSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: &[u8; 29] =
    b"ECDH-ECDSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256: &[u8; 28] = b"ECDHE-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_GCM_SHA384: &[u8; 28] = b"ECDHE-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256: &[u8; 27] = b"ECDH-RSA-AES128-GCM-SHA256\0";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384: &[u8; 27] = b"ECDH-RSA-AES256-GCM-SHA384\0";
pub const TLS1_TXT_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: &[u8; 28] =
    b"ECDHE-RSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: &[u8; 30] =
    b"ECDHE-ECDSA-CHACHA20-POLY1305\0";
pub const TLS1_TXT_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: &[u8; 28] =
    b"ECDHE-PSK-CHACHA20-POLY1305\0";
pub const TLS1_3_RFC_AES_128_GCM_SHA256: &[u8; 23] = b"TLS_AES_128_GCM_SHA256\0";
pub const TLS1_3_RFC_AES_256_GCM_SHA384: &[u8; 23] = b"TLS_AES_256_GCM_SHA384\0";
pub const TLS1_3_RFC_CHACHA20_POLY1305_SHA256: &[u8; 29] = b"TLS_CHACHA20_POLY1305_SHA256\0";
pub const TLS1_TXT_AES_128_GCM_SHA256: &[u8; 23] = b"TLS_AES_128_GCM_SHA256\0";
pub const TLS1_TXT_AES_256_GCM_SHA384: &[u8; 23] = b"TLS_AES_256_GCM_SHA384\0";
pub const TLS1_TXT_CHACHA20_POLY1305_SHA256: &[u8; 29] = b"TLS_CHACHA20_POLY1305_SHA256\0";
pub const TLS_CT_RSA_SIGN: u32 = 1;
pub const TLS_CT_DSS_SIGN: u32 = 2;
pub const TLS_CT_RSA_FIXED_DH: u32 = 3;
pub const TLS_CT_DSS_FIXED_DH: u32 = 4;
pub const TLS_CT_ECDSA_SIGN: u32 = 64;
pub const TLS_CT_RSA_FIXED_ECDH: u32 = 65;
pub const TLS_CT_ECDSA_FIXED_ECDH: u32 = 66;
pub const TLS_MD_MAX_CONST_SIZE: u32 = 20;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SSL_KEY_UPDATE_REQUESTED: u32 = 1;
pub const SSL_KEY_UPDATE_NOT_REQUESTED: u32 = 0;
pub const SSL_KEY_UPDATE_NONE: i32 = -1;
pub const SSL_ERROR_NONE: u32 = 0;
pub const SSL_ERROR_SSL: u32 = 1;
pub const SSL_ERROR_WANT_READ: u32 = 2;
pub const SSL_ERROR_WANT_WRITE: u32 = 3;
pub const SSL_ERROR_WANT_X509_LOOKUP: u32 = 4;
pub const SSL_ERROR_SYSCALL: u32 = 5;
pub const SSL_ERROR_ZERO_RETURN: u32 = 6;
pub const SSL_ERROR_WANT_CONNECT: u32 = 7;
pub const SSL_ERROR_WANT_ACCEPT: u32 = 8;
pub const SSL_ERROR_WANT_CHANNEL_ID_LOOKUP: u32 = 9;
pub const SSL_ERROR_PENDING_SESSION: u32 = 11;
pub const SSL_ERROR_PENDING_CERTIFICATE: u32 = 12;
pub const SSL_ERROR_WANT_PRIVATE_KEY_OPERATION: u32 = 13;
pub const SSL_ERROR_PENDING_TICKET: u32 = 14;
pub const SSL_ERROR_EARLY_DATA_REJECTED: u32 = 15;
pub const SSL_ERROR_WANT_CERTIFICATE_VERIFY: u32 = 16;
pub const SSL_ERROR_HANDOFF: u32 = 17;
pub const SSL_ERROR_HANDBACK: u32 = 18;
pub const SSL_ERROR_WANT_RENEGOTIATE: u32 = 19;
pub const SSL_ERROR_HANDSHAKE_HINTS_READY: u32 = 20;
pub const DTLS1_VERSION_MAJOR: u32 = 254;
pub const SSL3_VERSION_MAJOR: u32 = 3;
pub const SSL3_VERSION: u32 = 768;
pub const TLS1_VERSION: u32 = 769;
pub const TLS1_1_VERSION: u32 = 770;
pub const TLS1_2_VERSION: u32 = 771;
pub const TLS1_3_VERSION: u32 = 772;
pub const DTLS1_VERSION: u32 = 65279;
pub const DTLS1_2_VERSION: u32 = 65277;
pub const SSL_OP_NO_QUERY_MTU: u32 = 4096;
pub const SSL_OP_NO_TICKET: u32 = 16384;
pub const SSL_OP_CIPHER_SERVER_PREFERENCE: u32 = 4194304;
pub const SSL_OP_NO_TLSv1: u32 = 67108864;
pub const SSL_OP_NO_TLSv1_2: u32 = 134217728;
pub const SSL_OP_NO_TLSv1_1: u32 = 268435456;
pub const SSL_OP_NO_TLSv1_3: u32 = 536870912;
pub const SSL_OP_NO_DTLSv1: u32 = 67108864;
pub const SSL_OP_NO_DTLSv1_2: u32 = 134217728;
pub const SSL_MODE_ENABLE_PARTIAL_WRITE: u32 = 1;
pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER: u32 = 2;
pub const SSL_MODE_NO_AUTO_CHAIN: u32 = 8;
pub const SSL_MODE_ENABLE_FALSE_START: u32 = 128;
pub const SSL_MODE_CBC_RECORD_SPLITTING: u32 = 256;
pub const SSL_MODE_NO_SESSION_CREATION: u32 = 512;
pub const SSL_MODE_SEND_FALLBACK_SCSV: u32 = 1024;
pub const SSL_BUILD_CHAIN_FLAG_UNTRUSTED: u32 = 1;
pub const SSL_BUILD_CHAIN_FLAG_NO_ROOT: u32 = 2;
pub const SSL_BUILD_CHAIN_FLAG_CHECK: u32 = 4;
pub const SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR: u32 = 8;
pub const SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR: u32 = 16;
pub const SSL_SIGN_RSA_PKCS1_SHA1: u32 = 513;
pub const SSL_SIGN_RSA_PKCS1_SHA256: u32 = 1025;
pub const SSL_SIGN_RSA_PKCS1_SHA384: u32 = 1281;
pub const SSL_SIGN_RSA_PKCS1_SHA512: u32 = 1537;
pub const SSL_SIGN_ECDSA_SHA1: u32 = 515;
pub const SSL_SIGN_ECDSA_SECP256R1_SHA256: u32 = 1027;
pub const SSL_SIGN_ECDSA_SECP384R1_SHA384: u32 = 1283;
pub const SSL_SIGN_ECDSA_SECP521R1_SHA512: u32 = 1539;
pub const SSL_SIGN_RSA_PSS_RSAE_SHA256: u32 = 2052;
pub const SSL_SIGN_RSA_PSS_RSAE_SHA384: u32 = 2053;
pub const SSL_SIGN_RSA_PSS_RSAE_SHA512: u32 = 2054;
pub const SSL_SIGN_ED25519: u32 = 2055;
pub const SSL_SIGN_RSA_PKCS1_MD5_SHA1: u32 = 65281;
pub const SSL_FILETYPE_PEM: u32 = 1;
pub const SSL_FILETYPE_ASN1: u32 = 2;
pub const SSL_DEFAULT_CIPHER_LIST: &[u8; 4] = b"ALL\0";
pub const SSL_MAX_SSL_SESSION_ID_LENGTH: u32 = 32;
pub const SSL_MAX_MASTER_KEY_LENGTH: u32 = 48;
pub const SSL_SESS_CACHE_OFF: u32 = 0;
pub const SSL_SESS_CACHE_CLIENT: u32 = 1;
pub const SSL_SESS_CACHE_SERVER: u32 = 2;
pub const SSL_SESS_CACHE_BOTH: u32 = 3;
pub const SSL_SESS_CACHE_NO_AUTO_CLEAR: u32 = 128;
pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP: u32 = 256;
pub const SSL_SESS_CACHE_NO_INTERNAL_STORE: u32 = 512;
pub const SSL_SESS_CACHE_NO_INTERNAL: u32 = 768;
pub const SSL_DEFAULT_SESSION_TIMEOUT: u32 = 7200;
pub const SSL_DEFAULT_SESSION_PSK_DHE_TIMEOUT: u32 = 172800;
pub const SSL_DEFAULT_SESSION_AUTH_TIMEOUT: u32 = 604800;
pub const SSL_MAX_SID_CTX_LENGTH: u32 = 32;
pub const SSL_SESSION_CACHE_MAX_SIZE_DEFAULT: u32 = 20480;
pub const SSL_DEFAULT_TICKET_KEY_ROTATION_INTERVAL: u32 = 172800;
pub const SSL_TICKET_KEY_NAME_LEN: u32 = 16;
pub const SSL_GROUP_SECP224R1: u32 = 21;
pub const SSL_GROUP_SECP256R1: u32 = 23;
pub const SSL_GROUP_SECP384R1: u32 = 24;
pub const SSL_GROUP_SECP521R1: u32 = 25;
pub const SSL_GROUP_X25519: u32 = 29;
pub const SSL_GROUP_SECP256R1_KYBER768_DRAFT00: u32 = 25498;
pub const SSL_GROUP_X25519_KYBER768_DRAFT00: u32 = 25497;
pub const SSL_GROUP_KYBER512_R3: u32 = 570;
pub const SSL_GROUP_KYBER768_R3: u32 = 572;
pub const SSL_GROUP_KYBER1024_R3: u32 = 573;
pub const SSL_VERIFY_NONE: u32 = 0;
pub const SSL_VERIFY_PEER: u32 = 1;
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT: u32 = 2;
pub const SSL_VERIFY_PEER_IF_NO_OBC: u32 = 4;
pub const TLSEXT_NAMETYPE_host_name: u32 = 0;
pub const SSL_TLSEXT_ERR_OK: u32 = 0;
pub const SSL_TLSEXT_ERR_ALERT_WARNING: u32 = 1;
pub const SSL_TLSEXT_ERR_ALERT_FATAL: u32 = 2;
pub const SSL_TLSEXT_ERR_NOACK: u32 = 3;
pub const OPENSSL_NPN_UNSUPPORTED: u32 = 0;
pub const OPENSSL_NPN_NEGOTIATED: u32 = 1;
pub const OPENSSL_NPN_NO_OVERLAP: u32 = 2;
pub const SRTP_AES128_CM_SHA1_80: u32 = 1;
pub const SRTP_AES128_CM_SHA1_32: u32 = 2;
pub const SRTP_AES128_F8_SHA1_80: u32 = 3;
pub const SRTP_AES128_F8_SHA1_32: u32 = 4;
pub const SRTP_NULL_SHA1_80: u32 = 5;
pub const SRTP_NULL_SHA1_32: u32 = 6;
pub const SRTP_AEAD_AES_128_GCM: u32 = 7;
pub const SRTP_AEAD_AES_256_GCM: u32 = 8;
pub const PSK_MAX_IDENTITY_LEN: u32 = 128;
pub const PSK_MAX_PSK_LEN: u32 = 256;
pub const SSL_AD_REASON_OFFSET: u32 = 1000;
pub const SSL_AD_CLOSE_NOTIFY: u32 = 0;
pub const SSL_AD_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_AD_BAD_RECORD_MAC: u32 = 20;
pub const SSL_AD_DECRYPTION_FAILED: u32 = 21;
pub const SSL_AD_RECORD_OVERFLOW: u32 = 22;
pub const SSL_AD_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL_AD_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_AD_NO_CERTIFICATE: u32 = 41;
pub const SSL_AD_BAD_CERTIFICATE: u32 = 42;
pub const SSL_AD_UNSUPPORTED_CERTIFICATE: u32 = 43;
pub const SSL_AD_CERTIFICATE_REVOKED: u32 = 44;
pub const SSL_AD_CERTIFICATE_EXPIRED: u32 = 45;
pub const SSL_AD_CERTIFICATE_UNKNOWN: u32 = 46;
pub const SSL_AD_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_AD_UNKNOWN_CA: u32 = 48;
pub const SSL_AD_ACCESS_DENIED: u32 = 49;
pub const SSL_AD_DECODE_ERROR: u32 = 50;
pub const SSL_AD_DECRYPT_ERROR: u32 = 51;
pub const SSL_AD_EXPORT_RESTRICTION: u32 = 60;
pub const SSL_AD_PROTOCOL_VERSION: u32 = 70;
pub const SSL_AD_INSUFFICIENT_SECURITY: u32 = 71;
pub const SSL_AD_INTERNAL_ERROR: u32 = 80;
pub const SSL_AD_INAPPROPRIATE_FALLBACK: u32 = 86;
pub const SSL_AD_USER_CANCELLED: u32 = 90;
pub const SSL_AD_NO_RENEGOTIATION: u32 = 100;
pub const SSL_AD_MISSING_EXTENSION: u32 = 109;
pub const SSL_AD_UNSUPPORTED_EXTENSION: u32 = 110;
pub const SSL_AD_CERTIFICATE_UNOBTAINABLE: u32 = 111;
pub const SSL_AD_UNRECOGNIZED_NAME: u32 = 112;
pub const SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 113;
pub const SSL_AD_BAD_CERTIFICATE_HASH_VALUE: u32 = 114;
pub const SSL_AD_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const SSL_AD_CERTIFICATE_REQUIRED: u32 = 116;
pub const SSL_AD_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const SSL_AD_ECH_REQUIRED: u32 = 121;
pub const SSL_MAX_CERT_LIST_DEFAULT: u32 = 102400;
pub const SSL_ST_CONNECT: u32 = 4096;
pub const SSL_ST_ACCEPT: u32 = 8192;
pub const SSL_ST_MASK: u32 = 4095;
pub const SSL_ST_INIT: u32 = 12288;
pub const SSL_ST_OK: u32 = 3;
pub const SSL_ST_RENEGOTIATE: u32 = 12292;
pub const SSL_ST_BEFORE: u32 = 12293;
pub const SSL_CB_LOOP: u32 = 1;
pub const SSL_CB_EXIT: u32 = 2;
pub const SSL_CB_READ: u32 = 4;
pub const SSL_CB_WRITE: u32 = 8;
pub const SSL_CB_ALERT: u32 = 16384;
pub const SSL_CB_READ_ALERT: u32 = 16388;
pub const SSL_CB_WRITE_ALERT: u32 = 16392;
pub const SSL_CB_ACCEPT_LOOP: u32 = 8193;
pub const SSL_CB_ACCEPT_EXIT: u32 = 8194;
pub const SSL_CB_CONNECT_LOOP: u32 = 4097;
pub const SSL_CB_CONNECT_EXIT: u32 = 4098;
pub const SSL_CB_HANDSHAKE_START: u32 = 16;
pub const SSL_CB_HANDSHAKE_DONE: u32 = 32;
pub const SSL_SENT_SHUTDOWN: u32 = 1;
pub const SSL_RECEIVED_SHUTDOWN: u32 = 2;
pub const SSL_MODE_HANDSHAKE_CUTTHROUGH: u32 = 128;
pub const SSL_NOTHING: u32 = 0;
pub const SSL_WRITING: u32 = 3;
pub const SSL_READING: u32 = 2;
pub const SSL_TXT_MEDIUM: &[u8; 7] = b"MEDIUM\0";
pub const SSL_TXT_HIGH: &[u8; 5] = b"HIGH\0";
pub const SSL_TXT_FIPS: &[u8; 5] = b"FIPS\0";
pub const SSL_TXT_kRSA: &[u8; 5] = b"kRSA\0";
pub const SSL_TXT_kDHE: &[u8; 5] = b"kDHE\0";
pub const SSL_TXT_kEDH: &[u8; 5] = b"kEDH\0";
pub const SSL_TXT_kECDHE: &[u8; 7] = b"kECDHE\0";
pub const SSL_TXT_kEECDH: &[u8; 7] = b"kEECDH\0";
pub const SSL_TXT_kPSK: &[u8; 5] = b"kPSK\0";
pub const SSL_TXT_aRSA: &[u8; 5] = b"aRSA\0";
pub const SSL_TXT_aECDSA: &[u8; 7] = b"aECDSA\0";
pub const SSL_TXT_aPSK: &[u8; 5] = b"aPSK\0";
pub const SSL_TXT_DH: &[u8; 3] = b"DH\0";
pub const SSL_TXT_DHE: &[u8; 4] = b"DHE\0";
pub const SSL_TXT_EDH: &[u8; 4] = b"EDH\0";
pub const SSL_TXT_RSA: &[u8; 4] = b"RSA\0";
pub const SSL_TXT_ECDH: &[u8; 5] = b"ECDH\0";
pub const SSL_TXT_ECDHE: &[u8; 6] = b"ECDHE\0";
pub const SSL_TXT_EECDH: &[u8; 6] = b"EECDH\0";
pub const SSL_TXT_ECDSA: &[u8; 6] = b"ECDSA\0";
pub const SSL_TXT_PSK: &[u8; 4] = b"PSK\0";
pub const SSL_TXT_3DES: &[u8; 5] = b"3DES\0";
pub const SSL_TXT_RC4: &[u8; 4] = b"RC4\0";
pub const SSL_TXT_AES128: &[u8; 7] = b"AES128\0";
pub const SSL_TXT_AES256: &[u8; 7] = b"AES256\0";
pub const SSL_TXT_AES: &[u8; 4] = b"AES\0";
pub const SSL_TXT_AES_GCM: &[u8; 7] = b"AESGCM\0";
pub const SSL_TXT_CHACHA20: &[u8; 9] = b"CHACHA20\0";
pub const SSL_TXT_MD5: &[u8; 4] = b"MD5\0";
pub const SSL_TXT_SHA1: &[u8; 5] = b"SHA1\0";
pub const SSL_TXT_SHA: &[u8; 4] = b"SHA\0";
pub const SSL_TXT_SHA256: &[u8; 7] = b"SHA256\0";
pub const SSL_TXT_SHA384: &[u8; 7] = b"SHA384\0";
pub const SSL_TXT_SSLV3: &[u8; 6] = b"SSLv3\0";
pub const SSL_TXT_TLSV1: &[u8; 6] = b"TLSv1\0";
pub const SSL_TXT_TLSV1_1: &[u8; 8] = b"TLSv1.1\0";
pub const SSL_TXT_TLSV1_2: &[u8; 8] = b"TLSv1.2\0";
pub const SSL_TXT_TLSV1_3: &[u8; 8] = b"TLSv1.3\0";
pub const SSL_TXT_ALL: &[u8; 4] = b"ALL\0";
pub const SSL_TXT_CMPDEF: &[u8; 20] = b"COMPLEMENTOFDEFAULT\0";
pub const OPENSSL_INIT_NO_LOAD_SSL_STRINGS: u32 = 0;
pub const OPENSSL_INIT_LOAD_SSL_STRINGS: u32 = 0;
pub const OPENSSL_INIT_SSL_DEFAULT: u32 = 0;
pub const SSL_SIGN_RSA_PSS_SHA256: u32 = 2052;
pub const SSL_SIGN_RSA_PSS_SHA384: u32 = 2053;
pub const SSL_SIGN_RSA_PSS_SHA512: u32 = 2054;
pub const SSL_CURVE_SECP224R1: u32 = 21;
pub const SSL_CURVE_SECP256R1: u32 = 23;
pub const SSL_CURVE_SECP384R1: u32 = 24;
pub const SSL_CURVE_SECP521R1: u32 = 25;
pub const SSL_CURVE_X25519: u32 = 29;
pub const SSL_CURVE_SECP256R1_KYBER768_DRAFT00: u32 = 25498;
pub const SSL_CURVE_X25519_KYBER768_DRAFT00: u32 = 25497;
pub const SSL_MODE_AUTO_RETRY: u32 = 0;
pub const SSL_MODE_RELEASE_BUFFERS: u32 = 0;
pub const SSL_MODE_SEND_CLIENTHELLO_TIME: u32 = 0;
pub const SSL_MODE_SEND_SERVERHELLO_TIME: u32 = 0;
pub const SSL_OP_ALL: u32 = 0;
pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: u32 = 0;
pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG: u32 = 0;
pub const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: u32 = 0;
pub const SSL_OP_LEGACY_SERVER_CONNECT: u32 = 0;
pub const SSL_OP_NO_COMPRESSION: u32 = 0;
pub const SSL_OP_NO_RENEGOTIATION: u32 = 0;
pub const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: u32 = 0;
pub const SSL_OP_NO_SSLv2: u32 = 0;
pub const SSL_OP_NO_SSLv3: u32 = 0;
pub const SSL_OP_SAFARI_ECDHE_ECDSA_BUG: u32 = 0;
pub const SSL_OP_TLSEXT_PADDING: u32 = 0;
pub const SSL_OP_TLS_ROLLBACK_BUG: u32 = 0;
pub const SSL_VERIFY_CLIENT_ONCE: u32 = 0;
pub const SSL_OP_EPHEMERAL_RSA: u32 = 0;
pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: u32 = 0;
pub const SSL_OP_MICROSOFT_SESS_ID_BUG: u32 = 0;
pub const SSL_OP_MSIE_SSLV2_RSA_PADDING: u32 = 0;
pub const SSL_OP_NETSCAPE_CA_DN_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_CHALLENGE_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: u32 = 0;
pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_1: u32 = 0;
pub const SSL_OP_PKCS1_CHECK_2: u32 = 0;
pub const SSL_OP_SINGLE_DH_USE: u32 = 0;
pub const SSL_OP_SINGLE_ECDH_USE: u32 = 0;
pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG: u32 = 0;
pub const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: u32 = 0;
pub const SSL_OP_TLS_BLOCK_PADDING_BUG: u32 = 0;
pub const SSL_OP_TLS_D5_BUG: u32 = 0;
pub const SSL_R_BACKWARDS_COMPATABILITY_OFFSET: u32 = 23841;
pub const SSL_R_NO_PROTOCOLS_AVAILABLE: u32 = 23842;
pub const SSL_R_BAD_PROTOCOL_VERSION_NUMBER: u32 = 23843;
pub const SSL_R_UNSUPPORTED_SSL_VERSION: u32 = 23844;
pub const SSL_R_VERSION_TOO_HIGH: u32 = 23845;
pub const SSL_R_VERSION_TOO_LOW: u32 = 23846;
pub const SSL_R_APP_DATA_IN_HANDSHAKE: u32 = 100;
pub const SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT: u32 = 101;
pub const SSL_R_BAD_ALERT: u32 = 102;
pub const SSL_R_BAD_CHANGE_CIPHER_SPEC: u32 = 103;
pub const SSL_R_BAD_DATA_RETURNED_BY_CALLBACK: u32 = 104;
pub const SSL_R_BAD_DH_P_LENGTH: u32 = 105;
pub const SSL_R_BAD_DIGEST_LENGTH: u32 = 106;
pub const SSL_R_BAD_ECC_CERT: u32 = 107;
pub const SSL_R_BAD_ECPOINT: u32 = 108;
pub const SSL_R_BAD_HANDSHAKE_RECORD: u32 = 109;
pub const SSL_R_BAD_HELLO_REQUEST: u32 = 110;
pub const SSL_R_BAD_LENGTH: u32 = 111;
pub const SSL_R_BAD_PACKET_LENGTH: u32 = 112;
pub const SSL_R_BAD_RSA_ENCRYPT: u32 = 113;
pub const SSL_R_BAD_SIGNATURE: u32 = 114;
pub const SSL_R_BAD_SRTP_MKI_VALUE: u32 = 115;
pub const SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST: u32 = 116;
pub const SSL_R_BAD_SSL_FILETYPE: u32 = 117;
pub const SSL_R_BAD_WRITE_RETRY: u32 = 118;
pub const SSL_R_BIO_NOT_SET: u32 = 119;
pub const SSL_R_BN_LIB: u32 = 120;
pub const SSL_R_BUFFER_TOO_SMALL: u32 = 121;
pub const SSL_R_CA_DN_LENGTH_MISMATCH: u32 = 122;
pub const SSL_R_CA_DN_TOO_LONG: u32 = 123;
pub const SSL_R_CCS_RECEIVED_EARLY: u32 = 124;
pub const SSL_R_CERTIFICATE_VERIFY_FAILED: u32 = 125;
pub const SSL_R_CERT_CB_ERROR: u32 = 126;
pub const SSL_R_CERT_LENGTH_MISMATCH: u32 = 127;
pub const SSL_R_CHANNEL_ID_NOT_P256: u32 = 128;
pub const SSL_R_CHANNEL_ID_SIGNATURE_INVALID: u32 = 129;
pub const SSL_R_CIPHER_OR_HASH_UNAVAILABLE: u32 = 130;
pub const SSL_R_CLIENTHELLO_PARSE_FAILED: u32 = 131;
pub const SSL_R_CLIENTHELLO_TLSEXT: u32 = 132;
pub const SSL_R_CONNECTION_REJECTED: u32 = 133;
pub const SSL_R_CONNECTION_TYPE_NOT_SET: u32 = 134;
pub const SSL_R_CUSTOM_EXTENSION_ERROR: u32 = 135;
pub const SSL_R_DATA_LENGTH_TOO_LONG: u32 = 136;
pub const SSL_R_DECODE_ERROR: u32 = 137;
pub const SSL_R_DECRYPTION_FAILED: u32 = 138;
pub const SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC: u32 = 139;
pub const SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG: u32 = 140;
pub const SSL_R_DH_P_TOO_LONG: u32 = 141;
pub const SSL_R_DIGEST_CHECK_FAILED: u32 = 142;
pub const SSL_R_DTLS_MESSAGE_TOO_BIG: u32 = 143;
pub const SSL_R_ECC_CERT_NOT_FOR_SIGNING: u32 = 144;
pub const SSL_R_EMS_STATE_INCONSISTENT: u32 = 145;
pub const SSL_R_ENCRYPTED_LENGTH_TOO_LONG: u32 = 146;
pub const SSL_R_ERROR_ADDING_EXTENSION: u32 = 147;
pub const SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST: u32 = 148;
pub const SSL_R_ERROR_PARSING_EXTENSION: u32 = 149;
pub const SSL_R_EXCESSIVE_MESSAGE_SIZE: u32 = 150;
pub const SSL_R_EXTRA_DATA_IN_MESSAGE: u32 = 151;
pub const SSL_R_FRAGMENT_MISMATCH: u32 = 152;
pub const SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION: u32 = 153;
pub const SSL_R_HANDSHAKE_FAILURE_ON_CLIENT_HELLO: u32 = 154;
pub const SSL_R_HTTPS_PROXY_REQUEST: u32 = 155;
pub const SSL_R_HTTP_REQUEST: u32 = 156;
pub const SSL_R_INAPPROPRIATE_FALLBACK: u32 = 157;
pub const SSL_R_INVALID_COMMAND: u32 = 158;
pub const SSL_R_INVALID_MESSAGE: u32 = 159;
pub const SSL_R_INVALID_SSL_SESSION: u32 = 160;
pub const SSL_R_INVALID_TICKET_KEYS_LENGTH: u32 = 161;
pub const SSL_R_LENGTH_MISMATCH: u32 = 162;
pub const SSL_R_MISSING_EXTENSION: u32 = 164;
pub const SSL_R_MISSING_RSA_CERTIFICATE: u32 = 165;
pub const SSL_R_MISSING_TMP_DH_KEY: u32 = 166;
pub const SSL_R_MISSING_TMP_ECDH_KEY: u32 = 167;
pub const SSL_R_MIXED_SPECIAL_OPERATOR_WITH_GROUPS: u32 = 168;
pub const SSL_R_MTU_TOO_SMALL: u32 = 169;
pub const SSL_R_NEGOTIATED_BOTH_NPN_AND_ALPN: u32 = 170;
pub const SSL_R_NESTED_GROUP: u32 = 171;
pub const SSL_R_NO_CERTIFICATES_RETURNED: u32 = 172;
pub const SSL_R_NO_CERTIFICATE_ASSIGNED: u32 = 173;
pub const SSL_R_NO_CERTIFICATE_SET: u32 = 174;
pub const SSL_R_NO_CIPHERS_AVAILABLE: u32 = 175;
pub const SSL_R_NO_CIPHERS_PASSED: u32 = 176;
pub const SSL_R_NO_CIPHER_MATCH: u32 = 177;
pub const SSL_R_NO_COMPRESSION_SPECIFIED: u32 = 178;
pub const SSL_R_NO_METHOD_SPECIFIED: u32 = 179;
pub const SSL_R_NO_PRIVATE_KEY_ASSIGNED: u32 = 181;
pub const SSL_R_NO_RENEGOTIATION: u32 = 182;
pub const SSL_R_NO_REQUIRED_DIGEST: u32 = 183;
pub const SSL_R_NO_SHARED_CIPHER: u32 = 184;
pub const SSL_R_NULL_SSL_CTX: u32 = 185;
pub const SSL_R_NULL_SSL_METHOD_PASSED: u32 = 186;
pub const SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED: u32 = 187;
pub const SSL_R_OLD_SESSION_VERSION_NOT_RETURNED: u32 = 188;
pub const SSL_R_OUTPUT_ALIASES_INPUT: u32 = 189;
pub const SSL_R_PARSE_TLSEXT: u32 = 190;
pub const SSL_R_PATH_TOO_LONG: u32 = 191;
pub const SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE: u32 = 192;
pub const SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE: u32 = 193;
pub const SSL_R_PROTOCOL_IS_SHUTDOWN: u32 = 194;
pub const SSL_R_PSK_IDENTITY_NOT_FOUND: u32 = 195;
pub const SSL_R_PSK_NO_CLIENT_CB: u32 = 196;
pub const SSL_R_PSK_NO_SERVER_CB: u32 = 197;
pub const SSL_R_READ_TIMEOUT_EXPIRED: u32 = 198;
pub const SSL_R_RECORD_LENGTH_MISMATCH: u32 = 199;
pub const SSL_R_RECORD_TOO_LARGE: u32 = 200;
pub const SSL_R_RENEGOTIATION_ENCODING_ERR: u32 = 201;
pub const SSL_R_RENEGOTIATION_MISMATCH: u32 = 202;
pub const SSL_R_REQUIRED_CIPHER_MISSING: u32 = 203;
pub const SSL_R_RESUMED_EMS_SESSION_WITHOUT_EMS_EXTENSION: u32 = 204;
pub const SSL_R_RESUMED_NON_EMS_SESSION_WITH_EMS_EXTENSION: u32 = 205;
pub const SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING: u32 = 206;
pub const SSL_R_SERVERHELLO_TLSEXT: u32 = 207;
pub const SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED: u32 = 208;
pub const SSL_R_SESSION_MAY_NOT_BE_CREATED: u32 = 209;
pub const SSL_R_SIGNATURE_ALGORITHMS_EXTENSION_SENT_BY_SERVER: u32 = 210;
pub const SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES: u32 = 211;
pub const SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE: u32 = 212;
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME: u32 = 213;
pub const SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION: u32 = 214;
pub const SSL_R_SSL_HANDSHAKE_FAILURE: u32 = 215;
pub const SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG: u32 = 216;
pub const SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST: u32 = 217;
pub const SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG: u32 = 218;
pub const SSL_R_TOO_MANY_EMPTY_FRAGMENTS: u32 = 219;
pub const SSL_R_TOO_MANY_WARNING_ALERTS: u32 = 220;
pub const SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS: u32 = 221;
pub const SSL_R_UNEXPECTED_EXTENSION: u32 = 222;
pub const SSL_R_UNEXPECTED_MESSAGE: u32 = 223;
pub const SSL_R_UNEXPECTED_OPERATOR_IN_GROUP: u32 = 224;
pub const SSL_R_UNEXPECTED_RECORD: u32 = 225;
pub const SSL_R_UNINITIALIZED: u32 = 226;
pub const SSL_R_UNKNOWN_ALERT_TYPE: u32 = 227;
pub const SSL_R_UNKNOWN_CERTIFICATE_TYPE: u32 = 228;
pub const SSL_R_UNKNOWN_CIPHER_RETURNED: u32 = 229;
pub const SSL_R_UNKNOWN_CIPHER_TYPE: u32 = 230;
pub const SSL_R_UNKNOWN_DIGEST: u32 = 231;
pub const SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE: u32 = 232;
pub const SSL_R_UNKNOWN_PROTOCOL: u32 = 233;
pub const SSL_R_UNKNOWN_SSL_VERSION: u32 = 234;
pub const SSL_R_UNKNOWN_STATE: u32 = 235;
pub const SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED: u32 = 236;
pub const SSL_R_UNSUPPORTED_CIPHER: u32 = 237;
pub const SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM: u32 = 238;
pub const SSL_R_UNSUPPORTED_ELLIPTIC_CURVE: u32 = 239;
pub const SSL_R_UNSUPPORTED_PROTOCOL: u32 = 240;
pub const SSL_R_WRONG_CERTIFICATE_TYPE: u32 = 241;
pub const SSL_R_WRONG_CIPHER_RETURNED: u32 = 242;
pub const SSL_R_WRONG_CURVE: u32 = 243;
pub const SSL_R_WRONG_MESSAGE_TYPE: u32 = 244;
pub const SSL_R_WRONG_SIGNATURE_TYPE: u32 = 245;
pub const SSL_R_WRONG_SSL_VERSION: u32 = 246;
pub const SSL_R_WRONG_VERSION_NUMBER: u32 = 247;
pub const SSL_R_X509_LIB: u32 = 248;
pub const SSL_R_X509_VERIFICATION_SETUP_PROBLEMS: u32 = 249;
pub const SSL_R_SHUTDOWN_WHILE_IN_INIT: u32 = 250;
pub const SSL_R_INVALID_OUTER_RECORD_TYPE: u32 = 251;
pub const SSL_R_UNSUPPORTED_PROTOCOL_FOR_CUSTOM_KEY: u32 = 252;
pub const SSL_R_NO_COMMON_SIGNATURE_ALGORITHMS: u32 = 253;
pub const SSL_R_DOWNGRADE_DETECTED: u32 = 254;
pub const SSL_R_EXCESS_HANDSHAKE_DATA: u32 = 255;
pub const SSL_R_INVALID_COMPRESSION_LIST: u32 = 256;
pub const SSL_R_DUPLICATE_EXTENSION: u32 = 257;
pub const SSL_R_MISSING_KEY_SHARE: u32 = 258;
pub const SSL_R_INVALID_ALPN_PROTOCOL: u32 = 259;
pub const SSL_R_TOO_MANY_KEY_UPDATES: u32 = 260;
pub const SSL_R_BLOCK_CIPHER_PAD_IS_WRONG: u32 = 261;
pub const SSL_R_NO_CIPHERS_SPECIFIED: u32 = 262;
pub const SSL_R_RENEGOTIATION_EMS_MISMATCH: u32 = 263;
pub const SSL_R_DUPLICATE_KEY_SHARE: u32 = 264;
pub const SSL_R_NO_GROUPS_SPECIFIED: u32 = 265;
pub const SSL_R_NO_SHARED_GROUP: u32 = 266;
pub const SSL_R_PRE_SHARED_KEY_MUST_BE_LAST: u32 = 267;
pub const SSL_R_OLD_SESSION_PRF_HASH_MISMATCH: u32 = 268;
pub const SSL_R_INVALID_SCT_LIST: u32 = 269;
pub const SSL_R_TOO_MUCH_SKIPPED_EARLY_DATA: u32 = 270;
pub const SSL_R_PSK_IDENTITY_BINDER_COUNT_MISMATCH: u32 = 271;
pub const SSL_R_CANNOT_PARSE_LEAF_CERT: u32 = 272;
pub const SSL_R_SERVER_CERT_CHANGED: u32 = 273;
pub const SSL_R_CERTIFICATE_AND_PRIVATE_KEY_MISMATCH: u32 = 274;
pub const SSL_R_CANNOT_HAVE_BOTH_PRIVKEY_AND_METHOD: u32 = 275;
pub const SSL_R_TICKET_ENCRYPTION_FAILED: u32 = 276;
pub const SSL_R_ALPN_MISMATCH_ON_EARLY_DATA: u32 = 277;
pub const SSL_R_WRONG_VERSION_ON_EARLY_DATA: u32 = 278;
pub const SSL_R_UNEXPECTED_EXTENSION_ON_EARLY_DATA: u32 = 279;
pub const SSL_R_NO_SUPPORTED_VERSIONS_ENABLED: u32 = 280;
pub const SSL_R_APPLICATION_DATA_INSTEAD_OF_HANDSHAKE: u32 = 281;
pub const SSL_R_EMPTY_HELLO_RETRY_REQUEST: u32 = 282;
pub const SSL_R_EARLY_DATA_NOT_IN_USE: u32 = 283;
pub const SSL_R_HANDSHAKE_NOT_COMPLETE: u32 = 284;
pub const SSL_R_NEGOTIATED_TB_WITHOUT_EMS_OR_RI: u32 = 285;
pub const SSL_R_SERVER_ECHOED_INVALID_SESSION_ID: u32 = 286;
pub const SSL_R_PRIVATE_KEY_OPERATION_FAILED: u32 = 287;
pub const SSL_R_SECOND_SERVERHELLO_VERSION_MISMATCH: u32 = 288;
pub const SSL_R_OCSP_CB_ERROR: u32 = 289;
pub const SSL_R_SSL_SESSION_ID_TOO_LONG: u32 = 290;
pub const SSL_R_APPLICATION_DATA_ON_SHUTDOWN: u32 = 291;
pub const SSL_R_CERT_DECOMPRESSION_FAILED: u32 = 292;
pub const SSL_R_UNCOMPRESSED_CERT_TOO_LARGE: u32 = 293;
pub const SSL_R_UNKNOWN_CERT_COMPRESSION_ALG: u32 = 294;
pub const SSL_R_INVALID_SIGNATURE_ALGORITHM: u32 = 295;
pub const SSL_R_DUPLICATE_SIGNATURE_ALGORITHM: u32 = 296;
pub const SSL_R_TLS13_DOWNGRADE: u32 = 297;
pub const SSL_R_QUIC_INTERNAL_ERROR: u32 = 298;
pub const SSL_R_WRONG_ENCRYPTION_LEVEL_RECEIVED: u32 = 299;
pub const SSL_R_TOO_MUCH_READ_EARLY_DATA: u32 = 300;
pub const SSL_R_INVALID_DELEGATED_CREDENTIAL: u32 = 301;
pub const SSL_R_KEY_USAGE_BIT_INCORRECT: u32 = 302;
pub const SSL_R_INCONSISTENT_CLIENT_HELLO: u32 = 303;
pub const SSL_R_CIPHER_MISMATCH_ON_EARLY_DATA: u32 = 304;
pub const SSL_R_QUIC_TRANSPORT_PARAMETERS_MISCONFIGURED: u32 = 305;
pub const SSL_R_UNEXPECTED_COMPATIBILITY_MODE: u32 = 306;
pub const SSL_R_NO_APPLICATION_PROTOCOL: u32 = 307;
pub const SSL_R_NEGOTIATED_ALPS_WITHOUT_ALPN: u32 = 308;
pub const SSL_R_ALPS_MISMATCH_ON_EARLY_DATA: u32 = 309;
pub const SSL_R_ECH_SERVER_CONFIG_AND_PRIVATE_KEY_MISMATCH: u32 = 310;
pub const SSL_R_ECH_SERVER_CONFIG_UNSUPPORTED_EXTENSION: u32 = 311;
pub const SSL_R_UNSUPPORTED_ECH_SERVER_CONFIG: u32 = 312;
pub const SSL_R_ECH_SERVER_WOULD_HAVE_NO_RETRY_CONFIGS: u32 = 313;
pub const SSL_R_INVALID_CLIENT_HELLO_INNER: u32 = 314;
pub const SSL_R_INVALID_ALPN_PROTOCOL_LIST: u32 = 315;
pub const SSL_R_COULD_NOT_PARSE_HINTS: u32 = 316;
pub const SSL_R_INVALID_ECH_PUBLIC_NAME: u32 = 317;
pub const SSL_R_INVALID_ECH_CONFIG_LIST: u32 = 318;
pub const SSL_R_ECH_REJECTED: u32 = 319;
pub const SSL_R_INVALID_OUTER_EXTENSION: u32 = 320;
pub const SSL_R_INCONSISTENT_ECH_NEGOTIATION: u32 = 321;
pub const SSL_R_INVALID_ALPS_CODEPOINT: u32 = 322;
pub const SSL_R_SERIALIZATION_UNSUPPORTED: u32 = 500;
pub const SSL_R_SERIALIZATION_INVALID_SSL: u32 = 501;
pub const SSL_R_SERIALIZATION_INVALID_SSL_CONFIG: u32 = 502;
pub const SSL_R_SERIALIZATION_INVALID_SSL3_STATE: u32 = 503;
pub const SSL_R_SERIALIZATION_INVALID_SSL_BUFFER: u32 = 505;
pub const SSL_R_SERIALIZATION_INVALID_SSL_AEAD_CONTEXT: u32 = 506;
pub const SSL_R_BAD_HYBRID_KEYSHARE: u32 = 507;
pub const SSL_R_BAD_KEM_CIPHERTEXT: u32 = 508;
pub const SSL_R_SSLV3_ALERT_CLOSE_NOTIFY: u32 = 1000;
pub const SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE: u32 = 1010;
pub const SSL_R_SSLV3_ALERT_BAD_RECORD_MAC: u32 = 1020;
pub const SSL_R_TLSV1_ALERT_DECRYPTION_FAILED: u32 = 1021;
pub const SSL_R_TLSV1_ALERT_RECORD_OVERFLOW: u32 = 1022;
pub const SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE: u32 = 1030;
pub const SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE: u32 = 1040;
pub const SSL_R_SSLV3_ALERT_NO_CERTIFICATE: u32 = 1041;
pub const SSL_R_SSLV3_ALERT_BAD_CERTIFICATE: u32 = 1042;
pub const SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE: u32 = 1043;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED: u32 = 1044;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED: u32 = 1045;
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN: u32 = 1046;
pub const SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER: u32 = 1047;
pub const SSL_R_TLSV1_ALERT_UNKNOWN_CA: u32 = 1048;
pub const SSL_R_TLSV1_ALERT_ACCESS_DENIED: u32 = 1049;
pub const SSL_R_TLSV1_ALERT_DECODE_ERROR: u32 = 1050;
pub const SSL_R_TLSV1_ALERT_DECRYPT_ERROR: u32 = 1051;
pub const SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION: u32 = 1060;
pub const SSL_R_TLSV1_ALERT_PROTOCOL_VERSION: u32 = 1070;
pub const SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY: u32 = 1071;
pub const SSL_R_TLSV1_ALERT_INTERNAL_ERROR: u32 = 1080;
pub const SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK: u32 = 1086;
pub const SSL_R_TLSV1_ALERT_USER_CANCELLED: u32 = 1090;
pub const SSL_R_TLSV1_ALERT_NO_RENEGOTIATION: u32 = 1100;
pub const SSL_R_TLSV1_ALERT_UNSUPPORTED_EXTENSION: u32 = 1110;
pub const SSL_R_TLSV1_ALERT_CERTIFICATE_UNOBTAINABLE: u32 = 1111;
pub const SSL_R_TLSV1_ALERT_UNRECOGNIZED_NAME: u32 = 1112;
pub const SSL_R_TLSV1_ALERT_BAD_CERTIFICATE_STATUS_RESPONSE: u32 = 1113;
pub const SSL_R_TLSV1_ALERT_BAD_CERTIFICATE_HASH_VALUE: u32 = 1114;
pub const SSL_R_TLSV1_ALERT_UNKNOWN_PSK_IDENTITY: u32 = 1115;
pub const SSL_R_TLSV1_ALERT_CERTIFICATE_REQUIRED: u32 = 1116;
pub const SSL_R_TLSV1_ALERT_NO_APPLICATION_PROTOCOL: u32 = 1120;
pub const SSL_R_TLSV1_ALERT_ECH_REQUIRED: u32 = 1121;
pub const SSL_R_SERIALIZATION_INVALID_SERDE_VERSION: u32 = 1122;
pub const TRUST_TOKEN_MAX_PRIVATE_KEY_SIZE: u32 = 512;
pub const TRUST_TOKEN_MAX_PUBLIC_KEY_SIZE: u32 = 512;
pub const TRUST_TOKEN_R_KEYGEN_FAILURE: u32 = 100;
pub const TRUST_TOKEN_R_BUFFER_TOO_SMALL: u32 = 101;
pub const TRUST_TOKEN_R_OVER_BATCHSIZE: u32 = 102;
pub const TRUST_TOKEN_R_DECODE_ERROR: u32 = 103;
pub const TRUST_TOKEN_R_SRR_SIGNATURE_ERROR: u32 = 104;
pub const TRUST_TOKEN_R_DECODE_FAILURE: u32 = 105;
pub const TRUST_TOKEN_R_INVALID_METADATA: u32 = 106;
pub const TRUST_TOKEN_R_TOO_MANY_KEYS: u32 = 107;
pub const TRUST_TOKEN_R_NO_KEYS_CONFIGURED: u32 = 108;
pub const TRUST_TOKEN_R_INVALID_KEY_ID: u32 = 109;
pub const TRUST_TOKEN_R_INVALID_TOKEN: u32 = 110;
pub const TRUST_TOKEN_R_BAD_VALIDITY_CHECK: u32 = 111;
pub const TRUST_TOKEN_R_NO_SRR_KEY_CONFIGURED: u32 = 112;
pub const TRUST_TOKEN_R_INVALID_METADATA_KEY: u32 = 113;
pub const TRUST_TOKEN_R_INVALID_PROOF: u32 = 114;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_reserved: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_secure_time_in_system) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_time_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_secure_ptime_in_system) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_ptime_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type ossl_ssize_t = isize;
pub type CBS_ASN1_TAG = u32;
pub type CRYPTO_THREADID = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_null_st {
    _unused: [u8; 0],
}
pub type ASN1_NULL = asn1_null_st;
pub type ASN1_BOOLEAN = ::std::os::raw::c_int;
pub type ASN1_ITEM = ASN1_ITEM_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_object_st {
    _unused: [u8; 0],
}
pub type ASN1_OBJECT = asn1_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_pctx_st {
    _unused: [u8; 0],
}
pub type ASN1_PCTX = asn1_pctx_st;
pub type ASN1_BIT_STRING = asn1_string_st;
pub type ASN1_BMPSTRING = asn1_string_st;
pub type ASN1_ENUMERATED = asn1_string_st;
pub type ASN1_GENERALIZEDTIME = asn1_string_st;
pub type ASN1_GENERALSTRING = asn1_string_st;
pub type ASN1_IA5STRING = asn1_string_st;
pub type ASN1_INTEGER = asn1_string_st;
pub type ASN1_OCTET_STRING = asn1_string_st;
pub type ASN1_PRINTABLESTRING = asn1_string_st;
pub type ASN1_STRING = asn1_string_st;
pub type ASN1_T61STRING = asn1_string_st;
pub type ASN1_TIME = asn1_string_st;
pub type ASN1_UNIVERSALSTRING = asn1_string_st;
pub type ASN1_UTCTIME = asn1_string_st;
pub type ASN1_UTF8STRING = asn1_string_st;
pub type ASN1_VISIBLESTRING = asn1_string_st;
pub type ASN1_TYPE = asn1_type_st;
pub type AUTHORITY_KEYID = AUTHORITY_KEYID_st;
pub type BASIC_CONSTRAINTS = BASIC_CONSTRAINTS_st;
pub type DIST_POINT = DIST_POINT_st;
pub type DSA_SIG = DSA_SIG_st;
pub type GENERAL_NAME = GENERAL_NAME_st;
pub type ISSUING_DIST_POINT = ISSUING_DIST_POINT_st;
pub type NAME_CONSTRAINTS = NAME_CONSTRAINTS_st;
pub type NETSCAPE_SPKAC = Netscape_spkac_st;
pub type NETSCAPE_SPKI = Netscape_spki_st;
pub type RIPEMD160_CTX = RIPEMD160state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_VERIFY_PARAM_st {
    _unused: [u8; 0],
}
pub type X509_VERIFY_PARAM = X509_VERIFY_PARAM_st;
pub type X509_ALGOR = X509_algor_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_crl_st {
    _unused: [u8; 0],
}
pub type X509_CRL = X509_crl_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_extension_st {
    _unused: [u8; 0],
}
pub type X509_EXTENSION = X509_extension_st;
pub type X509_INFO = X509_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_entry_st {
    _unused: [u8; 0],
}
pub type X509_NAME_ENTRY = X509_name_entry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_name_st {
    _unused: [u8; 0],
}
pub type X509_NAME = X509_name_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_pubkey_st {
    _unused: [u8; 0],
}
pub type X509_PUBKEY = X509_pubkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_req_st {
    _unused: [u8; 0],
}
pub type X509_REQ = X509_req_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_sig_info_st {
    _unused: [u8; 0],
}
pub type X509_SIG_INFO = x509_sig_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_sig_st {
    _unused: [u8; 0],
}
pub type X509_SIG = X509_sig_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_ctx {
    _unused: [u8; 0],
}
pub type BN_CTX = bignum_ctx;
pub type BIGNUM = bignum_st;
pub type BIO_METHOD = bio_method_st;
pub type BIO = bio_st;
pub type BLAKE2B_CTX = blake2b_state_st;
pub type BN_GENCB = bn_gencb_st;
pub type BN_MONT_CTX = bn_mont_ctx_st;
pub type BUF_MEM = buf_mem_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cast_key_st {
    _unused: [u8; 0],
}
pub type CAST_KEY = cast_key_st;
pub type CBB = cbb_st;
pub type CBS = cbs_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmac_ctx_st {
    _unused: [u8; 0],
}
pub type CMAC_CTX = cmac_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_st {
    _unused: [u8; 0],
}
pub type CONF = conf_st;
pub type CONF_VALUE = conf_value_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_buffer_pool_st {
    _unused: [u8; 0],
}
pub type CRYPTO_BUFFER_POOL = crypto_buffer_pool_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_buffer_st {
    _unused: [u8; 0],
}
pub type CRYPTO_BUFFER = crypto_buffer_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctr_drbg_state_st {
    _unused: [u8; 0],
}
pub type CTR_DRBG_STATE = ctr_drbg_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    _unused: [u8; 0],
}
pub type DH = dh_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_st {
    _unused: [u8; 0],
}
pub type DSA = dsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group_st {
    _unused: [u8; 0],
}
pub type EC_GROUP = ec_group_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_point_st {
    _unused: [u8; 0],
}
pub type EC_POINT = ec_point_st;
pub type ECDSA_METHOD = ecdsa_method_st;
pub type ECDSA_SIG = ecdsa_sig_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine_st {
    _unused: [u8; 0],
}
pub type ENGINE = engine_st;
pub type EVP_MD_CTX = env_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = env_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_aead_st {
    _unused: [u8; 0],
}
pub type EVP_AEAD = evp_aead_st;
pub type EVP_AEAD_CTX = evp_aead_ctx_st;
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER = evp_cipher_st;
pub type EVP_ENCODE_CTX = evp_encode_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_aead_st {
    _unused: [u8; 0],
}
pub type EVP_HPKE_AEAD = evp_hpke_aead_st;
pub type EVP_HPKE_CTX = evp_hpke_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_kdf_st {
    _unused: [u8; 0],
}
pub type EVP_HPKE_KDF = evp_hpke_kdf_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_kem_st {
    _unused: [u8; 0],
}
pub type EVP_HPKE_KEM = evp_hpke_kem_st;
pub type EVP_HPKE_KEY = evp_hpke_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_kem_st {
    _unused: [u8; 0],
}
pub type EVP_KEM = evp_kem_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kem_key_st {
    _unused: [u8; 0],
}
pub type KEM_KEY = kem_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY_CTX = evp_pkey_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY = evp_pkey_st;
pub type HMAC_CTX = hmac_ctx_st;
pub type MD4_CTX = md4_state_st;
pub type MD5_CTX = md5_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_req_ctx_st {
    _unused: [u8; 0],
}
pub type OCSP_REQ_CTX = ocsp_req_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ossl_init_settings_st {
    _unused: [u8; 0],
}
pub type OPENSSL_INIT_SETTINGS = ossl_init_settings_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs12_st {
    _unused: [u8; 0],
}
pub type PKCS12 = pkcs12_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pkcs8_priv_key_info_st {
    _unused: [u8; 0],
}
pub type PKCS8_PRIV_KEY_INFO = pkcs8_priv_key_info_st;
pub type X509_PKEY = private_key_st;
pub type RAND_METHOD = rand_meth_st;
pub type RC4_KEY = rc4_key_st;
pub type RSA_METHOD = rsa_meth_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsassa_pss_params_st {
    _unused: [u8; 0],
}
pub type RSASSA_PSS_PARAMS = rsassa_pss_params_st;
pub type RSA_PSS_PARAMS = rsa_pss_params_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    _unused: [u8; 0],
}
pub type RSA = rsa_st;
pub type SHA256_CTX = sha256_state_st;
pub type SHA512_CTX = sha512_state_st;
pub type SHA_CTX = sha_state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spake2_ctx_st {
    _unused: [u8; 0],
}
pub type SPAKE2_CTX = spake2_ctx_st;
pub type SRTP_PROTECTION_PROFILE = srtp_protection_profile_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_cipher_st {
    _unused: [u8; 0],
}
pub type SSL_CIPHER = ssl_cipher_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CTX = ssl_ctx_st;
pub type SSL_CLIENT_HELLO = ssl_early_callback_ctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ech_keys_st {
    _unused: [u8; 0],
}
pub type SSL_ECH_KEYS = ssl_ech_keys_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_method_st {
    _unused: [u8; 0],
}
pub type SSL_METHOD = ssl_method_st;
pub type SSL_PRIVATE_KEY_METHOD = ssl_private_key_method_st;
pub type SSL_QUIC_METHOD = ssl_quic_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_session_st {
    _unused: [u8; 0],
}
pub type SSL_SESSION = ssl_session_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_st {
    _unused: [u8; 0],
}
pub type SSL = ssl_st;
pub type SSL_TICKET_AEAD_METHOD = ssl_ticket_aead_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_ERR_FNS {
    _unused: [u8; 0],
}
pub type ERR_FNS = st_ERR_FNS;
pub type TRUST_TOKEN = trust_token_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trust_token_client_st {
    _unused: [u8; 0],
}
pub type TRUST_TOKEN_CLIENT = trust_token_client_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trust_token_issuer_st {
    _unused: [u8; 0],
}
pub type TRUST_TOKEN_ISSUER = trust_token_issuer_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trust_token_method_st {
    _unused: [u8; 0],
}
pub type TRUST_TOKEN_METHOD = trust_token_method_st;
pub type X509V3_CTX = v3_ext_ctx;
pub type X509V3_EXT_METHOD = v3_ext_method;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_attributes_st {
    _unused: [u8; 0],
}
pub type X509_ATTRIBUTE = x509_attributes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP = x509_lookup_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_lookup_method_st {
    _unused: [u8; 0],
}
pub type X509_LOOKUP_METHOD = x509_lookup_method_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_object_st {
    _unused: [u8; 0],
}
pub type X509_OBJECT = x509_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_revoked_st {
    _unused: [u8; 0],
}
pub type X509_REVOKED = x509_revoked_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_st {
    _unused: [u8; 0],
}
pub type X509 = x509_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_ctx_st {
    _unused: [u8; 0],
}
pub type X509_STORE_CTX = x509_store_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_st {
    _unused: [u8; 0],
}
pub type X509_STORE = x509_store_st;
pub type X509_TRUST = x509_trust_st;
pub type OPENSSL_BLOCK = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn EVP_aead_aes_128_gcm() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_192_gcm() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_chacha20_poly1305() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_xchacha20_poly1305() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ctr_hmac_sha256() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_ctr_hmac_sha256() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_siv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_siv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_randnonce() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_randnonce() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ccm_bluetooth() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ccm_bluetooth_8() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_ccm_matter() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_has_aes_hardware() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_key_length(aead: *const EVP_AEAD) -> usize;
}
extern "C" {
    pub fn EVP_AEAD_nonce_length(aead: *const EVP_AEAD) -> usize;
}
extern "C" {
    pub fn EVP_AEAD_max_overhead(aead: *const EVP_AEAD) -> usize;
}
extern "C" {
    pub fn EVP_AEAD_max_tag_len(aead: *const EVP_AEAD) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evp_aead_ctx_st_state {
    pub opaque: [u8; 564usize],
    pub alignment: u64,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_evp_aead_ctx_st_state() {
    const UNINIT: ::std::mem::MaybeUninit<evp_aead_ctx_st_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_aead_ctx_st_state>(),
        568usize,
        concat!("Size of: ", stringify!(evp_aead_ctx_st_state))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_aead_ctx_st_state>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_aead_ctx_st_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st_state),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st_state),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st_state),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_aead_ctx_st {
    pub aead: *const EVP_AEAD,
    pub state: evp_aead_ctx_st_state,
    pub state_offset: u8,
    pub tag_len: u8,
}
#[test]
fn bindgen_test_layout_evp_aead_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<evp_aead_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_aead_ctx_st>(),
        584usize,
        concat!("Size of: ", stringify!(evp_aead_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_aead_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_aead_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st),
            "::",
            stringify!(aead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_offset) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st),
            "::",
            stringify!(state_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_len) as usize - ptr as usize },
        577usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_aead_ctx_st),
            "::",
            stringify!(tag_len)
        )
    );
}
extern "C" {
    pub fn EVP_AEAD_CTX_zero(ctx: *mut EVP_AEAD_CTX);
}
extern "C" {
    pub fn EVP_AEAD_CTX_new(
        aead: *const EVP_AEAD,
        key: *const u8,
        key_len: usize,
        tag_len: usize,
    ) -> *mut EVP_AEAD_CTX;
}
extern "C" {
    pub fn EVP_AEAD_CTX_free(ctx: *mut EVP_AEAD_CTX);
}
extern "C" {
    pub fn EVP_AEAD_CTX_init(
        ctx: *mut EVP_AEAD_CTX,
        aead: *const EVP_AEAD,
        key: *const u8,
        key_len: usize,
        tag_len: usize,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_cleanup(ctx: *mut EVP_AEAD_CTX);
}
extern "C" {
    pub fn EVP_AEAD_CTX_seal(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        out_len: *mut usize,
        max_out_len: usize,
        nonce: *const u8,
        nonce_len: usize,
        in_: *const u8,
        in_len: usize,
        ad: *const u8,
        ad_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_open(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        out_len: *mut usize,
        max_out_len: usize,
        nonce: *const u8,
        nonce_len: usize,
        in_: *const u8,
        in_len: usize,
        ad: *const u8,
        ad_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_seal_scatter(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        out_tag: *mut u8,
        out_tag_len: *mut usize,
        max_out_tag_len: usize,
        nonce: *const u8,
        nonce_len: usize,
        in_: *const u8,
        in_len: usize,
        extra_in: *const u8,
        extra_in_len: usize,
        ad: *const u8,
        ad_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_open_gather(
        ctx: *const EVP_AEAD_CTX,
        out: *mut u8,
        nonce: *const u8,
        nonce_len: usize,
        in_: *const u8,
        in_len: usize,
        in_tag: *const u8,
        in_tag_len: usize,
        ad: *const u8,
        ad_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_aead(ctx: *const EVP_AEAD_CTX) -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_cbc_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_cbc_sha1_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_cbc_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_cbc_sha1_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_cbc_sha256_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_cbc_sha256_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_cbc_sha384_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_des_ede3_cbc_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_des_ede3_cbc_sha1_tls_implicit_iv() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_null_sha1_tls() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_tls12() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_tls12() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_128_gcm_tls13() -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_aead_aes_256_gcm_tls13() -> *const EVP_AEAD;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum evp_aead_direction_t {
    evp_aead_open = 0,
    evp_aead_seal = 1,
}
extern "C" {
    pub fn EVP_AEAD_CTX_init_with_direction(
        ctx: *mut EVP_AEAD_CTX,
        aead: *const EVP_AEAD,
        key: *const u8,
        key_len: usize,
        tag_len: usize,
        dir: evp_aead_direction_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_get_iv(
        ctx: *const EVP_AEAD_CTX,
        out_iv: *mut *const u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_CTX_tag_len(
        ctx: *const EVP_AEAD_CTX,
        out_tag_len: *mut usize,
        in_len: usize,
        extra_in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_AEAD_get_iv_from_ipv4_nanosecs(
        ipv4_address: u32,
        nanosecs: u64,
        out_iv: *mut u8,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aes_key_st {
    pub rd_key: [u32; 60usize],
    pub rounds: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_aes_key_st() {
    const UNINIT: ::std::mem::MaybeUninit<aes_key_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aes_key_st>(),
        244usize,
        concat!("Size of: ", stringify!(aes_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<aes_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(aes_key_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rd_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_key_st),
            "::",
            stringify!(rd_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rounds) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_key_st),
            "::",
            stringify!(rounds)
        )
    );
}
pub type AES_KEY = aes_key_st;
extern "C" {
    pub fn AES_set_encrypt_key(
        key: *const u8,
        bits: ::std::os::raw::c_uint,
        aeskey: *mut AES_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_set_decrypt_key(
        key: *const u8,
        bits: ::std::os::raw::c_uint,
        aeskey: *mut AES_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_encrypt(in_: *const u8, out: *mut u8, key: *const AES_KEY);
}
extern "C" {
    pub fn AES_decrypt(in_: *const u8, out: *mut u8, key: *const AES_KEY);
}
extern "C" {
    pub fn AES_ctr128_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        key: *const AES_KEY,
        ivec: *mut u8,
        ecount_buf: *mut u8,
        num: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn AES_ecb_encrypt(
        in_: *const u8,
        out: *mut u8,
        key: *const AES_KEY,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        key: *const AES_KEY,
        ivec: *mut u8,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_ofb128_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        key: *const AES_KEY,
        ivec: *mut u8,
        num: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_cfb128_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        key: *const AES_KEY,
        ivec: *mut u8,
        num: *mut ::std::os::raw::c_int,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn AES_wrap_key(
        key: *const AES_KEY,
        iv: *const u8,
        out: *mut u8,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_unwrap_key(
        key: *const AES_KEY,
        iv: *const u8,
        out: *mut u8,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_wrap_key_padded(
        key: *const AES_KEY,
        out: *mut u8,
        out_len: *mut usize,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AES_unwrap_key_padded(
        key: *const AES_KEY,
        out: *mut u8,
        out_len: *mut usize,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_mem_st {
    pub length: usize,
    pub data: *mut ::std::os::raw::c_char,
    pub max: usize,
}
#[test]
fn bindgen_test_layout_buf_mem_st() {
    const UNINIT: ::std::mem::MaybeUninit<buf_mem_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<buf_mem_st>(),
        24usize,
        concat!("Size of: ", stringify!(buf_mem_st))
    );
    assert_eq!(
        ::std::mem::align_of::<buf_mem_st>(),
        8usize,
        concat!("Alignment of ", stringify!(buf_mem_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(buf_mem_st),
            "::",
            stringify!(max)
        )
    );
}
extern "C" {
    pub fn BUF_MEM_new() -> *mut BUF_MEM;
}
extern "C" {
    pub fn BUF_MEM_free(buf: *mut BUF_MEM);
}
extern "C" {
    pub fn BUF_MEM_reserve(buf: *mut BUF_MEM, cap: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BUF_MEM_grow(buf: *mut BUF_MEM, len: usize) -> usize;
}
extern "C" {
    pub fn BUF_MEM_grow_clean(buf: *mut BUF_MEM, len: usize) -> usize;
}
extern "C" {
    pub fn BUF_MEM_append(
        buf: *mut BUF_MEM,
        in_: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BUF_strdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BUF_strnlen(str_: *const ::std::os::raw::c_char, max_len: usize) -> usize;
}
extern "C" {
    pub fn BUF_strndup(
        str_: *const ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BUF_memdup(
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BUF_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn BUF_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn SHA1_Init(sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Update(
        sha: *mut SHA_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1_Final(out: *mut u8, sha: *mut SHA_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA1(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn SHA1_Transform(sha: *mut SHA_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha_state_st {
    pub h: [u32; 5usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_sha_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<sha_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sha_state_st>(),
        96usize,
        concat!("Size of: ", stringify!(sha_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(sha_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nl) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sha_state_st),
            "::",
            stringify!(num)
        )
    );
}
extern "C" {
    pub fn SHA224_Init(sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Update(
        sha: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224_Final(out: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA224(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn SHA256_Init(sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Update(
        sha: *mut SHA256_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256_Final(out: *mut u8, sha: *mut SHA256_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA256(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn SHA256_Transform(sha: *mut SHA256_CTX, block: *const u8);
}
extern "C" {
    pub fn SHA256_TransformBlocks(state: *mut u32, data: *const u8, num_blocks: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha256_state_st {
    pub h: [u32; 8usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_sha256_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<sha256_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sha256_state_st>(),
        112usize,
        concat!("Size of: ", stringify!(sha256_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha256_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nh) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_len) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_state_st),
            "::",
            stringify!(md_len)
        )
    );
}
extern "C" {
    pub fn SHA384_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA384(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn SHA512_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn SHA512_Transform(sha: *mut SHA512_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha512_state_st {
    pub h: [u64; 8usize],
    pub Nl: u64,
    pub Nh: u64,
    pub p: [u8; 128usize],
    pub num: ::std::os::raw::c_uint,
    pub md_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_sha512_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<sha512_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sha512_state_st>(),
        216usize,
        concat!("Size of: ", stringify!(sha512_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<sha512_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nl) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nh) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_len) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_state_st),
            "::",
            stringify!(md_len)
        )
    );
}
extern "C" {
    pub fn SHA512_224_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_224_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_224_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_224(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn SHA512_256_Init(sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_256_Update(
        sha: *mut SHA512_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_256_Final(out: *mut u8, sha: *mut SHA512_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SHA512_256(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn OPENSSL_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_zalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_calloc(num: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn OPENSSL_cleanse(ptr: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn CRYPTO_memcmp(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_hash32(ptr: *const ::std::os::raw::c_void, len: usize) -> u32;
}
extern "C" {
    pub fn OPENSSL_strhash(s: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn OPENSSL_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_strnlen(s: *const ::std::os::raw::c_char, len: usize) -> usize;
}
extern "C" {
    pub fn OPENSSL_isalpha(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_isdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_isxdigit(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_fromxdigit(out: *mut u8, c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_isalnum(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_tolower(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_isspace(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strcasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strncasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_snprintf(
        buf: *mut ::std::os::raw::c_char,
        n: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        n: usize,
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_vasprintf(
        str_: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_asprintf(
        str_: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_strndup(
        str_: *const ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OPENSSL_memdup(
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn OPENSSL_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dst_size: usize,
    ) -> usize;
}
extern "C" {
    pub fn CRYPTO_malloc(
        size: usize,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_realloc(
        ptr: *mut ::std::os::raw::c_void,
        new_size: usize,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn CRYPTO_free(
        ptr: *mut ::std::os::raw::c_void,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn OPENSSL_clear_free(ptr: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn CRYPTO_set_mem_functions(
        m: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: usize,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        r: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
                arg3: *const ::std::os::raw::c_char,
                arg4: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void,
        >,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_init(size: usize, min_size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_malloc_initialized() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_secure_used() -> usize;
}
extern "C" {
    pub fn OPENSSL_secure_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_secure_zalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_secure_clear_free(ptr: *mut ::std::os::raw::c_void, len: usize);
}
pub type CRYPTO_MUTEX = pthread_rwlock_t;
pub type CRYPTO_refcount_t = u32;
extern "C" {
    pub fn AWSLC_thread_local_clear() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AWSLC_thread_local_shutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_num_locks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_set_locking_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                mode: ::std::os::raw::c_int,
                lock_num: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_add_lock_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(
                num: *mut ::std::os::raw::c_int,
                amount: ::std::os::raw::c_int,
                lock_num: ::std::os::raw::c_int,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_locking_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn CRYPTO_get_lock_name(lock_num: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CRYPTO_THREADID_set_callback(
        threadid_func: ::std::option::Option<unsafe extern "C" fn(threadid: *mut CRYPTO_THREADID)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_THREADID_set_numeric(id: *mut CRYPTO_THREADID, val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn CRYPTO_THREADID_set_pointer(id: *mut CRYPTO_THREADID, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn CRYPTO_THREADID_current(id: *mut CRYPTO_THREADID);
}
extern "C" {
    pub fn CRYPTO_set_id_callback(
        func: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock {
    pub references: ::std::os::raw::c_int,
    pub data: *mut CRYPTO_dynlock_value,
}
#[test]
fn bindgen_test_layout_CRYPTO_dynlock() {
    const UNINIT: ::std::mem::MaybeUninit<CRYPTO_dynlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CRYPTO_dynlock>(),
        16usize,
        concat!("Size of: ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CRYPTO_dynlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CRYPTO_dynlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).references) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_dynlock),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_dynlock),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_create_callback(
        dyn_create_function: ::std::option::Option<
            unsafe extern "C" fn(
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ) -> *mut CRYPTO_dynlock_value,
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_lock_callback(
        dyn_lock_function: ::std::option::Option<
            unsafe extern "C" fn(
                mode: ::std::os::raw::c_int,
                l: *mut CRYPTO_dynlock_value,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_set_dynlock_destroy_callback(
        dyn_destroy_function: ::std::option::Option<
            unsafe extern "C" fn(
                l: *mut CRYPTO_dynlock_value,
                file: *const ::std::os::raw::c_char,
                line: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn CRYPTO_get_dynlock_create_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> *mut CRYPTO_dynlock_value,
    >;
}
extern "C" {
    pub fn CRYPTO_get_dynlock_lock_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut CRYPTO_dynlock_value,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn CRYPTO_get_dynlock_destroy_callback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut CRYPTO_dynlock_value,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn CRYPTO_library_init();
}
extern "C" {
    pub fn CRYPTO_is_confidential_build() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_has_asm() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BORINGSSL_self_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BORINGSSL_integrity_test() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_pre_sandbox_init();
}
extern "C" {
    pub fn FIPS_mode() -> ::std::os::raw::c_int;
}
impl fips_counter_t {
    pub const fips_counter_max: fips_counter_t = fips_counter_t::fips_counter_evp_aes_256_ctr;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum fips_counter_t {
    fips_counter_evp_aes_128_gcm = 0,
    fips_counter_evp_aes_256_gcm = 1,
    fips_counter_evp_aes_128_ctr = 2,
    fips_counter_evp_aes_256_ctr = 3,
}
extern "C" {
    pub fn FIPS_read_counter(counter: fips_counter_t) -> usize;
}
extern "C" {
    pub fn OpenSSL_version(which: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSLeay_version(which: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSLeay() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn OpenSSL_version_num() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn awslc_api_version_num() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn CRYPTO_malloc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_malloc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ENGINE_load_builtin_engines();
}
extern "C" {
    pub fn ENGINE_register_all_complete() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_load_builtin_modules();
}
extern "C" {
    pub fn OPENSSL_init_crypto(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_init();
}
extern "C" {
    pub fn OPENSSL_cleanup();
}
extern "C" {
    pub fn FIPS_mode_set(on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_BIO_strings();
}
extern "C" {
    pub fn ERR_load_ERR_strings();
}
extern "C" {
    pub fn ERR_load_CRYPTO_strings();
}
extern "C" {
    pub fn ERR_load_crypto_strings();
}
extern "C" {
    pub fn ERR_load_RAND_strings();
}
extern "C" {
    pub fn ERR_free_strings();
}
extern "C" {
    pub fn ERR_get_error() -> u32;
}
extern "C" {
    pub fn ERR_get_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_get_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_error() -> u32;
}
extern "C" {
    pub fn ERR_peek_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_last_error() -> u32;
}
extern "C" {
    pub fn ERR_peek_last_error_line(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_peek_last_error_line_data(
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
        data: *mut *const ::std::os::raw::c_char,
        flags: *mut ::std::os::raw::c_int,
    ) -> u32;
}
extern "C" {
    pub fn ERR_error_string_n(
        packed_error: u32,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_lib_error_string(packed_error: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_reason_error_string(packed_error: u32) -> *const ::std::os::raw::c_char;
}
pub type ERR_print_errors_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ERR_print_errors_cb(
        callback: ERR_print_errors_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ERR_print_errors_fp(file: *mut FILE);
}
extern "C" {
    pub fn ERR_clear_error();
}
extern "C" {
    pub fn ERR_set_mark() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_pop_to_mark() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_get_next_error_library() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_remove_state(pid: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ERR_remove_thread_state(tid: *const CRYPTO_THREADID);
}
extern "C" {
    pub fn ERR_func_error_string(packed_error: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_error_string(
        packed_error: u32,
        buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ERR_clear_system_error();
}
extern "C" {
    pub fn ERR_put_error(
        library: ::std::os::raw::c_int,
        unused: ::std::os::raw::c_int,
        reason: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn ERR_add_error_data(count: ::std::os::raw::c_uint, ...);
}
extern "C" {
    pub fn ERR_add_error_dataf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ERR_set_error_data(data: *mut ::std::os::raw::c_char, flags: ::std::os::raw::c_int);
}
pub type OPENSSL_sk_free_func =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
pub type OPENSSL_sk_copy_func = ::std::option::Option<
    unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type OPENSSL_sk_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const *const ::std::os::raw::c_void,
        b: *const *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type OPENSSL_sk_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type OPENSSL_sk_call_free_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: OPENSSL_sk_free_func, arg2: *mut ::std::os::raw::c_void),
>;
pub type OPENSSL_sk_call_copy_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: OPENSSL_sk_copy_func,
        arg2: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type OPENSSL_sk_call_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: OPENSSL_sk_cmp_func,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type OPENSSL_sk_call_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: OPENSSL_sk_delete_if_func,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st {
    _unused: [u8; 0],
}
pub type OPENSSL_STACK = stack_st;
extern "C" {
    pub fn OPENSSL_sk_new(comp: OPENSSL_sk_cmp_func) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_new_null() -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_num(sk: *const OPENSSL_STACK) -> usize;
}
extern "C" {
    pub fn OPENSSL_sk_zero(sk: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_value(sk: *const OPENSSL_STACK, i: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_set(
        sk: *mut OPENSSL_STACK,
        i: usize,
        p: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_free(sk: *mut OPENSSL_STACK);
}
extern "C" {
    pub fn OPENSSL_sk_pop_free_ex(
        sk: *mut OPENSSL_STACK,
        call_free_func: OPENSSL_sk_call_free_func,
        free_func: OPENSSL_sk_free_func,
    );
}
extern "C" {
    pub fn OPENSSL_sk_insert(
        sk: *mut OPENSSL_STACK,
        p: *mut ::std::os::raw::c_void,
        where_: usize,
    ) -> usize;
}
extern "C" {
    pub fn OPENSSL_sk_delete(sk: *mut OPENSSL_STACK, where_: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_delete_ptr(
        sk: *mut OPENSSL_STACK,
        p: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_delete_if(
        sk: *mut OPENSSL_STACK,
        call_func: OPENSSL_sk_call_delete_if_func,
        func: OPENSSL_sk_delete_if_func,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OPENSSL_sk_find(
        sk: *const OPENSSL_STACK,
        out_index: *mut usize,
        p: *const ::std::os::raw::c_void,
        call_cmp_func: OPENSSL_sk_call_cmp_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_unshift(
        sk: *mut OPENSSL_STACK,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_shift(sk: *mut OPENSSL_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_push(sk: *mut OPENSSL_STACK, p: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn OPENSSL_sk_pop(sk: *mut OPENSSL_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OPENSSL_sk_dup(sk: *const OPENSSL_STACK) -> *mut OPENSSL_STACK;
}
extern "C" {
    pub fn OPENSSL_sk_sort(sk: *mut OPENSSL_STACK, call_cmp_func: OPENSSL_sk_call_cmp_func);
}
extern "C" {
    pub fn OPENSSL_sk_is_sorted(sk: *const OPENSSL_STACK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_sk_set_cmp_func(
        sk: *mut OPENSSL_STACK,
        comp: OPENSSL_sk_cmp_func,
    ) -> OPENSSL_sk_cmp_func;
}
extern "C" {
    pub fn OPENSSL_sk_deep_copy(
        sk: *const OPENSSL_STACK,
        call_copy_func: OPENSSL_sk_call_copy_func,
        copy_func: OPENSSL_sk_copy_func,
        call_free_func: OPENSSL_sk_call_free_func,
        free_func: OPENSSL_sk_free_func,
    ) -> *mut OPENSSL_STACK;
}
pub type _STACK = OPENSSL_STACK;
extern "C" {
    pub fn sk_pop_free(sk: *mut OPENSSL_STACK, free_func: OPENSSL_sk_free_func);
}
pub type OPENSSL_STRING = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_void {
    _unused: [u8; 0],
}
pub type sk_void_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type sk_void_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type sk_void_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ::std::os::raw::c_void,
        arg2: *const *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_void_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OPENSSL_STRING {
    _unused: [u8; 0],
}
pub type sk_OPENSSL_STRING_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char)>;
pub type sk_OPENSSL_STRING_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
pub type sk_OPENSSL_STRING_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OPENSSL_STRING_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type CRYPTO_EX_DATA = crypto_ex_data_st;
pub type CRYPTO_EX_free = ::std::option::Option<
    unsafe extern "C" fn(
        parent: *mut ::std::os::raw::c_void,
        ptr: *mut ::std::os::raw::c_void,
        ad: *mut CRYPTO_EX_DATA,
        index: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn CRYPTO_cleanup_all_ex_data();
}
pub type CRYPTO_EX_dup = ::std::option::Option<
    unsafe extern "C" fn(
        to: *mut CRYPTO_EX_DATA,
        from: *const CRYPTO_EX_DATA,
        from_d: *mut *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type CRYPTO_EX_unused = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_ex_data_st {
    pub sk: *mut stack_st_void,
}
#[test]
fn bindgen_test_layout_crypto_ex_data_st() {
    const UNINIT: ::std::mem::MaybeUninit<crypto_ex_data_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Size of: ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_ex_data_st>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_ex_data_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_ex_data_st),
            "::",
            stringify!(sk)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_BIO {
    _unused: [u8; 0],
}
pub type sk_BIO_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO)>;
pub type sk_BIO_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const BIO) -> *mut BIO>;
pub type sk_BIO_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const *const BIO, arg2: *const *const BIO) -> ::std::os::raw::c_int,
>;
pub type sk_BIO_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut BIO,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn BIO_new(method: *const BIO_METHOD) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_vfree(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_up_ref(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read(
        bio: *mut BIO,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read_ex(
        bio: *mut BIO,
        data: *mut ::std::os::raw::c_void,
        data_len: usize,
        read_bytes: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_gets(
        bio: *mut BIO,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write(
        bio: *mut BIO,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write_ex(
        bio: *mut BIO,
        data: *const ::std::os::raw::c_void,
        data_len: usize,
        written_bytes: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write_all(
        bio: *mut BIO,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_puts(bio: *mut BIO, buf: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_flush(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ctrl(
        bio: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        parg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_ptr_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_int_ctrl(
        bp: *mut BIO,
        cmd: ::std::os::raw::c_int,
        larg: ::std::os::raw::c_long,
        iarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_reset(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_eof(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_flags(bio: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_test_flags(bio: *const BIO, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_read(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_write(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_retry(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_should_io_special(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_retry_reason(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_retry_reason(bio: *mut BIO, reason: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_clear_flags(bio: *mut BIO, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_set_retry_read(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_set_retry_write(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_get_retry_flags(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_clear_retry_flags(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_method_type(bio: *const BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_method_name(b: *const BIO) -> *const ::std::os::raw::c_char;
}
pub type bio_info_cb = ::std::option::Option<
    unsafe extern "C" fn(
        b: *mut BIO,
        state: ::std::os::raw::c_int,
        res: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long,
>;
pub type BIO_callback_fn_ex = ::std::option::Option<
    unsafe extern "C" fn(
        bio: *mut BIO,
        oper: ::std::os::raw::c_int,
        argp: *const ::std::os::raw::c_char,
        len: usize,
        argi: ::std::os::raw::c_int,
        argl: ::std::os::raw::c_long,
        bio_ret: ::std::os::raw::c_int,
        processed: *mut usize,
    ) -> ::std::os::raw::c_long,
>;
extern "C" {
    pub fn BIO_callback_ctrl(
        bio: *mut BIO,
        cmd: ::std::os::raw::c_int,
        fp: bio_info_cb,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_pending(bio: *const BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_pending(bio: *const BIO) -> usize;
}
extern "C" {
    pub fn BIO_wpending(bio: *const BIO) -> usize;
}
extern "C" {
    pub fn BIO_set_close(bio: *mut BIO, close_flag: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_number_read(bio: *const BIO) -> usize;
}
extern "C" {
    pub fn BIO_number_written(bio: *const BIO) -> usize;
}
extern "C" {
    pub fn BIO_set_callback_ex(bio: *mut BIO, callback_ex: BIO_callback_fn_ex);
}
extern "C" {
    pub fn BIO_set_callback_arg(bio: *mut BIO, arg: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn BIO_get_callback_arg(bio: *const BIO) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BIO_push(bio: *mut BIO, appended_bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_pop(bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_next(bio: *mut BIO) -> *mut BIO;
}
extern "C" {
    pub fn BIO_free_all(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_find_type(bio: *mut BIO, type_: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_copy_next_retry(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_printf(
        bio: *mut BIO,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_indent(
        bio: *mut BIO,
        indent: ::std::os::raw::c_uint,
        max_indent: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_hexdump(
        bio: *mut BIO,
        data: *const u8,
        len: usize,
        indent: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_print_errors(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_read_asn1(
        bio: *mut BIO,
        out: *mut *mut u8,
        out_len: *mut usize,
        max_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_mem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_mem_buf(buf: *const ::std::os::raw::c_void, len: ossl_ssize_t) -> *mut BIO;
}
extern "C" {
    pub fn BIO_mem_contents(
        bio: *const BIO,
        out_contents: *mut *const u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_mem_ptr(bio: *mut BIO, out: *mut *mut BUF_MEM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_mem_buf(
        bio: *mut BIO,
        b: *mut BUF_MEM,
        take_ownership: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_mem_eof_return(
        bio: *mut BIO,
        eof_value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_fd() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_fd(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_fd(
        bio: *mut BIO,
        fd: ::std::os::raw::c_int,
        close_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_fd(bio: *mut BIO, out_fd: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_s_file() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_file(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut BIO;
}
extern "C" {
    pub fn BIO_new_fp(stream: *mut FILE, close_flag: ::std::os::raw::c_int) -> *mut BIO;
}
extern "C" {
    pub fn BIO_get_fp(bio: *mut BIO, out_file: *mut *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_fp(
        bio: *mut BIO,
        file: *mut FILE,
        close_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_read_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_write_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_append_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_rw_filename(
        bio: *mut BIO,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_tell(bio: *mut BIO) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_seek(bio: *mut BIO, offset: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn BIO_s_socket() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_socket(fd: ::std::os::raw::c_int, close_flag: ::std::os::raw::c_int)
        -> *mut BIO;
}
extern "C" {
    pub fn BIO_s_connect() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_new_connect(host_and_optional_port: *const ::std::os::raw::c_char) -> *mut BIO;
}
extern "C" {
    pub fn BIO_set_conn_hostname(
        bio: *mut BIO,
        host_and_optional_port: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_conn_port(
        bio: *mut BIO,
        port_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_conn_int_port(
        bio: *mut BIO,
        port: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_nbio(bio: *mut BIO, on: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_do_connect(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_new_bio_pair(
        out1: *mut *mut BIO,
        writebuf1: usize,
        out2: *mut *mut BIO,
        writebuf2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_ctrl_get_read_request(bio: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_ctrl_get_write_guarantee(bio: *mut BIO) -> usize;
}
extern "C" {
    pub fn BIO_shutdown_wr(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_new_index() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_new(
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> *mut BIO_METHOD;
}
extern "C" {
    pub fn BIO_meth_free(method: *mut BIO_METHOD);
}
extern "C" {
    pub fn BIO_meth_set_create(
        method: *mut BIO_METHOD,
        create: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_create(
        method: *const BIO_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(method: *mut BIO) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_destroy(
        method: *mut BIO_METHOD,
        destroy: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_destroy(
        method: *const BIO_METHOD,
    ) -> ::std::option::Option<unsafe extern "C" fn(method: *mut BIO) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn BIO_meth_set_write(
        method: *mut BIO_METHOD,
        write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_read(
        method: *mut BIO_METHOD,
        read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_gets(
        method: *mut BIO_METHOD,
        gets: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_gets(
        method: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            method: *mut BIO,
            arg1: *mut ::std::os::raw::c_char,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_meth_set_ctrl(
        method: *mut BIO_METHOD,
        ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::std::os::raw::c_int,
                arg3: ::std::os::raw::c_long,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_long,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_ctrl(
        method: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            method: *mut BIO,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_long,
            arg3: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn BIO_meth_set_callback_ctrl(
        method: *mut BIO_METHOD,
        callback_ctrl: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: ::std::os::raw::c_int,
                arg3: bio_info_cb,
            ) -> ::std::os::raw::c_long,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_callback_ctrl(
        method: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            method: *mut BIO,
            arg1: ::std::os::raw::c_int,
            arg2: bio_info_cb,
        ) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn BIO_set_data(bio: *mut BIO, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn BIO_get_data(bio: *mut BIO) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_set_init(bio: *mut BIO, init: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_init(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_set_ex_data(
        bio: *mut BIO,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_get_ex_data(
        bio: *const BIO,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BIO_f_base64() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_retry_special(bio: *mut BIO);
}
extern "C" {
    pub fn BIO_set_shutdown(bio: *mut BIO, shutdown: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BIO_get_shutdown(bio: *mut BIO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_set_puts(
        method: *mut BIO_METHOD,
        puts: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut BIO,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_meth_get_puts(
        method: *const BIO_METHOD,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            method: *mut BIO,
            arg1: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn BIO_s_secmem() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_write_buffer_size(
        bio: *mut BIO,
        buffer_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_method_st {
    pub type_: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub bwrite: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bread: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub bputs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub bgets: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_long,
            arg4: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_long,
    >,
    pub create:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int>,
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut BIO) -> ::std::os::raw::c_int>,
    pub callback_ctrl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut BIO,
            arg2: ::std::os::raw::c_int,
            arg3: bio_info_cb,
        ) -> ::std::os::raw::c_long,
    >,
}
#[test]
fn bindgen_test_layout_bio_method_st() {
    const UNINIT: ::std::mem::MaybeUninit<bio_method_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bio_method_st>(),
        80usize,
        concat!("Size of: ", stringify!(bio_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bio_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_method_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bwrite) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bputs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bgets) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(bgets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_ctrl) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_method_st),
            "::",
            stringify!(callback_ctrl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_st {
    pub method: *const BIO_METHOD,
    pub ex_data: CRYPTO_EX_DATA,
    pub callback_ex: BIO_callback_fn_ex,
    pub cb_arg: *mut ::std::os::raw::c_char,
    pub init: ::std::os::raw::c_int,
    pub shutdown: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub retry_reason: ::std::os::raw::c_int,
    pub num: ::std::os::raw::c_int,
    pub references: CRYPTO_refcount_t,
    pub ptr: *mut ::std::os::raw::c_void,
    pub next_bio: *mut BIO,
    pub num_read: usize,
    pub num_write: usize,
}
#[test]
fn bindgen_test_layout_bio_st() {
    const UNINIT: ::std::mem::MaybeUninit<bio_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bio_st>(),
        88usize,
        concat!("Size of: ", stringify!(bio_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bio_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bio_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ex_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(ex_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_ex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(callback_ex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_arg) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(cb_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retry_reason) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(retry_reason)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).references) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_bio) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(next_bio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_read) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(num_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bio_st),
            "::",
            stringify!(num_write)
        )
    );
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type BN_ULONG = u64;
extern "C" {
    pub fn BN_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_init(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_free(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_clear_free(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_dup(src: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_copy(dest: *mut BIGNUM, src: *const BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_clear(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_value_one() -> *const BIGNUM;
}
extern "C" {
    pub fn BN_num_bits(bn: *const BIGNUM) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn BN_num_bytes(bn: *const BIGNUM) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn BN_zero(bn: *mut BIGNUM);
}
extern "C" {
    pub fn BN_one(bn: *mut BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_word(bn: *mut BIGNUM, value: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_u64(bn: *mut BIGNUM, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_negative(bn: *mut BIGNUM, sign: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BN_is_negative(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bin2bn(in_: *const u8, len: usize, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2bin(in_: *const BIGNUM, out: *mut u8) -> usize;
}
extern "C" {
    pub fn BN_le2bn(in_: *const u8, len: usize, ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_bn2le_padded(out: *mut u8, len: usize, in_: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2bin_padded(out: *mut u8, len: usize, in_: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2cbb_padded(out: *mut CBB, len: usize, in_: *const BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2hex(bn: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_hex2bn(
        outp: *mut *mut BIGNUM,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2dec(a: *const BIGNUM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn BN_dec2bn(
        outp: *mut *mut BIGNUM,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_asc2bn(
        outp: *mut *mut BIGNUM,
        in_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print(bio: *mut BIO, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_print_fp(fp: *mut FILE, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_word(bn: *const BIGNUM) -> BN_ULONG;
}
extern "C" {
    pub fn BN_get_u64(bn: *const BIGNUM, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_get_flags(bn: *const BIGNUM, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_parse_asn1_unsigned(cbs: *mut CBS, ret: *mut BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_marshal_asn1(cbb: *mut CBB, bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_CTX_new() -> *mut BN_CTX;
}
extern "C" {
    pub fn BN_CTX_free(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_start(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_CTX_get(ctx: *mut BN_CTX) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_end(ctx: *mut BN_CTX);
}
extern "C" {
    pub fn BN_add(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_uadd(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_add_word(a: *mut BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_usub(r: *mut BIGNUM, a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sub_word(a: *mut BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mul_word(bn: *mut BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_sqr(r: *mut BIGNUM, a: *const BIGNUM, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div(
        quotient: *mut BIGNUM,
        rem: *mut BIGNUM,
        numerator: *const BIGNUM,
        divisor: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_div_word(numerator: *mut BIGNUM, divisor: BN_ULONG) -> BN_ULONG;
}
extern "C" {
    pub fn BN_sqrt(
        out_sqrt: *mut BIGNUM,
        in_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_cmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_cmp_word(a: *const BIGNUM, b: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_ucmp(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_equal_consttime(a: *const BIGNUM, b: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_abs_is_word(bn: *const BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_zero(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_one(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_word(bn: *const BIGNUM, w: BN_ULONG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_odd(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_pow2(a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_lshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rshift1(r: *mut BIGNUM, a: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_set_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_clear_bit(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_bit_set(a: *const BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mask_bits(a: *mut BIGNUM, n: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_count_low_zero_bits(bn: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_word(a: *const BIGNUM, w: BN_ULONG) -> BN_ULONG;
}
extern "C" {
    pub fn BN_mod_pow2(r: *mut BIGNUM, a: *const BIGNUM, e: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nnmod_pow2(r: *mut BIGNUM, a: *const BIGNUM, e: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_nnmod(
        rem: *mut BIGNUM,
        numerator: *const BIGNUM,
        divisor: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_add_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sub_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sqr(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        n: ::std::os::raw::c_int,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_lshift1_quick(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        m: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_sqrt(
        in_: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand(
        rnd: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_rand_range_ex(
        r: *mut BIGNUM,
        min_inclusive: BN_ULONG,
        max_exclusive: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_pseudo_rand_range(rnd: *mut BIGNUM, range: *const BIGNUM) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bn_gencb_st {
    pub type_: u8,
    pub arg: *mut ::std::os::raw::c_void,
    pub callback: bn_gencb_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bn_gencb_st__bindgen_ty_1 {
    pub new_style: ::std::option::Option<
        unsafe extern "C" fn(
            event: ::std::os::raw::c_int,
            n: ::std::os::raw::c_int,
            arg1: *mut bn_gencb_st,
        ) -> ::std::os::raw::c_int,
    >,
    pub old_style: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_bn_gencb_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<bn_gencb_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bn_gencb_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bn_gencb_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_gencb_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_gencb_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st__bindgen_ty_1),
            "::",
            stringify!(new_style)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).old_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st__bindgen_ty_1),
            "::",
            stringify!(old_style)
        )
    );
}
#[test]
fn bindgen_test_layout_bn_gencb_st() {
    const UNINIT: ::std::mem::MaybeUninit<bn_gencb_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bn_gencb_st>(),
        24usize,
        concat!("Size of: ", stringify!(bn_gencb_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_gencb_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_gencb_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_gencb_st),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    pub fn BN_GENCB_new() -> *mut BN_GENCB;
}
extern "C" {
    pub fn BN_GENCB_free(callback: *mut BN_GENCB);
}
extern "C" {
    pub fn BN_GENCB_set(
        callback: *mut BN_GENCB,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                event: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                arg1: *mut BN_GENCB,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn BN_GENCB_call(
        callback: *mut BN_GENCB,
        event: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GENCB_get_arg(callback: *const BN_GENCB) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn BN_generate_prime_ex(
        ret: *mut BIGNUM,
        bits: ::std::os::raw::c_int,
        safe: ::std::os::raw::c_int,
        add: *const BIGNUM,
        rem: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum bn_primality_result_t {
    bn_probably_prime = 0,
    bn_composite = 1,
    bn_non_prime_power_composite = 2,
}
extern "C" {
    pub fn BN_enhanced_miller_rabin_primality_test(
        out_result: *mut bn_primality_result_t,
        w: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_primality_test(
        is_probably_prime: *mut ::std::os::raw::c_int,
        candidate: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_fasttest_ex(
        candidate: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        do_trial_division: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_is_prime_ex(
        candidate: *const BIGNUM,
        checks: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_gcd(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_inverse(
        out: *mut BIGNUM,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_inverse_blinded(
        out: *mut BIGNUM,
        out_no_inverse: *mut ::std::os::raw::c_int,
        a: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_inverse_odd(
        out: *mut BIGNUM,
        out_no_inverse: *mut ::std::os::raw::c_int,
        a: *const BIGNUM,
        n: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new_for_modulus(mod_: *const BIGNUM, ctx: *mut BN_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_new_consttime(mod_: *const BIGNUM, ctx: *mut BN_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_free(mont: *mut BN_MONT_CTX);
}
extern "C" {
    pub fn BN_MONT_CTX_copy(to: *mut BN_MONT_CTX, from: *const BN_MONT_CTX) -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_to_montgomery(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_from_montgomery(
        ret: *mut BIGNUM,
        a: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_mul_montgomery(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        mont: *const BN_MONT_CTX,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont(
        r: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp_mont_consttime(
        rr: *mut BIGNUM,
        a: *const BIGNUM,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_GENCB_set_old(
        callback: *mut BN_GENCB,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn BN_bn2mpi(in_: *const BIGNUM, out: *mut u8) -> usize;
}
extern "C" {
    pub fn BN_mpi2bn(in_: *const u8, len: usize, out: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_mod_exp_mont_word(
        r: *mut BIGNUM,
        a: BN_ULONG,
        p: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_mod_exp2_mont(
        r: *mut BIGNUM,
        a1: *const BIGNUM,
        p1: *const BIGNUM,
        a2: *const BIGNUM,
        p2: *const BIGNUM,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
        mont: *const BN_MONT_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_MONT_CTX_new() -> *mut BN_MONT_CTX;
}
extern "C" {
    pub fn BN_MONT_CTX_set(
        mont: *mut BN_MONT_CTX,
        mod_: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_bn2binpad(
        in_: *const BIGNUM,
        out: *mut u8,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_secure_new() -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_CTX_secure_new() -> *mut BN_CTX;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bignum_st {
    pub d: *mut BN_ULONG,
    pub width: ::std::os::raw::c_int,
    pub dmax: ::std::os::raw::c_int,
    pub neg: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bignum_st() {
    const UNINIT: ::std::mem::MaybeUninit<bignum_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bignum_st>(),
        24usize,
        concat!("Size of: ", stringify!(bignum_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bignum_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bignum_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmax) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(dmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).neg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(neg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bignum_st),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bn_mont_ctx_st {
    pub RR: BIGNUM,
    pub N: BIGNUM,
    pub n0: [BN_ULONG; 2usize],
}
#[test]
fn bindgen_test_layout_bn_mont_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<bn_mont_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bn_mont_ctx_st>(),
        64usize,
        concat!("Size of: ", stringify!(bn_mont_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bn_mont_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(bn_mont_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(RR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n0) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bn_mont_ctx_st),
            "::",
            stringify!(n0)
        )
    );
}
extern "C" {
    pub fn BN_num_bits_word(l: BN_ULONG) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ASN1_tag2bit(tag: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_tag2str(tag: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub type d2i_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut *const ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type i2d_of_void = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ITEM_EXP = ASN1_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_VALUE_st {
    _unused: [u8; 0],
}
pub type ASN1_VALUE = ASN1_VALUE_st;
extern "C" {
    pub fn ASN1_item_new(it: *const ASN1_ITEM) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_free(val: *mut ASN1_VALUE, it: *const ASN1_ITEM);
}
extern "C" {
    pub fn ASN1_item_d2i(
        out: *mut *mut ASN1_VALUE,
        inp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        it: *const ASN1_ITEM,
    ) -> *mut ASN1_VALUE;
}
extern "C" {
    pub fn ASN1_item_i2d(
        val: *mut ASN1_VALUE,
        outp: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_dup(
        i2d: i2d_of_void,
        d2i: d2i_of_void,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_dup(
        it: *const ASN1_ITEM,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_fp(
        it: *const ASN1_ITEM,
        in_: *mut FILE,
        out: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_d2i_bio(
        it: *const ASN1_ITEM,
        in_: *mut BIO,
        out: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_i2d_fp(
        it: *const ASN1_ITEM,
        out: *mut FILE,
        in_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_i2d_bio(
        it: *const ASN1_ITEM,
        out: *mut BIO,
        in_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_i2d_bio(
        i2d: i2d_of_void,
        out: *mut BIO,
        in_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_unpack(
        oct: *const ASN1_STRING,
        it: *const ASN1_ITEM,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_item_pack(
        obj: *mut ::std::os::raw::c_void,
        it: *const ASN1_ITEM,
        out: *mut *mut ASN1_STRING,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn d2i_ASN1_BOOLEAN(
        out: *mut ASN1_BOOLEAN,
        inp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ASN1_BOOLEAN;
}
extern "C" {
    pub fn i2d_ASN1_BOOLEAN(
        a: ASN1_BOOLEAN,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_BOOLEAN_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_TBOOLEAN_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_FBOOLEAN_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_string_st {
    pub length: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_asn1_string_st() {
    const UNINIT: ::std::mem::MaybeUninit<asn1_string_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<asn1_string_st>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_string_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_string_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_string_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_string_st),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn ASN1_STRING_type_new(type_: ::std::os::raw::c_int) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_clear_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub fn ASN1_STRING_copy(
        dst: *mut ASN1_STRING,
        str_: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_dup(str_: *const ASN1_STRING) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_type(str_: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get0_data(str_: *const ASN1_STRING) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_data(str_: *mut ASN1_STRING) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ASN1_STRING_length(str_: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_cmp(a: *const ASN1_STRING, b: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set(
        str_: *mut ASN1_STRING,
        data: *const ::std::os::raw::c_void,
        len: ossl_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set0(
        str_: *mut ASN1_STRING,
        data: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_BMPSTRING_new() -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn ASN1_GENERALSTRING_new() -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn ASN1_IA5STRING_new() -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_new() -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_new() -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn ASN1_T61STRING_new() -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_new() -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn ASN1_UTF8STRING_new() -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_new() -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn ASN1_BMPSTRING_free(str_: *mut ASN1_BMPSTRING);
}
extern "C" {
    pub fn ASN1_GENERALSTRING_free(str_: *mut ASN1_GENERALSTRING);
}
extern "C" {
    pub fn ASN1_IA5STRING_free(str_: *mut ASN1_IA5STRING);
}
extern "C" {
    pub fn ASN1_OCTET_STRING_free(str_: *mut ASN1_OCTET_STRING);
}
extern "C" {
    pub fn ASN1_PRINTABLESTRING_free(str_: *mut ASN1_PRINTABLESTRING);
}
extern "C" {
    pub fn ASN1_T61STRING_free(str_: *mut ASN1_T61STRING);
}
extern "C" {
    pub fn ASN1_UNIVERSALSTRING_free(str_: *mut ASN1_UNIVERSALSTRING);
}
extern "C" {
    pub fn ASN1_UTF8STRING_free(str_: *mut ASN1_UTF8STRING);
}
extern "C" {
    pub fn ASN1_VISIBLESTRING_free(str_: *mut ASN1_VISIBLESTRING);
}
extern "C" {
    pub fn d2i_ASN1_BMPSTRING(
        out: *mut *mut ASN1_BMPSTRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BMPSTRING;
}
extern "C" {
    pub fn d2i_ASN1_GENERALSTRING(
        out: *mut *mut ASN1_GENERALSTRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALSTRING;
}
extern "C" {
    pub fn d2i_ASN1_IA5STRING(
        out: *mut *mut ASN1_IA5STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_IA5STRING;
}
extern "C" {
    pub fn d2i_ASN1_OCTET_STRING(
        out: *mut *mut ASN1_OCTET_STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLESTRING(
        out: *mut *mut ASN1_PRINTABLESTRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_PRINTABLESTRING;
}
extern "C" {
    pub fn d2i_ASN1_T61STRING(
        out: *mut *mut ASN1_T61STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_T61STRING;
}
extern "C" {
    pub fn d2i_ASN1_UNIVERSALSTRING(
        out: *mut *mut ASN1_UNIVERSALSTRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UNIVERSALSTRING;
}
extern "C" {
    pub fn d2i_ASN1_UTF8STRING(
        out: *mut *mut ASN1_UTF8STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTF8STRING;
}
extern "C" {
    pub fn d2i_ASN1_VISIBLESTRING(
        out: *mut *mut ASN1_VISIBLESTRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_VISIBLESTRING;
}
extern "C" {
    pub fn i2d_ASN1_BMPSTRING(
        in_: *const ASN1_BMPSTRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_GENERALSTRING(
        in_: *const ASN1_GENERALSTRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_IA5STRING(
        in_: *const ASN1_IA5STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_OCTET_STRING(
        in_: *const ASN1_OCTET_STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLESTRING(
        in_: *const ASN1_PRINTABLESTRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_T61STRING(
        in_: *const ASN1_T61STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_UNIVERSALSTRING(
        in_: *const ASN1_UNIVERSALSTRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_UTF8STRING(
        in_: *const ASN1_UTF8STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ASN1_VISIBLESTRING(
        in_: *const ASN1_VISIBLESTRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_BMPSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_GENERALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_IA5STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_OCTET_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_PRINTABLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_T61STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_UNIVERSALSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_UTF8STRING_it: ASN1_ITEM;
}
extern "C" {
    pub static ASN1_VISIBLESTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_dup(a: *const ASN1_OCTET_STRING) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_cmp(
        a: *const ASN1_OCTET_STRING,
        b: *const ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_OCTET_STRING_set(
        str_: *mut ASN1_OCTET_STRING,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_to_UTF8(
        out: *mut *mut ::std::os::raw::c_uchar,
        in_: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_copy(
        out: *mut *mut ASN1_STRING,
        in_: *const u8,
        len: ossl_ssize_t,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_mbstring_ncopy(
        out: *mut *mut ASN1_STRING,
        in_: *const u8,
        len: ossl_ssize_t,
        inform: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_ulong,
        minsize: ossl_ssize_t,
        maxsize: ossl_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_set_by_NID(
        out: *mut *mut ASN1_STRING,
        in_: *const ::std::os::raw::c_uchar,
        len: ossl_ssize_t,
        inform: ::std::os::raw::c_int,
        nid: ::std::os::raw::c_int,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_add(
        nid: ::std::os::raw::c_int,
        minsize: ::std::os::raw::c_long,
        maxsize: ::std::os::raw::c_long,
        mask: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DIRECTORYSTRING_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DIRECTORYSTRING_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DIRECTORYSTRING(
        out: *mut *mut ASN1_STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DIRECTORYSTRING(
        in_: *const ASN1_STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DIRECTORYSTRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn DISPLAYTEXT_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn DISPLAYTEXT_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_DISPLAYTEXT(
        out: *mut *mut ASN1_STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_DISPLAYTEXT(in_: *const ASN1_STRING, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DISPLAYTEXT_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BIT_STRING_new() -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn ASN1_BIT_STRING_free(str_: *mut ASN1_BIT_STRING);
}
extern "C" {
    pub fn d2i_ASN1_BIT_STRING(
        out: *mut *mut ASN1_BIT_STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2d_ASN1_BIT_STRING(
        in_: *const ASN1_BIT_STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2i_ASN1_BIT_STRING(
        out: *mut *mut ASN1_BIT_STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn i2c_ASN1_BIT_STRING(
        in_: *const ASN1_BIT_STRING,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_BIT_STRING_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_BIT_STRING_num_bytes(
        str_: *const ASN1_BIT_STRING,
        out: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set(
        str_: *mut ASN1_BIT_STRING,
        d: *const ::std::os::raw::c_uchar,
        length: ossl_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_set_bit(
        str_: *mut ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_get_bit(
        str_: *const ASN1_BIT_STRING,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_BIT_STRING_check(
        str_: *const ASN1_BIT_STRING,
        flags: *const ::std::os::raw::c_uchar,
        flags_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_INTEGER {
    _unused: [u8; 0],
}
pub type sk_ASN1_INTEGER_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ASN1_INTEGER)>;
pub type sk_ASN1_INTEGER_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ASN1_INTEGER) -> *mut ASN1_INTEGER>;
pub type sk_ASN1_INTEGER_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ASN1_INTEGER,
        arg2: *const *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_INTEGER_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ASN1_INTEGER,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ASN1_INTEGER_new() -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_free(str_: *mut ASN1_INTEGER);
}
extern "C" {
    pub fn ASN1_INTEGER_dup(x: *const ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn d2i_ASN1_INTEGER(
        out: *mut *mut ASN1_INTEGER,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2d_ASN1_INTEGER(in_: *const ASN1_INTEGER, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2i_ASN1_INTEGER(
        in_: *mut *mut ASN1_INTEGER,
        outp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2c_ASN1_INTEGER(in_: *const ASN1_INTEGER, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_INTEGER_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_INTEGER_set_uint64(out: *mut ASN1_INTEGER, v: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_set_int64(out: *mut ASN1_INTEGER, v: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get_uint64(out: *mut u64, a: *const ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get_int64(out: *mut i64, a: *const ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_to_ASN1_INTEGER(bn: *const BIGNUM, ai: *mut ASN1_INTEGER) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn ASN1_INTEGER_to_BN(ai: *const ASN1_INTEGER, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_INTEGER_cmp(
        x: *const ASN1_INTEGER,
        y: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_new() -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_free(str_: *mut ASN1_ENUMERATED);
}
extern "C" {
    pub fn d2i_ASN1_ENUMERATED(
        out: *mut *mut ASN1_ENUMERATED,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn i2d_ASN1_ENUMERATED(
        in_: *const ASN1_ENUMERATED,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_ENUMERATED_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set_uint64(out: *mut ASN1_ENUMERATED, v: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set_int64(out: *mut ASN1_ENUMERATED, v: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get_uint64(
        out: *mut u64,
        a: *const ASN1_ENUMERATED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get_int64(
        out: *mut i64,
        a: *const ASN1_ENUMERATED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BN_to_ASN1_ENUMERATED(
        bn: *const BIGNUM,
        ai: *mut ASN1_ENUMERATED,
    ) -> *mut ASN1_ENUMERATED;
}
extern "C" {
    pub fn ASN1_ENUMERATED_to_BN(ai: *const ASN1_ENUMERATED, bn: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn ASN1_UTCTIME_new() -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_free(str_: *mut ASN1_UTCTIME);
}
extern "C" {
    pub fn d2i_ASN1_UTCTIME(
        out: *mut *mut ASN1_UTCTIME,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn i2d_ASN1_UTCTIME(in_: *const ASN1_UTCTIME, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_UTCTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_UTCTIME_check(a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_set(s: *mut ASN1_UTCTIME, posix_time: i64) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_adj(
        s: *mut ASN1_UTCTIME,
        posix_time: i64,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_UTCTIME;
}
extern "C" {
    pub fn ASN1_UTCTIME_set_string(
        s: *mut ASN1_UTCTIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_cmp_time_t(s: *const ASN1_UTCTIME, t: time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_new() -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_free(str_: *mut ASN1_GENERALIZEDTIME);
}
extern "C" {
    pub fn d2i_ASN1_GENERALIZEDTIME(
        out: *mut *mut ASN1_GENERALIZEDTIME,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn i2d_ASN1_GENERALIZEDTIME(
        in_: *const ASN1_GENERALIZEDTIME,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_GENERALIZEDTIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_check(a: *const ASN1_GENERALIZEDTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set(
        s: *mut ASN1_GENERALIZEDTIME,
        posix_time: i64,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_adj(
        s: *mut ASN1_GENERALIZEDTIME,
        posix_time: i64,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_set_string(
        s: *mut ASN1_GENERALIZEDTIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_new() -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_free(str_: *mut ASN1_TIME);
}
extern "C" {
    pub fn d2i_ASN1_TIME(
        out: *mut *mut ASN1_TIME,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn i2d_ASN1_TIME(in_: *const ASN1_TIME, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_TIME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TIME_diff(
        out_days: *mut ::std::os::raw::c_int,
        out_seconds: *mut ::std::os::raw::c_int,
        from: *const ASN1_TIME,
        to: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_set_posix(s: *mut ASN1_TIME, posix_time: i64) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_set(s: *mut ASN1_TIME, time: time_t) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_adj(
        s: *mut ASN1_TIME,
        posix_time: i64,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn ASN1_TIME_check(t: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_generalizedtime(
        t: *const ASN1_TIME,
        out: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> *mut ASN1_GENERALIZEDTIME;
}
extern "C" {
    pub fn ASN1_TIME_set_string(
        s: *mut ASN1_TIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_tm(t: *const ASN1_TIME, out: *mut tm) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_set_string_X509(
        s: *mut ASN1_TIME,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_time_t(t: *const ASN1_TIME, out: *mut time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_to_posix(t: *const ASN1_TIME, out: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_NULL_new() -> *mut ASN1_NULL;
}
extern "C" {
    pub fn ASN1_NULL_free(null: *mut ASN1_NULL);
}
extern "C" {
    pub fn d2i_ASN1_NULL(
        out: *mut *mut ASN1_NULL,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_NULL;
}
extern "C" {
    pub fn i2d_ASN1_NULL(in_: *const ASN1_NULL, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_NULL_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_OBJECT {
    _unused: [u8; 0],
}
pub type sk_ASN1_OBJECT_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ASN1_OBJECT)>;
pub type sk_ASN1_OBJECT_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ASN1_OBJECT) -> *mut ASN1_OBJECT>;
pub type sk_ASN1_OBJECT_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ASN1_OBJECT,
        arg2: *const *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_OBJECT_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ASN1_OBJECT,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ASN1_OBJECT_create(
        nid: ::std::os::raw::c_int,
        data: *const u8,
        len: usize,
        sn: *const ::std::os::raw::c_char,
        ln: *const ::std::os::raw::c_char,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn ASN1_OBJECT_free(a: *mut ASN1_OBJECT);
}
extern "C" {
    pub fn d2i_ASN1_OBJECT(
        out: *mut *mut ASN1_OBJECT,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn i2d_ASN1_OBJECT(in_: *const ASN1_OBJECT, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c2i_ASN1_OBJECT(
        out: *mut *mut ASN1_OBJECT,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub static ASN1_OBJECT_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_type_st {
    pub type_: ::std::os::raw::c_int,
    pub value: asn1_type_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union asn1_type_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub boolean: ASN1_BOOLEAN,
    pub asn1_string: *mut ASN1_STRING,
    pub object: *mut ASN1_OBJECT,
    pub integer: *mut ASN1_INTEGER,
    pub enumerated: *mut ASN1_ENUMERATED,
    pub bit_string: *mut ASN1_BIT_STRING,
    pub octet_string: *mut ASN1_OCTET_STRING,
    pub printablestring: *mut ASN1_PRINTABLESTRING,
    pub t61string: *mut ASN1_T61STRING,
    pub ia5string: *mut ASN1_IA5STRING,
    pub generalstring: *mut ASN1_GENERALSTRING,
    pub bmpstring: *mut ASN1_BMPSTRING,
    pub universalstring: *mut ASN1_UNIVERSALSTRING,
    pub utctime: *mut ASN1_UTCTIME,
    pub generalizedtime: *mut ASN1_GENERALIZEDTIME,
    pub visiblestring: *mut ASN1_VISIBLESTRING,
    pub utf8string: *mut ASN1_UTF8STRING,
    pub set: *mut ASN1_STRING,
    pub sequence: *mut ASN1_STRING,
    pub asn1_value: *mut ASN1_VALUE,
}
#[test]
fn bindgen_test_layout_asn1_type_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<asn1_type_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(enumerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bit_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).octet_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(octet_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).printablestring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(printablestring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t61string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(t61string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ia5string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(ia5string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generalstring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalstring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bmpstring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(bmpstring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).universalstring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(universalstring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utctime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utctime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generalizedtime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(generalizedtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visiblestring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(visiblestring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utf8string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(utf8string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st__bindgen_ty_1),
            "::",
            stringify!(asn1_value)
        )
    );
}
#[test]
fn bindgen_test_layout_asn1_type_st() {
    const UNINIT: ::std::mem::MaybeUninit<asn1_type_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<asn1_type_st>(),
        16usize,
        concat!("Size of: ", stringify!(asn1_type_st))
    );
    assert_eq!(
        ::std::mem::align_of::<asn1_type_st>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_type_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_type_st),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_TYPE {
    _unused: [u8; 0],
}
pub type sk_ASN1_TYPE_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ASN1_TYPE)>;
pub type sk_ASN1_TYPE_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ASN1_TYPE) -> *mut ASN1_TYPE>;
pub type sk_ASN1_TYPE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ASN1_TYPE,
        arg2: *const *const ASN1_TYPE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_TYPE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ASN1_TYPE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ASN1_TYPE_new() -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn ASN1_TYPE_free(a: *mut ASN1_TYPE);
}
extern "C" {
    pub fn d2i_ASN1_TYPE(
        out: *mut *mut ASN1_TYPE,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_TYPE;
}
extern "C" {
    pub fn i2d_ASN1_TYPE(in_: *const ASN1_TYPE, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_ANY_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_TYPE_get(a: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_set(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ASN1_TYPE_set1(
        a: *mut ASN1_TYPE,
        type_: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TYPE_cmp(a: *const ASN1_TYPE, b: *const ASN1_TYPE) -> ::std::os::raw::c_int;
}
pub type ASN1_SEQUENCE_ANY = stack_st_ASN1_TYPE;
extern "C" {
    pub fn d2i_ASN1_SEQUENCE_ANY(
        out: *mut *mut ASN1_SEQUENCE_ANY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SEQUENCE_ANY(
        in_: *const ASN1_SEQUENCE_ANY,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ASN1_SET_ANY(
        out: *mut *mut ASN1_SEQUENCE_ANY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_SEQUENCE_ANY;
}
extern "C" {
    pub fn i2d_ASN1_SET_ANY(
        in_: *const ASN1_SEQUENCE_ANY,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_UTCTIME_print(out: *mut BIO, a: *const ASN1_UTCTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_GENERALIZEDTIME_print(
        out: *mut BIO,
        a: *const ASN1_GENERALIZEDTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_TIME_print(out: *mut BIO, a: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print(out: *mut BIO, str_: *const ASN1_STRING) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex(
        out: *mut BIO,
        str_: *const ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_print_ex_fp(
        fp: *mut FILE,
        str_: *const ASN1_STRING,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_INTEGER(bp: *mut BIO, a: *const ASN1_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_ENUMERATED(bp: *mut BIO, a: *const ASN1_ENUMERATED) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_OBJECT(bp: *mut BIO, a: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2a_ASN1_STRING(
        bp: *mut BIO,
        a: *const ASN1_STRING,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2t_ASN1_OBJECT(
        buf: *mut ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        a: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_get_object(
        inp: *mut *const ::std::os::raw::c_uchar,
        out_length: *mut ::std::os::raw::c_long,
        out_tag: *mut ::std::os::raw::c_int,
        out_class: *mut ::std::os::raw::c_int,
        max_len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_put_object(
        outp: *mut *mut ::std::os::raw::c_uchar,
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
        xclass: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ASN1_put_eoc(outp: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_object_size(
        constructed: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
        tag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_PRINTABLE_new() -> *mut ASN1_STRING;
}
extern "C" {
    pub fn ASN1_PRINTABLE_free(str_: *mut ASN1_STRING);
}
extern "C" {
    pub fn d2i_ASN1_PRINTABLE(
        out: *mut *mut ASN1_STRING,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn i2d_ASN1_PRINTABLE(in_: *const ASN1_STRING, outp: *mut *mut u8)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ASN1_PRINTABLE_it: ASN1_ITEM;
}
extern "C" {
    pub fn ASN1_INTEGER_set(
        a: *mut ASN1_INTEGER,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_ENUMERATED_set(
        a: *mut ASN1_ENUMERATED,
        v: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_INTEGER_get(a: *const ASN1_INTEGER) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ASN1_ENUMERATED_get(a: *const ASN1_ENUMERATED) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask(mask: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ASN1_STRING_set_default_mask_asc(
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_STRING_get_default_mask() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ASN1_STRING_TABLE_cleanup();
}
pub type ASN1_TEMPLATE = ASN1_TEMPLATE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TLC_st {
    _unused: [u8; 0],
}
pub type ASN1_TLC = ASN1_TLC_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_TEMPLATE_st {
    pub flags: u32,
    pub tag: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_ulong,
    pub field_name: *const ::std::os::raw::c_char,
    pub item: *const ASN1_ITEM_st,
}
#[test]
fn bindgen_test_layout_ASN1_TEMPLATE_st() {
    const UNINIT: ::std::mem::MaybeUninit<ASN1_TEMPLATE_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASN1_TEMPLATE_st>(),
        32usize,
        concat!("Size of: ", stringify!(ASN1_TEMPLATE_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_TEMPLATE_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_TEMPLATE_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_TEMPLATE_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_TEMPLATE_st),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_TEMPLATE_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_TEMPLATE_st),
            "::",
            stringify!(field_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_TEMPLATE_st),
            "::",
            stringify!(item)
        )
    );
}
pub type ASN1_ADB_TABLE = ASN1_ADB_TABLE_st;
pub type ASN1_ADB = ASN1_ADB_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_must_be_null_st {
    _unused: [u8; 0],
}
pub type ASN1_MUST_BE_NULL = asn1_must_be_null_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ADB_st {
    pub flags: u32,
    pub offset: ::std::os::raw::c_ulong,
    pub unused: *mut ASN1_MUST_BE_NULL,
    pub tbl: *const ASN1_ADB_TABLE,
    pub tblcount: ::std::os::raw::c_long,
    pub default_tt: *const ASN1_TEMPLATE,
    pub null_tt: *const ASN1_TEMPLATE,
}
#[test]
fn bindgen_test_layout_ASN1_ADB_st() {
    const UNINIT: ::std::mem::MaybeUninit<ASN1_ADB_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASN1_ADB_st>(),
        56usize,
        concat!("Size of: ", stringify!(ASN1_ADB_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ADB_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ADB_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tbl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tblcount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(tblcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_tt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(default_tt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).null_tt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_st),
            "::",
            stringify!(null_tt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ADB_TABLE_st {
    pub value: ::std::os::raw::c_int,
    pub tt: ASN1_TEMPLATE,
}
#[test]
fn bindgen_test_layout_ASN1_ADB_TABLE_st() {
    const UNINIT: ::std::mem::MaybeUninit<ASN1_ADB_TABLE_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASN1_ADB_TABLE_st>(),
        40usize,
        concat!("Size of: ", stringify!(ASN1_ADB_TABLE_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ADB_TABLE_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ADB_TABLE_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_TABLE_st),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ADB_TABLE_st),
            "::",
            stringify!(tt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_ITEM_st {
    pub itype: ::std::os::raw::c_char,
    pub utype: ::std::os::raw::c_int,
    pub templates: *const ASN1_TEMPLATE,
    pub tcount: ::std::os::raw::c_long,
    pub funcs: *const ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_long,
    pub sname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ASN1_ITEM_st() {
    const UNINIT: ::std::mem::MaybeUninit<ASN1_ITEM_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASN1_ITEM_st>(),
        48usize,
        concat!("Size of: ", stringify!(ASN1_ITEM_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_ITEM_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_ITEM_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(utype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).templates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(templates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(tcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_ITEM_st),
            "::",
            stringify!(sname)
        )
    );
}
pub type ASN1_new_func = ::std::option::Option<unsafe extern "C" fn() -> *mut ASN1_VALUE>;
pub type ASN1_free_func = ::std::option::Option<unsafe extern "C" fn(a: *mut ASN1_VALUE)>;
pub type ASN1_d2i_func = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut *mut ASN1_VALUE,
        in_: *mut *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_long,
    ) -> *mut ASN1_VALUE,
>;
pub type ASN1_i2d_func = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ASN1_VALUE,
        in_: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_d2i = ::std::option::Option<
    unsafe extern "C" fn(
        pval: *mut *mut ASN1_VALUE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        it: *const ASN1_ITEM,
        tag: ::std::os::raw::c_int,
        aclass: ::std::os::raw::c_int,
        opt: ::std::os::raw::c_char,
        ctx: *mut ASN1_TLC,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_i2d = ::std::option::Option<
    unsafe extern "C" fn(
        pval: *mut *mut ASN1_VALUE,
        out: *mut *mut ::std::os::raw::c_uchar,
        it: *const ASN1_ITEM,
        tag: ::std::os::raw::c_int,
        aclass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_new_func = ::std::option::Option<
    unsafe extern "C" fn(pval: *mut *mut ASN1_VALUE, it: *const ASN1_ITEM) -> ::std::os::raw::c_int,
>;
pub type ASN1_ex_free_func =
    ::std::option::Option<unsafe extern "C" fn(pval: *mut *mut ASN1_VALUE, it: *const ASN1_ITEM)>;
pub type ASN1_ex_print_func = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut BIO,
        pval: *mut *mut ASN1_VALUE,
        indent: ::std::os::raw::c_int,
        fname: *const ::std::os::raw::c_char,
        pctx: *const ASN1_PCTX,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_EXTERN_FUNCS_st {
    pub app_data: *mut ::std::os::raw::c_void,
    pub asn1_ex_new: ASN1_ex_new_func,
    pub asn1_ex_free: ASN1_ex_free_func,
    pub asn1_ex_d2i: ASN1_ex_d2i,
    pub asn1_ex_i2d: ASN1_ex_i2d,
    pub asn1_ex_print: ASN1_ex_print_func,
}
#[test]
fn bindgen_test_layout_ASN1_EXTERN_FUNCS_st() {
    const UNINIT: ::std::mem::MaybeUninit<ASN1_EXTERN_FUNCS_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASN1_EXTERN_FUNCS_st>(),
        48usize,
        concat!("Size of: ", stringify!(ASN1_EXTERN_FUNCS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_EXTERN_FUNCS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_EXTERN_FUNCS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_ex_new) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_ex_free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_ex_d2i) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_d2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_ex_i2d) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_i2d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_ex_print) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_EXTERN_FUNCS_st),
            "::",
            stringify!(asn1_ex_print)
        )
    );
}
pub type ASN1_EXTERN_FUNCS = ASN1_EXTERN_FUNCS_st;
pub type ASN1_aux_cb = ::std::option::Option<
    unsafe extern "C" fn(
        operation: ::std::os::raw::c_int,
        in_: *mut *mut ASN1_VALUE,
        it: *const ASN1_ITEM,
        exarg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ASN1_AUX_st {
    pub app_data: *mut ::std::os::raw::c_void,
    pub flags: u32,
    pub ref_offset: ::std::os::raw::c_int,
    pub asn1_cb: ASN1_aux_cb,
    pub enc_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ASN1_AUX_st() {
    const UNINIT: ::std::mem::MaybeUninit<ASN1_AUX_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ASN1_AUX_st>(),
        32usize,
        concat!("Size of: ", stringify!(ASN1_AUX_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ASN1_AUX_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ASN1_AUX_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_AUX_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_AUX_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_AUX_st),
            "::",
            stringify!(ref_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asn1_cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_AUX_st),
            "::",
            stringify!(asn1_cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enc_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ASN1_AUX_st),
            "::",
            stringify!(enc_offset)
        )
    );
}
pub type ASN1_AUX = ASN1_AUX_st;
extern "C" {
    pub static ASN1_SEQUENCE_it: ASN1_ITEM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ASN1_VALUE {
    _unused: [u8; 0],
}
pub type sk_ASN1_VALUE_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ASN1_VALUE)>;
pub type sk_ASN1_VALUE_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ASN1_VALUE) -> *mut ASN1_VALUE>;
pub type sk_ASN1_VALUE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ASN1_VALUE,
        arg2: *const *const ASN1_VALUE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ASN1_VALUE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ASN1_VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn EVP_EncodeBlock(dst: *mut u8, src: *const u8, src_len: usize) -> usize;
}
extern "C" {
    pub fn EVP_EncodedLength(out_len: *mut usize, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodedLength(out_len: *mut usize, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeBase64(
        out: *mut u8,
        out_len: *mut usize,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_new() -> *mut EVP_ENCODE_CTX;
}
extern "C" {
    pub fn EVP_ENCODE_CTX_free(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_EncodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn EVP_DecodeInit(ctx: *mut EVP_ENCODE_CTX);
}
extern "C" {
    pub fn EVP_DecodeUpdate(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeFinal(
        ctx: *mut EVP_ENCODE_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecodeBlock(dst: *mut u8, src: *const u8, src_len: usize) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_encode_ctx_st {
    pub data_used: ::std::os::raw::c_uint,
    pub data: [u8; 48usize],
    pub eof_seen: ::std::os::raw::c_char,
    pub error_encountered: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_evp_encode_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<evp_encode_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_encode_ctx_st>(),
        56usize,
        concat!("Size of: ", stringify!(evp_encode_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_encode_ctx_st>(),
        4usize,
        concat!("Alignment of ", stringify!(evp_encode_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_used) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_encode_ctx_st),
            "::",
            stringify!(data_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_encode_ctx_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eof_seen) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_encode_ctx_st),
            "::",
            stringify!(eof_seen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_encountered) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_encode_ctx_st),
            "::",
            stringify!(error_encountered)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blake2b_state_st {
    pub h: [u64; 8usize],
    pub t_low: u64,
    pub t_high: u64,
    pub block: [u8; 128usize],
    pub block_used: usize,
}
#[test]
fn bindgen_test_layout_blake2b_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<blake2b_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blake2b_state_st>(),
        216usize,
        concat!("Size of: ", stringify!(blake2b_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<blake2b_state_st>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_low) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state_st),
            "::",
            stringify!(t_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_high) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state_st),
            "::",
            stringify!(t_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state_st),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_used) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state_st),
            "::",
            stringify!(block_used)
        )
    );
}
extern "C" {
    pub fn BLAKE2B256_Init(b2b: *mut BLAKE2B_CTX);
}
extern "C" {
    pub fn BLAKE2B256_Update(
        b2b: *mut BLAKE2B_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    );
}
extern "C" {
    pub fn BLAKE2B256_Final(out: *mut u8, b2b: *mut BLAKE2B_CTX);
}
extern "C" {
    pub fn BLAKE2B256(data: *const u8, len: usize, out: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bf_key_st {
    pub P: [u32; 18usize],
    pub S: [u32; 1024usize],
}
#[test]
fn bindgen_test_layout_bf_key_st() {
    const UNINIT: ::std::mem::MaybeUninit<bf_key_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bf_key_st>(),
        4168usize,
        concat!("Size of: ", stringify!(bf_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<bf_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(bf_key_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bf_key_st),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bf_key_st),
            "::",
            stringify!(S)
        )
    );
}
pub type BF_KEY = bf_key_st;
extern "C" {
    pub fn BF_set_key(key: *mut BF_KEY, len: usize, data: *const u8);
}
extern "C" {
    pub fn BF_encrypt(data: *mut u32, key: *const BF_KEY);
}
extern "C" {
    pub fn BF_decrypt(data: *mut u32, key: *const BF_KEY);
}
extern "C" {
    pub fn BF_ecb_encrypt(
        in_: *const u8,
        out: *mut u8,
        key: *const BF_KEY,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn BF_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        length: usize,
        schedule: *const BF_KEY,
        ivec: *mut u8,
        enc: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbs_st {
    pub data: *const u8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_cbs_st() {
    const UNINIT: ::std::mem::MaybeUninit<cbs_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbs_st>(),
        16usize,
        concat!("Size of: ", stringify!(cbs_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbs_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbs_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbs_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbs_st),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn CBS_init(cbs: *mut CBS, data: *const u8, len: usize);
}
extern "C" {
    pub fn CBS_skip(cbs: *mut CBS, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_data(cbs: *const CBS) -> *const u8;
}
extern "C" {
    pub fn CBS_len(cbs: *const CBS) -> usize;
}
extern "C" {
    pub fn CBS_stow(
        cbs: *const CBS,
        out_ptr: *mut *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_strdup(
        cbs: *const CBS,
        out_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_contains_zero_byte(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_mem_equal(cbs: *const CBS, data: *const u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u8(cbs: *mut CBS, out: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u16(cbs: *mut CBS, out: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u16le(cbs: *mut CBS, out: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u24(cbs: *mut CBS, out: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u32(cbs: *mut CBS, out: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u32le(cbs: *mut CBS, out: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u64(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u64le(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_last_u8(cbs: *mut CBS, out: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_bytes(cbs: *mut CBS, out: *mut CBS, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_copy_bytes(cbs: *mut CBS, out: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u8_length_prefixed(cbs: *mut CBS, out: *mut CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u16_length_prefixed(cbs: *mut CBS, out: *mut CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u24_length_prefixed(cbs: *mut CBS, out: *mut CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_until_first(cbs: *mut CBS, out: *mut CBS, c: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_u64_decimal(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1(
        cbs: *mut CBS,
        out: *mut CBS,
        tag_value: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_element(
        cbs: *mut CBS,
        out: *mut CBS,
        tag_value: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_peek_asn1_tag(cbs: *const CBS, tag_value: CBS_ASN1_TAG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_any_asn1(
        cbs: *mut CBS,
        out: *mut CBS,
        out_tag: *mut CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_any_asn1_element(
        cbs: *mut CBS,
        out: *mut CBS,
        out_tag: *mut CBS_ASN1_TAG,
        out_header_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_any_ber_asn1_element(
        cbs: *mut CBS,
        out: *mut CBS,
        out_tag: *mut CBS_ASN1_TAG,
        out_header_len: *mut usize,
        out_ber_found: *mut ::std::os::raw::c_int,
        out_indefinite: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_uint64(cbs: *mut CBS, out: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_int64(cbs: *mut CBS, out: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_asn1_bool(
        cbs: *mut CBS,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1(
        cbs: *mut CBS,
        out: *mut CBS,
        out_present: *mut ::std::os::raw::c_int,
        tag: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_octet_string(
        cbs: *mut CBS,
        out: *mut CBS,
        out_present: *mut ::std::os::raw::c_int,
        tag: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_uint64(
        cbs: *mut CBS,
        out: *mut u64,
        tag: CBS_ASN1_TAG,
        default_value: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_bool(
        cbs: *mut CBS,
        out: *mut ::std::os::raw::c_int,
        tag: CBS_ASN1_TAG,
        default_value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_valid_asn1_bitstring(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_asn1_bitstring_has_bit(
        cbs: *const CBS,
        bit: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_valid_asn1_integer(
        cbs: *const CBS,
        out_is_negative: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_unsigned_asn1_integer(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_is_valid_asn1_oid(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_asn1_oid_to_text(cbs: *const CBS) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn CBS_parse_generalized_time(
        cbs: *const CBS,
        out_tm: *mut tm,
        allow_timezone_offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_parse_utc_time(
        cbs: *const CBS,
        out_tm: *mut tm,
        allow_timezone_offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBS_get_optional_asn1_int64(
        cbs: *mut CBS,
        out: *mut i64,
        tag: CBS_ASN1_TAG,
        default_value: i64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbb_buffer_st {
    pub buf: *mut u8,
    pub len: usize,
    pub cap: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_cbb_buffer_st() {
    const UNINIT: ::std::mem::MaybeUninit<cbb_buffer_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbb_buffer_st>(),
        32usize,
        concat!("Size of: ", stringify!(cbb_buffer_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_buffer_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_buffer_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_buffer_st),
            "::",
            stringify!(cap)
        )
    );
}
impl cbb_buffer_st {
    #[inline]
    pub fn can_resize(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_resize(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_resize: ::std::os::raw::c_uint,
        error: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_resize: u32 = unsafe { ::std::mem::transmute(can_resize) };
            can_resize as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let error: u32 = unsafe { ::std::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbb_child_st {
    pub base: *mut cbb_buffer_st,
    pub offset: usize,
    pub pending_len_len: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_cbb_child_st() {
    const UNINIT: ::std::mem::MaybeUninit<cbb_child_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbb_child_st>(),
        24usize,
        concat!("Size of: ", stringify!(cbb_child_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_child_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_child_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_child_st),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_child_st),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending_len_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_child_st),
            "::",
            stringify!(pending_len_len)
        )
    );
}
impl cbb_child_st {
    #[inline]
    pub fn pending_is_asn1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pending_is_asn1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pending_is_asn1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pending_is_asn1: u32 = unsafe { ::std::mem::transmute(pending_is_asn1) };
            pending_is_asn1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cbb_st {
    pub child: *mut CBB,
    pub is_child: ::std::os::raw::c_char,
    pub u: cbb_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cbb_st__bindgen_ty_1 {
    pub base: cbb_buffer_st,
    pub child: cbb_child_st,
}
#[test]
fn bindgen_test_layout_cbb_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<cbb_st__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbb_st__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(cbb_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st__bindgen_ty_1),
            "::",
            stringify!(child)
        )
    );
}
#[test]
fn bindgen_test_layout_cbb_st() {
    const UNINIT: ::std::mem::MaybeUninit<cbb_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cbb_st>(),
        48usize,
        concat!("Size of: ", stringify!(cbb_st))
    );
    assert_eq!(
        ::std::mem::align_of::<cbb_st>(),
        8usize,
        concat!("Alignment of ", stringify!(cbb_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_child) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbb_st),
            "::",
            stringify!(is_child)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(cbb_st), "::", stringify!(u))
    );
}
extern "C" {
    pub fn CBB_zero(cbb: *mut CBB);
}
extern "C" {
    pub fn CBB_init(cbb: *mut CBB, initial_capacity: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_init_fixed(cbb: *mut CBB, buf: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_cleanup(cbb: *mut CBB);
}
extern "C" {
    pub fn CBB_finish(
        cbb: *mut CBB,
        out_data: *mut *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_flush(cbb: *mut CBB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_data(cbb: *const CBB) -> *const u8;
}
extern "C" {
    pub fn CBB_len(cbb: *const CBB) -> usize;
}
extern "C" {
    pub fn CBB_add_u8_length_prefixed(
        cbb: *mut CBB,
        out_contents: *mut CBB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u16_length_prefixed(
        cbb: *mut CBB,
        out_contents: *mut CBB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u24_length_prefixed(
        cbb: *mut CBB,
        out_contents: *mut CBB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1(
        cbb: *mut CBB,
        out_contents: *mut CBB,
        tag: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_bytes(cbb: *mut CBB, data: *const u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_zeros(cbb: *mut CBB, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_space(
        cbb: *mut CBB,
        out_data: *mut *mut u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_reserve(cbb: *mut CBB, out_data: *mut *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_did_write(cbb: *mut CBB, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u8(cbb: *mut CBB, value: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u16(cbb: *mut CBB, value: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u16le(cbb: *mut CBB, value: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u24(cbb: *mut CBB, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u32(cbb: *mut CBB, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u32le(cbb: *mut CBB, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u64(cbb: *mut CBB, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_u64le(cbb: *mut CBB, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_discard_child(cbb: *mut CBB);
}
extern "C" {
    pub fn CBB_add_asn1_uint64(cbb: *mut CBB, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_uint64_with_tag(
        cbb: *mut CBB,
        value: u64,
        tag: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_int64(cbb: *mut CBB, value: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_int64_with_tag(
        cbb: *mut CBB,
        value: i64,
        tag: CBS_ASN1_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_octet_string(
        cbb: *mut CBB,
        data: *const u8,
        data_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_bool(cbb: *mut CBB, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_add_asn1_oid_from_text(
        cbb: *mut CBB,
        text: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CBB_flush_asn1_set_of(cbb: *mut CBB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_chacha_20(
        out: *mut u8,
        in_: *const u8,
        in_len: usize,
        key: *const u8,
        nonce: *const u8,
        counter: u32,
    );
}
extern "C" {
    pub fn EVP_rc4() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_xts() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_wrap() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_enc_null() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_rc2_40_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_chacha20_poly1305() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_get_cipherbynid(nid: ::std::os::raw::c_int) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_init(ctx: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_new() -> *mut EVP_CIPHER_CTX;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cleanup(ctx: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_free(ctx: *mut EVP_CIPHER_CTX);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_copy(
        out: *mut EVP_CIPHER_CTX,
        in_: *const EVP_CIPHER_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_reset(ctx: *mut EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        engine: *mut ENGINE,
        key: *const u8,
        iv: *const u8,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit_ex(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        impl_: *mut ENGINE,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherUpdate(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
        in_: *const u8,
        in_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal_ex(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_cipher(ctx: *const EVP_CIPHER_CTX) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_nid(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_encrypting(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_block_size(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_key_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_iv_length(ctx: *const EVP_CIPHER_CTX) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_get_app_data(ctx: *const EVP_CIPHER_CTX) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_app_data(ctx: *mut EVP_CIPHER_CTX, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn EVP_CIPHER_CTX_flags(ctx: *const EVP_CIPHER_CTX) -> u32;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_mode(ctx: *const EVP_CIPHER_CTX) -> u32;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_ctrl(
        ctx: *mut EVP_CIPHER_CTX,
        command: ::std::os::raw::c_int,
        arg: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_padding(
        ctx: *mut EVP_CIPHER_CTX,
        pad: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_key_length(
        ctx: *mut EVP_CIPHER_CTX,
        key_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_nid(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_name(cipher: *const EVP_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EVP_CIPHER_block_size(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_key_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_iv_length(cipher: *const EVP_CIPHER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EVP_CIPHER_flags(cipher: *const EVP_CIPHER) -> u32;
}
extern "C" {
    pub fn EVP_CIPHER_mode(cipher: *const EVP_CIPHER) -> u32;
}
extern "C" {
    pub fn EVP_BytesToKey(
        type_: *const EVP_CIPHER,
        md: *const EVP_MD,
        salt: *const u8,
        data: *const u8,
        data_len: usize,
        count: ::std::os::raw::c_uint,
        key: *mut u8,
        iv: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cbc_hmac_sha256() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CipherInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const u8,
        iv: *const u8,
        enc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptInit(
        ctx: *mut EVP_CIPHER_CTX,
        cipher: *const EVP_CIPHER,
        key: *const u8,
        iv: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CipherFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_EncryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DecryptFinal(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_Cipher(
        ctx: *mut EVP_CIPHER_CTX,
        out: *mut u8,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_get_cipherbyname(name: *const ::std::os::raw::c_char) -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_ccm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ctr() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_gcm() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_ofb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_des_ede3_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_128_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_192_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb128() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb1() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_aes_256_cfb8() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_bf_cfb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_ecb() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_cast5_cbc() -> *const EVP_CIPHER;
}
extern "C" {
    pub fn EVP_CIPHER_CTX_set_flags(ctx: *const EVP_CIPHER_CTX, flags: u32);
}
extern "C" {
    pub fn EVP_add_cipher_alias(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    pub cipher: *const EVP_CIPHER,
    pub app_data: *mut ::std::os::raw::c_void,
    pub cipher_data: *mut ::std::os::raw::c_void,
    pub key_len: ::std::os::raw::c_uint,
    pub encrypt: ::std::os::raw::c_int,
    pub flags: u32,
    pub oiv: [u8; 16usize],
    pub iv: [u8; 16usize],
    pub buf: [u8; 32usize],
    pub buf_len: ::std::os::raw::c_int,
    pub num: ::std::os::raw::c_uint,
    pub final_used: ::std::os::raw::c_int,
    pub final_: [u8; 32usize],
    pub poisoned: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_evp_cipher_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<evp_cipher_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_ctx_st>(),
        152usize,
        concat!("Size of: ", stringify!(evp_cipher_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cipher_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(cipher_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encrypt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(encrypt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oiv) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(oiv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_len) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).final_used) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(final_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).final_) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(final_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poisoned) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_ctx_st),
            "::",
            stringify!(poisoned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_info_st {
    pub cipher: *const EVP_CIPHER,
    pub iv: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_evp_cipher_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<evp_cipher_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_cipher_info_st>(),
        24usize,
        concat!("Size of: ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_cipher_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_cipher_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_cipher_info_st),
            "::",
            stringify!(iv)
        )
    );
}
pub type EVP_CIPHER_INFO = evp_cipher_info_st;
extern "C" {
    pub fn AES_CMAC(
        out: *mut u8,
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CMAC_CTX_new() -> *mut CMAC_CTX;
}
extern "C" {
    pub fn CMAC_CTX_free(ctx: *mut CMAC_CTX);
}
extern "C" {
    pub fn CMAC_CTX_copy(out: *mut CMAC_CTX, in_: *const CMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CMAC_Init(
        ctx: *mut CMAC_CTX,
        key: *const ::std::os::raw::c_void,
        key_len: usize,
        cipher: *const EVP_CIPHER,
        engine: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CMAC_Reset(ctx: *mut CMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CMAC_Update(ctx: *mut CMAC_CTX, in_: *const u8, in_len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CMAC_Final(
        ctx: *mut CMAC_CTX,
        out: *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CMAC_CTX_get0_cipher_ctx(ctx: *mut CMAC_CTX) -> *mut EVP_CIPHER_CTX;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conf_value_st {
    pub section: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_conf_value_st() {
    const UNINIT: ::std::mem::MaybeUninit<conf_value_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<conf_value_st>(),
        24usize,
        concat!("Size of: ", stringify!(conf_value_st))
    );
    assert_eq!(
        ::std::mem::align_of::<conf_value_st>(),
        8usize,
        concat!("Alignment of ", stringify!(conf_value_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).section) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_value_st),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_value_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(conf_value_st),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CONF_VALUE {
    _unused: [u8; 0],
}
pub type sk_CONF_VALUE_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CONF_VALUE)>;
pub type sk_CONF_VALUE_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const CONF_VALUE) -> *mut CONF_VALUE>;
pub type sk_CONF_VALUE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const CONF_VALUE,
        arg2: *const *const CONF_VALUE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_CONF_VALUE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut CONF_VALUE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lhash_st_CONF_VALUE {
    _unused: [u8; 0],
}
extern "C" {
    pub fn NCONF_new(method: *mut ::std::os::raw::c_void) -> *mut CONF;
}
extern "C" {
    pub fn NCONF_free(conf: *mut CONF);
}
extern "C" {
    pub fn NCONF_load(
        conf: *mut CONF,
        filename: *const ::std::os::raw::c_char,
        out_error_line: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NCONF_load_bio(
        conf: *mut CONF,
        bio: *mut BIO,
        out_error_line: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NCONF_get_section(
        conf: *const CONF,
        section: *const ::std::os::raw::c_char,
    ) -> *const stack_st_CONF_VALUE;
}
extern "C" {
    pub fn NCONF_get_string(
        conf: *const CONF,
        section: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn CONF_modules_load_file(
        filename: *const ::std::os::raw::c_char,
        appname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CONF_get1_default_config_file() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn CONF_modules_free();
}
extern "C" {
    pub fn CONF_modules_unload(all: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CONF_modules_finish();
}
extern "C" {
    pub fn OPENSSL_config(config_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn OPENSSL_no_config();
}
extern "C" {
    pub fn CTR_DRBG_new(
        entropy: *const u8,
        personalization: *const u8,
        personalization_len: usize,
    ) -> *mut CTR_DRBG_STATE;
}
extern "C" {
    pub fn CTR_DRBG_free(state: *mut CTR_DRBG_STATE);
}
extern "C" {
    pub fn CTR_DRBG_reseed(
        drbg: *mut CTR_DRBG_STATE,
        entropy: *const u8,
        additional_data: *const u8,
        additional_data_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CTR_DRBG_generate(
        drbg: *mut CTR_DRBG_STATE,
        out: *mut u8,
        out_len: usize,
        additional_data: *const u8,
        additional_data_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CTR_DRBG_clear(drbg: *mut CTR_DRBG_STATE);
}
extern "C" {
    pub fn X25519_keypair(out_public_value: *mut u8, out_private_key: *mut u8);
}
extern "C" {
    pub fn X25519(
        out_shared_key: *mut u8,
        private_key: *const u8,
        peer_public_value: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X25519_public_from_private(out_public_value: *mut u8, private_key: *const u8);
}
extern "C" {
    pub fn ED25519_keypair(out_public_key: *mut u8, out_private_key: *mut u8);
}
extern "C" {
    pub fn ED25519_sign(
        out_sig: *mut u8,
        message: *const u8,
        message_len: usize,
        private_key: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ED25519_verify(
        message: *const u8,
        message_len: usize,
        signature: *const u8,
        public_key: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ED25519_keypair_from_seed(
        out_public_key: *mut u8,
        out_private_key: *mut u8,
        seed: *const u8,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum spake2_role_t {
    spake2_role_alice = 0,
    spake2_role_bob = 1,
}
extern "C" {
    pub fn SPAKE2_CTX_new(
        my_role: spake2_role_t,
        my_name: *const u8,
        my_name_len: usize,
        their_name: *const u8,
        their_name_len: usize,
    ) -> *mut SPAKE2_CTX;
}
extern "C" {
    pub fn SPAKE2_CTX_free(ctx: *mut SPAKE2_CTX);
}
extern "C" {
    pub fn SPAKE2_generate_msg(
        ctx: *mut SPAKE2_CTX,
        out: *mut u8,
        out_len: *mut usize,
        max_out_len: usize,
        password: *const u8,
        password_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SPAKE2_process_msg(
        ctx: *mut SPAKE2_CTX,
        out_key: *mut u8,
        out_key_len: *mut usize,
        max_out_key_len: usize,
        their_msg: *const u8,
        their_msg_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DES_cblock_st {
    pub bytes: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_DES_cblock_st() {
    const UNINIT: ::std::mem::MaybeUninit<DES_cblock_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DES_cblock_st>(),
        8usize,
        concat!("Size of: ", stringify!(DES_cblock_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DES_cblock_st>(),
        1usize,
        concat!("Alignment of ", stringify!(DES_cblock_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DES_cblock_st),
            "::",
            stringify!(bytes)
        )
    );
}
pub type DES_cblock = DES_cblock_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DES_ks {
    pub subkeys: [[u32; 2usize]; 16usize],
}
#[test]
fn bindgen_test_layout_DES_ks() {
    const UNINIT: ::std::mem::MaybeUninit<DES_ks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DES_ks>(),
        128usize,
        concat!("Size of: ", stringify!(DES_ks))
    );
    assert_eq!(
        ::std::mem::align_of::<DES_ks>(),
        4usize,
        concat!("Alignment of ", stringify!(DES_ks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subkeys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DES_ks),
            "::",
            stringify!(subkeys)
        )
    );
}
pub type DES_key_schedule = DES_ks;
extern "C" {
    pub fn DES_is_weak_key(key: *const DES_cblock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DES_set_key(
        key: *const DES_cblock,
        schedule: *mut DES_key_schedule,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DES_set_key_unchecked(key: *const DES_cblock, schedule: *mut DES_key_schedule);
}
extern "C" {
    pub fn DES_key_sched(
        key: *const DES_cblock,
        schedule: *mut DES_key_schedule,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DES_set_odd_parity(key: *mut DES_cblock);
}
extern "C" {
    pub fn DES_ecb_encrypt(
        in_: *const DES_cblock,
        out: *mut DES_cblock,
        schedule: *const DES_key_schedule,
        is_encrypt: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ncbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        schedule: *const DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ecb3_encrypt(
        input: *const DES_cblock,
        output: *mut DES_cblock,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ede3_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_ede2_cbc_encrypt(
        in_: *const u8,
        out: *mut u8,
        len: usize,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ivec: *mut DES_cblock,
        enc: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn DES_decrypt3(
        data: *mut u32,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
    );
}
extern "C" {
    pub fn DES_encrypt3(
        data: *mut u32,
        ks1: *const DES_key_schedule,
        ks2: *const DES_key_schedule,
        ks3: *const DES_key_schedule,
    );
}
extern "C" {
    pub fn DH_new() -> *mut DH;
}
extern "C" {
    pub fn DH_new_by_nid(nid: ::std::os::raw::c_int) -> *mut DH;
}
extern "C" {
    pub fn DH_free(dh: *mut DH);
}
extern "C" {
    pub fn DH_up_ref(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_bits(dh: *const DH) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn DH_get0_pub_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_priv_key(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_p(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_q(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_g(dh: *const DH) -> *const BIGNUM;
}
extern "C" {
    pub fn DH_get0_key(
        dh: *const DH,
        out_pub_key: *mut *const BIGNUM,
        out_priv_key: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DH_set0_key(
        dh: *mut DH,
        pub_key: *mut BIGNUM,
        priv_key: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get0_pqg(
        dh: *const DH,
        out_p: *mut *const BIGNUM,
        out_q: *mut *const BIGNUM,
        out_g: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DH_set0_pqg(
        dh: *mut DH,
        p: *mut BIGNUM,
        q: *mut BIGNUM,
        g: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_set_length(dh: *mut DH, priv_length: ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_rfc7919_2048() -> *mut DH;
}
extern "C" {
    pub fn DH_get_rfc7919_4096() -> *mut DH;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_1536(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_2048(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_3072(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_4096(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_6144(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn BN_get_rfc3526_prime_8192(ret: *mut BIGNUM) -> *mut BIGNUM;
}
extern "C" {
    pub fn DH_generate_parameters_ex(
        dh: *mut DH,
        prime_bits: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_generate_key(dh: *mut DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key_padded(
        out: *mut u8,
        peers_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key_hashed(
        dh: *mut DH,
        out: *mut u8,
        out_len: *mut usize,
        max_out_len: usize,
        peers_key: *const BIGNUM,
        digest: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_size(dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_num_bits(dh: *const DH) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn DH_check(dh: *const DH, out_flags: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_check_pub_key(
        dh: *const DH,
        pub_key: *const BIGNUM,
        out_flags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DHparams_dup(dh: *const DH) -> *mut DH;
}
extern "C" {
    pub fn DH_parse_parameters(cbs: *mut CBS) -> *mut DH;
}
extern "C" {
    pub fn DH_marshal_parameters(cbb: *mut CBB, dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_generate_parameters(
        prime_len: ::std::os::raw::c_int,
        generator: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn d2i_DHparams(
        ret: *mut *mut DH,
        inp: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut DH;
}
extern "C" {
    pub fn i2d_DHparams(
        in_: *const DH,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_compute_key(
        out: *mut u8,
        peers_key: *const BIGNUM,
        dh: *mut DH,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DH_get_2048_256() -> *mut DH;
}
extern "C" {
    pub fn DH_clear_flags(dh: *mut DH, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_md4() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_ripemd160() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha512_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_224() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_384() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_sha3_512() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake128() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_shake256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_blake2b256() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_md5_sha1() -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_get_digestbynid(nid: ::std::os::raw::c_int) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_get_digestbyobj(obj: *const ASN1_OBJECT) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_init(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_new() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_cleanup(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_cleanse(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_free(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_copy_ex(
        out: *mut EVP_MD_CTX,
        in_: *const EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_move(out: *mut EVP_MD_CTX, in_: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_MD_CTX_reset(ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        engine: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal_ex(
        ctx: *mut EVP_MD_CTX,
        md_out: *mut u8,
        out_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestFinal(
        ctx: *mut EVP_MD_CTX,
        md_out: *mut u8,
        out_size: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_Digest(
        data: *const ::std::os::raw::c_void,
        len: usize,
        md_out: *mut u8,
        out_size: *mut ::std::os::raw::c_uint,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_flags(md: *const EVP_MD) -> u32;
}
extern "C" {
    pub fn EVP_MD_size(md: *const EVP_MD) -> usize;
}
extern "C" {
    pub fn EVP_MD_block_size(md: *const EVP_MD) -> usize;
}
extern "C" {
    pub fn EVP_MD_CTX_md(ctx: *const EVP_MD_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_size(ctx: *const EVP_MD_CTX) -> usize;
}
extern "C" {
    pub fn EVP_MD_CTX_block_size(ctx: *const EVP_MD_CTX) -> usize;
}
extern "C" {
    pub fn EVP_MD_CTX_type(ctx: *const EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_parse_digest_algorithm(cbs: *mut CBS) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_marshal_digest_algorithm(cbb: *mut CBB, md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_copy(out: *mut EVP_MD_CTX, in_: *const EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_get_digestbyname(arg1: *const ::std::os::raw::c_char) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_MD_CTX_create() -> *mut EVP_MD_CTX;
}
extern "C" {
    pub fn EVP_MD_CTX_destroy(ctx: *mut EVP_MD_CTX);
}
extern "C" {
    pub fn EVP_DigestFinalXOF(
        ctx: *mut EVP_MD_CTX,
        out: *mut u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_meth_get_flags(md: *const EVP_MD) -> u32;
}
extern "C" {
    pub fn EVP_MD_nid(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_CTX_set_pkey_ctx(ctx: *mut EVP_MD_CTX, pctx: *mut EVP_PKEY_CTX);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_pctx_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct env_md_ctx_st {
    pub digest: *const EVP_MD,
    pub md_data: *mut ::std::os::raw::c_void,
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut EVP_MD_CTX,
            data: *const ::std::os::raw::c_void,
            count: usize,
        ),
    >,
    pub pctx: *mut EVP_PKEY_CTX,
    pub pctx_ops: *const evp_md_pctx_ops,
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_env_md_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<env_md_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<env_md_ctx_st>(),
        48usize,
        concat!("Size of: ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<env_md_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(env_md_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(md_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(pctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pctx_ops) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(pctx_ops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(env_md_ctx_st),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn EVP_MD_unstable_sha3_enable(enable: bool);
}
extern "C" {
    pub fn EVP_MD_unstable_sha3_is_enabled() -> bool;
}
extern "C" {
    pub fn EVP_MD_CTX_set_flags(ctx: *mut EVP_MD_CTX, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EVP_add_digest(digest: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_md_null() -> *const EVP_MD;
}
extern "C" {
    pub fn DSA_new() -> *mut DSA;
}
extern "C" {
    pub fn DSA_free(dsa: *mut DSA);
}
extern "C" {
    pub fn DSA_up_ref(dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_print(
        bio: *mut BIO,
        dsa: *const DSA,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_print_fp(
        fp: *mut FILE,
        dsa: *const DSA,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_bits(dsa: *const DSA) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn DSA_get0_pub_key(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_priv_key(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_p(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_q(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_g(dsa: *const DSA) -> *const BIGNUM;
}
extern "C" {
    pub fn DSA_get0_key(
        dsa: *const DSA,
        out_pub_key: *mut *const BIGNUM,
        out_priv_key: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DSA_get0_pqg(
        dsa: *const DSA,
        out_p: *mut *const BIGNUM,
        out_q: *mut *const BIGNUM,
        out_g: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn DSA_set0_key(
        dsa: *mut DSA,
        pub_key: *mut BIGNUM,
        priv_key: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set0_pqg(
        dsa: *mut DSA,
        p: *mut BIGNUM,
        q: *mut BIGNUM,
        g: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_generate_parameters_ex(
        dsa: *mut DSA,
        bits: ::std::os::raw::c_uint,
        seed: *const u8,
        seed_len: usize,
        out_counter: *mut ::std::os::raw::c_int,
        out_h: *mut ::std::os::raw::c_ulong,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSAparams_dup(dsa: *const DSA) -> *mut DSA;
}
extern "C" {
    pub fn DSA_generate_key(dsa: *mut DSA) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DSA_SIG_st {
    pub r: *mut BIGNUM,
    pub s: *mut BIGNUM,
}
#[test]
fn bindgen_test_layout_DSA_SIG_st() {
    const UNINIT: ::std::mem::MaybeUninit<DSA_SIG_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DSA_SIG_st>(),
        16usize,
        concat!("Size of: ", stringify!(DSA_SIG_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DSA_SIG_st>(),
        8usize,
        concat!("Alignment of ", stringify!(DSA_SIG_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSA_SIG_st),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DSA_SIG_st),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    pub fn DSA_SIG_new() -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_free(sig: *mut DSA_SIG);
}
extern "C" {
    pub fn DSA_SIG_get0(sig: *const DSA_SIG, out_r: *mut *const BIGNUM, out_s: *mut *const BIGNUM);
}
extern "C" {
    pub fn DSA_SIG_set0(sig: *mut DSA_SIG, r: *mut BIGNUM, s: *mut BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_do_sign(digest: *const u8, digest_len: usize, dsa: *const DSA) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_do_verify(
        digest: *const u8,
        digest_len: usize,
        sig: *mut DSA_SIG,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_do_check_signature(
        out_valid: *mut ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        sig: *mut DSA_SIG,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_sign(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        out_sig: *mut u8,
        out_siglen: *mut ::std::os::raw::c_uint,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_verify(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        sig: *const u8,
        sig_len: usize,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_check_signature(
        out_valid: *mut ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        sig: *const u8,
        sig_len: usize,
        dsa: *const DSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_size(dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_SIG_parse(cbs: *mut CBS) -> *mut DSA_SIG;
}
extern "C" {
    pub fn DSA_SIG_marshal(cbb: *mut CBB, sig: *const DSA_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_parse_public_key(cbs: *mut CBS) -> *mut DSA;
}
extern "C" {
    pub fn DSA_marshal_public_key(cbb: *mut CBB, dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_parse_private_key(cbs: *mut CBS) -> *mut DSA;
}
extern "C" {
    pub fn DSA_marshal_private_key(cbb: *mut CBB, dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_parse_parameters(cbs: *mut CBS) -> *mut DSA;
}
extern "C" {
    pub fn DSA_marshal_parameters(cbb: *mut CBB, dsa: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_dup_DH(dsa: *const DSA) -> *mut DH;
}
extern "C" {
    pub fn DSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_set_ex_data(
        dsa: *mut DSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DSA_get_ex_data(
        dsa: *const DSA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn d2i_DSA_SIG(
        out_sig: *mut *mut DSA_SIG,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut DSA_SIG;
}
extern "C" {
    pub fn i2d_DSA_SIG(in_: *const DSA_SIG, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAPublicKey(
        out: *mut *mut DSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPublicKey(in_: *const DSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAPrivateKey(
        out: *mut *mut DSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAPrivateKey(in_: *const DSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSAparams(
        out: *mut *mut DSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_DSAparams(in_: *const DSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum point_conversion_form_t {
    POINT_CONVERSION_COMPRESSED = 2,
    POINT_CONVERSION_UNCOMPRESSED = 4,
    POINT_CONVERSION_HYBRID = 6,
}
extern "C" {
    pub fn EC_group_p224() -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_group_p256() -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_group_p384() -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_group_p521() -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_group_secp256k1() -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_cmp(
        a: *const EC_GROUP,
        b: *const EC_GROUP,
        ignored: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get0_generator(group: *const EC_GROUP) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_GROUP_get0_order(group: *const EC_GROUP) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_GROUP_order_bits(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_cofactor(
        group: *const EC_GROUP,
        cofactor: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_GFp(
        group: *const EC_GROUP,
        out_p: *mut BIGNUM,
        out_a: *mut BIGNUM,
        out_b: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_curve_name(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_get_degree(group: *const EC_GROUP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EC_curve_nid2nist(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EC_curve_nist2nid(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_new(group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_POINT_copy(dest: *mut EC_POINT, src: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_dup(src: *const EC_POINT, group: *const EC_GROUP) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_POINT_set_to_infinity(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_is_at_infinity(
        group: *const EC_GROUP,
        point: *const EC_POINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_is_on_curve(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_cmp(
        group: *const EC_GROUP,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates_GFp(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_get_affine_coordinates(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        x: *mut BIGNUM,
        y: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates_GFp(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_affine_coordinates(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        x: *const BIGNUM,
        y: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_point2oct(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        buf: *mut u8,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> usize;
}
extern "C" {
    pub fn EC_POINT_point2cbb(
        out: *mut CBB,
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_oct2point(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        buf: *const u8,
        len: usize,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_set_compressed_coordinates_GFp(
        group: *const EC_GROUP,
        point: *mut EC_POINT,
        x: *const BIGNUM,
        y_bit: ::std::os::raw::c_int,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_add(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        b: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_dbl(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        a: *const EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_invert(
        group: *const EC_GROUP,
        a: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_mul(
        group: *const EC_GROUP,
        r: *mut EC_POINT,
        n: *const BIGNUM,
        q: *const EC_POINT,
        m: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_hash_to_curve_p256_xmd_sha256_sswu(
        group: *const EC_GROUP,
        out: *mut EC_POINT,
        dst: *const u8,
        dst_len: usize,
        msg: *const u8,
        msg_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_hash_to_curve_p384_xmd_sha384_sswu(
        group: *const EC_GROUP,
        out: *mut EC_POINT,
        dst: *const u8,
        dst_len: usize,
        msg: *const u8,
        msg_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_free(group: *mut EC_GROUP);
}
extern "C" {
    pub fn EC_GROUP_dup(group: *const EC_GROUP) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_new_curve_GFp(
        p: *const BIGNUM,
        a: *const BIGNUM,
        b: *const BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_GROUP_set_generator(
        group: *mut EC_GROUP,
        generator: *const EC_POINT,
        order: *const BIGNUM,
        cofactor: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_POINT_point2bn(
        group: *const EC_GROUP,
        point: *const EC_POINT,
        form: point_conversion_form_t,
        ret: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> *mut BIGNUM;
}
extern "C" {
    pub fn EC_POINT_bn2point(
        group: *const EC_GROUP,
        bn: *const BIGNUM,
        point: *mut EC_POINT,
        ctx: *mut BN_CTX,
    ) -> *mut EC_POINT;
}
extern "C" {
    pub fn EC_GROUP_get_order(
        group: *const EC_GROUP,
        order: *mut BIGNUM,
        ctx: *mut BN_CTX,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EC_builtin_curve {
    pub nid: ::std::os::raw::c_int,
    pub comment: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EC_builtin_curve() {
    const UNINIT: ::std::mem::MaybeUninit<EC_builtin_curve> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EC_builtin_curve>(),
        16usize,
        concat!("Size of: ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        ::std::mem::align_of::<EC_builtin_curve>(),
        8usize,
        concat!("Alignment of ", stringify!(EC_builtin_curve))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EC_builtin_curve),
            "::",
            stringify!(comment)
        )
    );
}
extern "C" {
    pub fn EC_get_builtin_curves(out_curves: *mut EC_builtin_curve, max_num_curves: usize)
        -> usize;
}
extern "C" {
    pub fn EC_POINT_clear_free(point: *mut EC_POINT);
}
extern "C" {
    pub fn EC_GROUP_set_asn1_flag(group: *mut EC_GROUP, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EC_GROUP_get_asn1_flag(group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_GROUP_set_point_conversion_form(group: *mut EC_GROUP, form: point_conversion_form_t);
}
extern "C" {
    pub fn EC_GROUP_set_seed(
        group: *mut EC_GROUP,
        p: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> usize;
}
extern "C" {
    pub fn EC_GROUP_get0_seed(group: *const EC_GROUP) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn EC_GROUP_get_seed_len(group: *const EC_GROUP) -> usize;
}
extern "C" {
    pub fn ECPKParameters_print(
        bio: *mut BIO,
        group: *const EC_GROUP,
        offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_method_st {
    _unused: [u8; 0],
}
pub type EC_METHOD = ec_method_st;
extern "C" {
    pub fn EC_GROUP_method_of(group: *const EC_GROUP) -> *const EC_METHOD;
}
extern "C" {
    pub fn EC_METHOD_get_field_type(meth: *const EC_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ENGINE_new() -> *mut ENGINE;
}
extern "C" {
    pub fn ENGINE_free(engine: *mut ENGINE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ENGINE_set_RSA_method(
        engine: *mut ENGINE,
        method: *const RSA_METHOD,
        method_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ENGINE_get_RSA_method(engine: *const ENGINE) -> *mut RSA_METHOD;
}
extern "C" {
    pub fn ENGINE_set_ECDSA_method(
        engine: *mut ENGINE,
        method: *const ECDSA_METHOD,
        method_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ENGINE_get_ECDSA_method(engine: *const ENGINE) -> *mut ECDSA_METHOD;
}
extern "C" {
    pub fn METHOD_ref(method: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn METHOD_unref(method: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ENGINE_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct openssl_method_common_st {
    pub references: ::std::os::raw::c_int,
    pub is_static: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_openssl_method_common_st() {
    const UNINIT: ::std::mem::MaybeUninit<openssl_method_common_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<openssl_method_common_st>(),
        8usize,
        concat!("Size of: ", stringify!(openssl_method_common_st))
    );
    assert_eq!(
        ::std::mem::align_of::<openssl_method_common_st>(),
        4usize,
        concat!("Alignment of ", stringify!(openssl_method_common_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).references) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_method_common_st),
            "::",
            stringify!(references)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_static) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(openssl_method_common_st),
            "::",
            stringify!(is_static)
        )
    );
}
extern "C" {
    pub fn EC_KEY_new() -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_new_method(engine: *const ENGINE) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_new_by_curve_name(nid: ::std::os::raw::c_int) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_free(key: *mut EC_KEY);
}
extern "C" {
    pub fn EC_KEY_dup(src: *const EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_up_ref(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_is_opaque(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_group(key: *const EC_KEY) -> *const EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_set_group(key: *mut EC_KEY, group: *const EC_GROUP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_private_key(key: *const EC_KEY) -> *const BIGNUM;
}
extern "C" {
    pub fn EC_KEY_set_private_key(key: *mut EC_KEY, priv_: *const BIGNUM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get0_public_key(key: *const EC_KEY) -> *const EC_POINT;
}
extern "C" {
    pub fn EC_KEY_set_public_key(key: *mut EC_KEY, pub_: *const EC_POINT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_enc_flags(key: *const EC_KEY) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn EC_KEY_set_enc_flags(key: *mut EC_KEY, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn EC_KEY_get_conv_form(key: *const EC_KEY) -> point_conversion_form_t;
}
extern "C" {
    pub fn EC_KEY_set_conv_form(key: *mut EC_KEY, cform: point_conversion_form_t);
}
extern "C" {
    pub fn EC_KEY_check_key(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_check_fips(key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_public_key_affine_coordinates(
        key: *mut EC_KEY,
        x: *const BIGNUM,
        y: *const BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_key2buf(
        key: *const EC_KEY,
        form: point_conversion_form_t,
        out_buf: *mut *mut ::std::os::raw::c_uchar,
        ctx: *mut BN_CTX,
    ) -> usize;
}
extern "C" {
    pub fn EC_KEY_generate_key(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_generate_key_fips(key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_derive_from_secret(
        group: *const EC_GROUP,
        secret: *const u8,
        secret_len: usize,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_parse_private_key(cbs: *mut CBS, group: *const EC_GROUP) -> *mut EC_KEY;
}
extern "C" {
    pub fn EC_KEY_marshal_private_key(
        cbb: *mut CBB,
        key: *const EC_KEY,
        enc_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_parse_curve_name(cbs: *mut CBS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_marshal_curve_name(
        cbb: *mut CBB,
        group: *const EC_GROUP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_parse_parameters(cbs: *mut CBS) -> *mut EC_GROUP;
}
extern "C" {
    pub fn EC_KEY_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_ex_data(
        r: *mut EC_KEY,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_get_ex_data(
        r: *const EC_KEY,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdsa_method_st {
    pub common: openssl_method_common_st,
    pub app_data: *mut ::std::os::raw::c_void,
    pub init:
        ::std::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int>,
    pub finish:
        ::std::option::Option<unsafe extern "C" fn(key: *mut EC_KEY) -> ::std::os::raw::c_int>,
    pub group_order_size: ::std::option::Option<unsafe extern "C" fn(key: *const EC_KEY) -> usize>,
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            digest: *const u8,
            digest_len: usize,
            sig: *mut u8,
            sig_len: *mut ::std::os::raw::c_uint,
            eckey: *mut EC_KEY,
        ) -> ::std::os::raw::c_int,
    >,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ecdsa_method_st() {
    const UNINIT: ::std::mem::MaybeUninit<ecdsa_method_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ecdsa_method_st>(),
        56usize,
        concat!("Size of: ", stringify!(ecdsa_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ecdsa_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ecdsa_method_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group_order_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(group_order_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_method_st),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn d2i_ECPrivateKey(
        out_key: *mut *mut EC_KEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECPrivateKey(key: *const EC_KEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_ECParameters(
        out_key: *mut *mut EC_KEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2d_ECParameters(key: *const EC_KEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn o2i_ECPublicKey(
        out_key: *mut *mut EC_KEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn i2o_ECPublicKey(
        key: *const EC_KEY,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EC_KEY_set_asn1_flag(key: *mut EC_KEY, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ECDH_compute_key(
        out: *mut ::std::os::raw::c_void,
        outlen: usize,
        pub_key: *const EC_POINT,
        priv_key: *const EC_KEY,
        kdf: ::std::option::Option<
            unsafe extern "C" fn(
                in_: *const ::std::os::raw::c_void,
                inlen: usize,
                out: *mut ::std::os::raw::c_void,
                outlen: *mut usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDH_compute_key_fips(
        out: *mut u8,
        out_len: usize,
        pub_key: *const EC_POINT,
        priv_key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_sign(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        sig: *mut u8,
        sig_len: *mut ::std::os::raw::c_uint,
        key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_verify(
        type_: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        sig: *const u8,
        sig_len: usize,
        key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_size(key: *const EC_KEY) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdsa_sig_st {
    pub r: *mut BIGNUM,
    pub s: *mut BIGNUM,
}
#[test]
fn bindgen_test_layout_ecdsa_sig_st() {
    const UNINIT: ::std::mem::MaybeUninit<ecdsa_sig_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ecdsa_sig_st>(),
        16usize,
        concat!("Size of: ", stringify!(ecdsa_sig_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ecdsa_sig_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ecdsa_sig_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_sig_st),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdsa_sig_st),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    pub fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);
}
extern "C" {
    pub fn ECDSA_SIG_get0_r(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_get0_s(sig: *const ECDSA_SIG) -> *const BIGNUM;
}
extern "C" {
    pub fn ECDSA_SIG_get0(
        sig: *const ECDSA_SIG,
        out_r: *mut *const BIGNUM,
        out_s: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn ECDSA_SIG_set0(
        sig: *mut ECDSA_SIG,
        r: *mut BIGNUM,
        s: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_do_sign(
        digest: *const u8,
        digest_len: usize,
        key: *const EC_KEY,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_do_verify(
        digest: *const u8,
        digest_len: usize,
        sig: *const ECDSA_SIG,
        key: *const EC_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_parse(cbs: *mut CBS) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_from_bytes(in_: *const u8, in_len: usize) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn ECDSA_SIG_marshal(cbb: *mut CBB, sig: *const ECDSA_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_to_bytes(
        out_bytes: *mut *mut u8,
        out_len: *mut usize,
        sig: *const ECDSA_SIG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ECDSA_SIG_max_len(order_len: usize) -> usize;
}
extern "C" {
    pub fn ECDSA_sign_with_nonce_and_leak_private_key_for_testing(
        digest: *const u8,
        digest_len: usize,
        eckey: *const EC_KEY,
        nonce: *const u8,
        nonce_len: usize,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn d2i_ECDSA_SIG(
        out: *mut *mut ECDSA_SIG,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut ECDSA_SIG;
}
extern "C" {
    pub fn i2d_ECDSA_SIG(sig: *const ECDSA_SIG, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_dup(obj: *const ASN1_OBJECT) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_cmp(a: *const ASN1_OBJECT, b: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_get0_data(obj: *const ASN1_OBJECT) -> *const u8;
}
extern "C" {
    pub fn OBJ_length(obj: *const ASN1_OBJECT) -> usize;
}
extern "C" {
    pub fn OBJ_obj2nid(obj: *const ASN1_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_cbs2nid(cbs: *const CBS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_sn2nid(short_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_ln2nid(long_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_txt2nid(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_nid2obj(nid: ::std::os::raw::c_int) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_get_undef() -> *const ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_nid2sn(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_nid2ln(nid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OBJ_nid2cbb(out: *mut CBB, nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_txt2obj(
        s: *const ::std::os::raw::c_char,
        dont_search_names: ::std::os::raw::c_int,
    ) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn OBJ_obj2txt(
        out: *mut ::std::os::raw::c_char,
        out_len: ::std::os::raw::c_int,
        obj: *const ASN1_OBJECT,
        always_return_oid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_create(
        oid: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        long_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_algs(
        sign_nid: ::std::os::raw::c_int,
        out_digest_nid: *mut ::std::os::raw::c_int,
        out_pkey_nid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OBJ_find_sigid_by_algs(
        out_sign_nid: *mut ::std::os::raw::c_int,
        digest_nid: ::std::os::raw::c_int,
        pkey_nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obj_name_st {
    pub type_: ::std::os::raw::c_int,
    pub alias: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_obj_name_st() {
    const UNINIT: ::std::mem::MaybeUninit<obj_name_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<obj_name_st>(),
        24usize,
        concat!("Size of: ", stringify!(obj_name_st))
    );
    assert_eq!(
        ::std::mem::align_of::<obj_name_st>(),
        8usize,
        concat!("Alignment of ", stringify!(obj_name_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obj_name_st),
            "::",
            stringify!(data)
        )
    );
}
pub type OBJ_NAME = obj_name_st;
extern "C" {
    pub fn OBJ_NAME_do_all_sorted(
        type_: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const OBJ_NAME, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn OBJ_cleanup();
}
extern "C" {
    pub fn EVP_PKEY_new() -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_free(pkey: *mut EVP_PKEY);
}
extern "C" {
    pub fn EVP_PKEY_up_ref(pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_is_opaque(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp(a: *const EVP_PKEY, b: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_copy_parameters(
        to: *mut EVP_PKEY,
        from: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_missing_parameters(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_size(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_bits(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_type(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_get0_name(md: *const EVP_MD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EVP_MD_name(md: *const EVP_MD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EVP_PKEY_set1_RSA(pkey: *mut EVP_PKEY, key: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign_RSA(pkey: *mut EVP_PKEY, key: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_RSA(pkey: *const EVP_PKEY) -> *mut RSA;
}
extern "C" {
    pub fn EVP_PKEY_get1_RSA(pkey: *const EVP_PKEY) -> *mut RSA;
}
extern "C" {
    pub fn EVP_PKEY_set1_DSA(pkey: *mut EVP_PKEY, key: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign_DSA(pkey: *mut EVP_PKEY, key: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DSA(pkey: *const EVP_PKEY) -> *mut DSA;
}
extern "C" {
    pub fn EVP_PKEY_get1_DSA(pkey: *const EVP_PKEY) -> *mut DSA;
}
extern "C" {
    pub fn EVP_PKEY_set1_EC_KEY(pkey: *mut EVP_PKEY, key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_assign_EC_KEY(pkey: *mut EVP_PKEY, key: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_EC_KEY(pkey: *const EVP_PKEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EVP_PKEY_get1_EC_KEY(pkey: *const EVP_PKEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn EVP_PKEY_set_type(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_cmp_parameters(a: *const EVP_PKEY, b: *const EVP_PKEY)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_parse_public_key(cbs: *mut CBS) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_marshal_public_key(cbb: *mut CBB, key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_parse_private_key(cbs: *mut CBS) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_marshal_private_key(cbb: *mut CBB, key: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_marshal_private_key_v2(cbb: *mut CBB, key: *const EVP_PKEY)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_private_key(
        type_: ::std::os::raw::c_int,
        unused: *mut ENGINE,
        in_: *const u8,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_new_raw_public_key(
        type_: ::std::os::raw::c_int,
        unused: *mut ENGINE,
        in_: *const u8,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_private_key(
        pkey: *const EVP_PKEY,
        out: *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get_raw_public_key(
        pkey: *const EVP_PKEY,
        out: *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSignFinal(
        ctx: *mut EVP_MD_CTX,
        out_sig: *mut u8,
        out_sig_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestSign(
        ctx: *mut EVP_MD_CTX,
        out_sig: *mut u8,
        out_sig_len: *mut usize,
        data: *const u8,
        data_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyInit(
        ctx: *mut EVP_MD_CTX,
        pctx: *mut *mut EVP_PKEY_CTX,
        type_: *const EVP_MD,
        e: *mut ENGINE,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const u8,
        sig_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_DigestVerify(
        ctx: *mut EVP_MD_CTX,
        sig: *const u8,
        sig_len: usize,
        data: *const u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_SignFinal(
        ctx: *const EVP_MD_CTX,
        sig: *mut u8,
        out_sig_len: *mut ::std::os::raw::c_uint,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyInit_ex(
        ctx: *mut EVP_MD_CTX,
        type_: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyInit(ctx: *mut EVP_MD_CTX, type_: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyUpdate(
        ctx: *mut EVP_MD_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_VerifyFinal(
        ctx: *mut EVP_MD_CTX,
        sig: *const u8,
        sig_len: usize,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_public(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_private(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_print_params(
        out: *mut BIO,
        pkey: *const EVP_PKEY,
        indent: ::std::os::raw::c_int,
        pctx: *mut ASN1_PCTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC(
        password: *const ::std::os::raw::c_char,
        password_len: usize,
        salt: *const u8,
        salt_len: usize,
        iterations: u32,
        digest: *const EVP_MD,
        key_len: usize,
        out_key: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS5_PBKDF2_HMAC_SHA1(
        password: *const ::std::os::raw::c_char,
        password_len: usize,
        salt: *const u8,
        salt_len: usize,
        iterations: u32,
        key_len: usize,
        out_key: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PBE_scrypt(
        password: *const ::std::os::raw::c_char,
        password_len: usize,
        salt: *const u8,
        salt_len: usize,
        N: u64,
        r: u64,
        p: u64,
        max_mem: usize,
        out_key: *mut u8,
        key_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new(pkey: *mut EVP_PKEY, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_new_id(id: ::std::os::raw::c_int, e: *mut ENGINE) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_free(ctx: *mut EVP_PKEY_CTX);
}
extern "C" {
    pub fn EVP_PKEY_CTX_dup(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY_CTX;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_pkey(ctx: *mut EVP_PKEY_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_sign_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_sign(
        ctx: *mut EVP_PKEY_CTX,
        sig: *mut u8,
        sig_len: *mut usize,
        digest: *const u8,
        digest_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify(
        ctx: *mut EVP_PKEY_CTX,
        sig: *const u8,
        sig_len: usize,
        digest: *const u8,
        digest_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut u8,
        out_len: *mut usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decrypt(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut u8,
        out_len: *mut usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_verify_recover(
        ctx: *mut EVP_PKEY_CTX,
        out: *mut u8,
        out_len: *mut usize,
        sig: *const u8,
        siglen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive_set_peer(
        ctx: *mut EVP_PKEY_CTX,
        peer: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_derive(
        ctx: *mut EVP_PKEY_CTX,
        key: *mut u8,
        out_key_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_keygen(
        ctx: *mut EVP_PKEY_CTX,
        out_pkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encapsulate(
        ctx: *mut EVP_PKEY_CTX,
        ciphertext: *mut u8,
        ciphertext_len: *mut usize,
        shared_secret: *mut u8,
        shared_secret_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_decapsulate(
        ctx: *mut EVP_PKEY_CTX,
        shared_secret: *mut u8,
        shared_secret_len: *mut usize,
        ciphertext: *const u8,
        ciphertext_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen_init(ctx: *mut EVP_PKEY_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_paramgen(
        ctx: *mut EVP_PKEY_CTX,
        out_pkey: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_signature_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_signature_md(
        ctx: *mut EVP_PKEY_CTX,
        out_md: *mut *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_padding(
        ctx: *mut EVP_PKEY_CTX,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_padding(
        ctx: *mut EVP_PKEY_CTX,
        out_padding: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        salt_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_pss_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        out_salt_len: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_bits(
        ctx: *mut EVP_PKEY_CTX,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_keygen_pubexp(
        ctx: *mut EVP_PKEY_CTX,
        e: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_oaep_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_oaep_md(
        ctx: *mut EVP_PKEY_CTX,
        out_md: *mut *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_mgf1_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get_rsa_mgf1_md(
        ctx: *mut EVP_PKEY_CTX,
        out_md: *mut *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx: *mut EVP_PKEY_CTX,
        label: *mut u8,
        label_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_get0_rsa_oaep_label(
        ctx: *mut EVP_PKEY_CTX,
        out_label: *mut *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
        ctx: *mut EVP_PKEY_CTX,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_kem_set_params(
        ctx: *mut EVP_PKEY_CTX,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_kem_new_raw_public_key(
        nid: ::std::os::raw::c_int,
        in_: *const u8,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_kem_new_raw_secret_key(
        nid: ::std::os::raw::c_int,
        in_: *const u8,
        len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_kem_new_raw_key(
        nid: ::std::os::raw::c_int,
        in_public: *const u8,
        len_public: usize,
        in_secret: *const u8,
        len_secret: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_kem_check_key(key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_get_pkey_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_MD_pkey_type(md: *const EVP_MD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_CIPHER_do_all_sorted(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *const EVP_CIPHER,
                name: *const ::std::os::raw::c_char,
                unused: *const ::std::os::raw::c_char,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all_sorted(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *const EVP_MD,
                name: *const ::std::os::raw::c_char,
                unused: *const ::std::os::raw::c_char,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EVP_MD_do_all(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                cipher: *const EVP_MD,
                name: *const ::std::os::raw::c_char,
                unused: *const ::std::os::raw::c_char,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn i2d_PrivateKey(key: *const EVP_PKEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PublicKey(key: *const EVP_PKEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PrivateKey(
        type_: ::std::os::raw::c_int,
        out: *mut *mut EVP_PKEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_AutoPrivateKey(
        out: *mut *mut EVP_PKEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_PublicKey(
        type_: ::std::os::raw::c_int,
        out: *mut *mut EVP_PKEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_ec_param_enc(
        ctx: *mut EVP_PKEY_CTX,
        encoding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_set1_tls_encodedpoint(
        pkey: *mut EVP_PKEY,
        in_: *const u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get1_tls_encodedpoint(pkey: *const EVP_PKEY, out_ptr: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn EVP_PKEY_base_id(pkey: *const EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(
        ctx: *mut EVP_PKEY_CTX,
        salt_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PUBKEY(pkey: *const EVP_PKEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PUBKEY(
        out: *mut *mut EVP_PKEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY(rsa: *const RSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY(
        out: *mut *mut RSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY(dsa: *const DSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY(
        out: *mut *mut DSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut DSA;
}
extern "C" {
    pub fn i2d_EC_PUBKEY(ec_key: *const EC_KEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_EC_PUBKEY(
        out: *mut *mut EC_KEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn EVP_PKEY_assign(
        pkey: *mut EVP_PKEY,
        type_: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_new_mac_key(
        type_: ::std::os::raw::c_int,
        engine: *mut ENGINE,
        mac_key: *const u8,
        mac_key_len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY_get0(pkey: *const EVP_PKEY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn OpenSSL_add_all_algorithms();
}
extern "C" {
    pub fn OPENSSL_add_all_algorithms_conf();
}
extern "C" {
    pub fn OpenSSL_add_all_ciphers();
}
extern "C" {
    pub fn OpenSSL_add_all_digests();
}
extern "C" {
    pub fn EVP_cleanup();
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_bits(
        ctx: *mut EVP_PKEY_CTX,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
        ctx: *mut EVP_PKEY_CTX,
        qbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_get0_DH(pkey: *const EVP_PKEY) -> *mut DH;
}
extern "C" {
    pub fn EVP_PKEY_get1_DH(pkey: *const EVP_PKEY) -> *mut DH;
}
extern "C" {
    pub fn EVP_PKEY_keygen_deterministic(
        ctx: *mut EVP_PKEY_CTX,
        out_pkey: *mut *mut EVP_PKEY,
        seed: *const u8,
        seed_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_encapsulate_deterministic(
        ctx: *mut EVP_PKEY_CTX,
        ciphertext: *mut u8,
        ciphertext_len: *mut usize,
        shared_secret: *mut u8,
        shared_secret_len: *mut usize,
        seed: *const u8,
        seed_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HKDF(
        out_key: *mut u8,
        out_len: usize,
        digest: *const EVP_MD,
        secret: *const u8,
        secret_len: usize,
        salt: *const u8,
        salt_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HKDF_extract(
        out_key: *mut u8,
        out_len: *mut usize,
        digest: *const EVP_MD,
        secret: *const u8,
        secret_len: usize,
        salt: *const u8,
        salt_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HKDF_expand(
        out_key: *mut u8,
        out_len: usize,
        digest: *const EVP_MD,
        prk: *const u8,
        prk_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5_Init(md5: *mut MD5_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5_Update(
        md5: *mut MD5_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5_Final(out: *mut u8, md5: *mut MD5_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD5(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn MD5_Transform(md5: *mut MD5_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md5_state_st {
    pub h: [u32; 4usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_md5_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<md5_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<md5_state_st>(),
        92usize,
        concat!("Size of: ", stringify!(md5_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<md5_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nh) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_state_st),
            "::",
            stringify!(num)
        )
    );
}
extern "C" {
    pub fn HMAC(
        evp_md: *const EVP_MD,
        key: *const ::std::os::raw::c_void,
        key_len: usize,
        data: *const u8,
        data_len: usize,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> *mut u8;
}
extern "C" {
    pub fn HMAC_CTX_init(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_new() -> *mut HMAC_CTX;
}
extern "C" {
    pub fn HMAC_CTX_cleanup(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_cleanse(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_CTX_free(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_Init_ex(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        key_len: usize,
        md: *const EVP_MD,
        impl_: *mut ENGINE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Update(
        ctx: *mut HMAC_CTX,
        data: *const u8,
        data_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Final(
        ctx: *mut HMAC_CTX,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_size(ctx: *const HMAC_CTX) -> usize;
}
extern "C" {
    pub fn HMAC_CTX_get_md(ctx: *const HMAC_CTX) -> *const EVP_MD;
}
extern "C" {
    pub fn HMAC_CTX_copy_ex(dest: *mut HMAC_CTX, src: *const HMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_reset(ctx: *mut HMAC_CTX);
}
extern "C" {
    pub fn HMAC_set_precomputed_key_export(ctx: *mut HMAC_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_get_precomputed_key(
        ctx: *mut HMAC_CTX,
        out: *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Init_from_precomputed_key(
        ctx: *mut HMAC_CTX,
        precomputed_key: *const u8,
        precompute_key_len: usize,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_Init(
        ctx: *mut HMAC_CTX,
        key: *const ::std::os::raw::c_void,
        key_len: ::std::os::raw::c_int,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HMAC_CTX_copy(dest: *mut HMAC_CTX, src: *const HMAC_CTX) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_methods_st {
    _unused: [u8; 0],
}
pub type HmacMethods = hmac_methods_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub union md_ctx_union {
    pub md5: MD5_CTX,
    pub sha1: SHA_CTX,
    pub sha256: SHA256_CTX,
    pub sha512: SHA512_CTX,
}
#[test]
fn bindgen_test_layout_md_ctx_union() {
    const UNINIT: ::std::mem::MaybeUninit<md_ctx_union> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<md_ctx_union>(),
        216usize,
        concat!("Size of: ", stringify!(md_ctx_union))
    );
    assert_eq!(
        ::std::mem::align_of::<md_ctx_union>(),
        8usize,
        concat!("Alignment of ", stringify!(md_ctx_union))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_ctx_union),
            "::",
            stringify!(md5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_ctx_union),
            "::",
            stringify!(sha1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_ctx_union),
            "::",
            stringify!(sha256)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_ctx_union),
            "::",
            stringify!(sha512)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hmac_ctx_st {
    pub md: *const EVP_MD,
    pub methods: *const HmacMethods,
    pub md_ctx: md_ctx_union,
    pub i_ctx: md_ctx_union,
    pub o_ctx: md_ctx_union,
    pub state: i8,
}
#[test]
fn bindgen_test_layout_hmac_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<hmac_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hmac_ctx_st>(),
        672usize,
        concat!("Size of: ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hmac_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md_ctx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_ctx) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(i_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).o_ctx) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(o_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_ctx_st),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub fn EVP_hpke_x25519_hkdf_sha256() -> *const EVP_HPKE_KEM;
}
extern "C" {
    pub fn EVP_HPKE_KEM_id(kem: *const EVP_HPKE_KEM) -> u16;
}
extern "C" {
    pub fn EVP_HPKE_KEM_public_key_len(kem: *const EVP_HPKE_KEM) -> usize;
}
extern "C" {
    pub fn EVP_HPKE_KEM_private_key_len(kem: *const EVP_HPKE_KEM) -> usize;
}
extern "C" {
    pub fn EVP_HPKE_KEM_enc_len(kem: *const EVP_HPKE_KEM) -> usize;
}
extern "C" {
    pub fn EVP_hpke_hkdf_sha256() -> *const EVP_HPKE_KDF;
}
extern "C" {
    pub fn EVP_HPKE_KDF_id(kdf: *const EVP_HPKE_KDF) -> u16;
}
extern "C" {
    pub fn EVP_HPKE_KDF_hkdf_md(kdf: *const EVP_HPKE_KDF) -> *const EVP_MD;
}
extern "C" {
    pub fn EVP_hpke_aes_128_gcm() -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_hpke_aes_256_gcm() -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_hpke_chacha20_poly1305() -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_HPKE_AEAD_id(aead: *const EVP_HPKE_AEAD) -> u16;
}
extern "C" {
    pub fn EVP_HPKE_AEAD_aead(aead: *const EVP_HPKE_AEAD) -> *const EVP_AEAD;
}
extern "C" {
    pub fn EVP_HPKE_KEY_zero(key: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_cleanup(key: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_new() -> *mut EVP_HPKE_KEY;
}
extern "C" {
    pub fn EVP_HPKE_KEY_free(key: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_copy(
        dst: *mut EVP_HPKE_KEY,
        src: *const EVP_HPKE_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_move(out: *mut EVP_HPKE_KEY, in_: *mut EVP_HPKE_KEY);
}
extern "C" {
    pub fn EVP_HPKE_KEY_init(
        key: *mut EVP_HPKE_KEY,
        kem: *const EVP_HPKE_KEM,
        priv_key: *const u8,
        priv_key_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_generate(
        key: *mut EVP_HPKE_KEY,
        kem: *const EVP_HPKE_KEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_kem(key: *const EVP_HPKE_KEY) -> *const EVP_HPKE_KEM;
}
extern "C" {
    pub fn EVP_HPKE_KEY_public_key(
        key: *const EVP_HPKE_KEY,
        out: *mut u8,
        out_len: *mut usize,
        max_out: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_KEY_private_key(
        key: *const EVP_HPKE_KEY,
        out: *mut u8,
        out_len: *mut usize,
        max_out: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_zero(ctx: *mut EVP_HPKE_CTX);
}
extern "C" {
    pub fn EVP_HPKE_CTX_cleanup(ctx: *mut EVP_HPKE_CTX);
}
extern "C" {
    pub fn EVP_HPKE_CTX_new() -> *mut EVP_HPKE_CTX;
}
extern "C" {
    pub fn EVP_HPKE_CTX_free(ctx: *mut EVP_HPKE_CTX);
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_sender(
        ctx: *mut EVP_HPKE_CTX,
        out_enc: *mut u8,
        out_enc_len: *mut usize,
        max_enc: usize,
        kem: *const EVP_HPKE_KEM,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        peer_public_key: *const u8,
        peer_public_key_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_sender_with_seed_for_testing(
        ctx: *mut EVP_HPKE_CTX,
        out_enc: *mut u8,
        out_enc_len: *mut usize,
        max_enc: usize,
        kem: *const EVP_HPKE_KEM,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        peer_public_key: *const u8,
        peer_public_key_len: usize,
        info: *const u8,
        info_len: usize,
        seed: *const u8,
        seed_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_recipient(
        ctx: *mut EVP_HPKE_CTX,
        key: *const EVP_HPKE_KEY,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        enc: *const u8,
        enc_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_auth_sender(
        ctx: *mut EVP_HPKE_CTX,
        out_enc: *mut u8,
        out_enc_len: *mut usize,
        max_enc: usize,
        key: *const EVP_HPKE_KEY,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        peer_public_key: *const u8,
        peer_public_key_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_auth_sender_with_seed_for_testing(
        ctx: *mut EVP_HPKE_CTX,
        out_enc: *mut u8,
        out_enc_len: *mut usize,
        max_enc: usize,
        key: *const EVP_HPKE_KEY,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        peer_public_key: *const u8,
        peer_public_key_len: usize,
        info: *const u8,
        info_len: usize,
        seed: *const u8,
        seed_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_setup_auth_recipient(
        ctx: *mut EVP_HPKE_CTX,
        key: *const EVP_HPKE_KEY,
        kdf: *const EVP_HPKE_KDF,
        aead: *const EVP_HPKE_AEAD,
        enc: *const u8,
        enc_len: usize,
        info: *const u8,
        info_len: usize,
        peer_public_key: *const u8,
        peer_public_key_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_open(
        ctx: *mut EVP_HPKE_CTX,
        out: *mut u8,
        out_len: *mut usize,
        max_out_len: usize,
        in_: *const u8,
        in_len: usize,
        ad: *const u8,
        ad_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_seal(
        ctx: *mut EVP_HPKE_CTX,
        out: *mut u8,
        out_len: *mut usize,
        max_out_len: usize,
        in_: *const u8,
        in_len: usize,
        ad: *const u8,
        ad_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_export(
        ctx: *const EVP_HPKE_CTX,
        out: *mut u8,
        secret_len: usize,
        context: *const u8,
        context_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_HPKE_CTX_max_overhead(ctx: *const EVP_HPKE_CTX) -> usize;
}
extern "C" {
    pub fn EVP_HPKE_CTX_kem(ctx: *const EVP_HPKE_CTX) -> *const EVP_HPKE_KEM;
}
extern "C" {
    pub fn EVP_HPKE_CTX_aead(ctx: *const EVP_HPKE_CTX) -> *const EVP_HPKE_AEAD;
}
extern "C" {
    pub fn EVP_HPKE_CTX_kdf(ctx: *const EVP_HPKE_CTX) -> *const EVP_HPKE_KDF;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evp_hpke_ctx_st {
    pub kem: *const EVP_HPKE_KEM,
    pub aead: *const EVP_HPKE_AEAD,
    pub kdf: *const EVP_HPKE_KDF,
    pub aead_ctx: EVP_AEAD_CTX,
    pub base_nonce: [u8; 24usize],
    pub exporter_secret: [u8; 64usize],
    pub seq: u64,
    pub is_sender: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_evp_hpke_ctx_st() {
    const UNINIT: ::std::mem::MaybeUninit<evp_hpke_ctx_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_hpke_ctx_st>(),
        712usize,
        concat!("Size of: ", stringify!(evp_hpke_ctx_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_hpke_ctx_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_hpke_ctx_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(kem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(aead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aead_ctx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(aead_ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_nonce) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(base_nonce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exporter_secret) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(exporter_secret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_sender) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_ctx_st),
            "::",
            stringify!(is_sender)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_hpke_key_st {
    pub kem: *const EVP_HPKE_KEM,
    pub private_key: [u8; 32usize],
    pub public_key: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_evp_hpke_key_st() {
    const UNINIT: ::std::mem::MaybeUninit<evp_hpke_key_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evp_hpke_key_st>(),
        72usize,
        concat!("Size of: ", stringify!(evp_hpke_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<evp_hpke_key_st>(),
        8usize,
        concat!("Alignment of ", stringify!(evp_hpke_key_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_key_st),
            "::",
            stringify!(kem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_key_st),
            "::",
            stringify!(private_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).public_key) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(evp_hpke_key_st),
            "::",
            stringify!(public_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRSS_private_key {
    pub opaque: [u8; 1808usize],
}
#[test]
fn bindgen_test_layout_HRSS_private_key() {
    const UNINIT: ::std::mem::MaybeUninit<HRSS_private_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HRSS_private_key>(),
        1808usize,
        concat!("Size of: ", stringify!(HRSS_private_key))
    );
    assert_eq!(
        ::std::mem::align_of::<HRSS_private_key>(),
        1usize,
        concat!("Alignment of ", stringify!(HRSS_private_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HRSS_private_key),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRSS_public_key {
    pub opaque: [u8; 1424usize],
}
#[test]
fn bindgen_test_layout_HRSS_public_key() {
    const UNINIT: ::std::mem::MaybeUninit<HRSS_public_key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HRSS_public_key>(),
        1424usize,
        concat!("Size of: ", stringify!(HRSS_public_key))
    );
    assert_eq!(
        ::std::mem::align_of::<HRSS_public_key>(),
        1usize,
        concat!("Alignment of ", stringify!(HRSS_public_key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HRSS_public_key),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    pub fn HRSS_generate_key(
        out_pub: *mut HRSS_public_key,
        out_priv: *mut HRSS_private_key,
        input: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HRSS_encap(
        out_ciphertext: *mut u8,
        out_shared_key: *mut u8,
        in_pub: *const HRSS_public_key,
        in_: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HRSS_decap(
        out_shared_key: *mut u8,
        in_priv: *const HRSS_private_key,
        ciphertext: *const u8,
        ciphertext_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HRSS_marshal_public_key(out: *mut u8, in_pub: *const HRSS_public_key);
}
extern "C" {
    pub fn HRSS_parse_public_key(
        out: *mut HRSS_public_key,
        in_: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_tls1_prf(
        digest: *const EVP_MD,
        out: *mut u8,
        out_len: usize,
        secret: *const u8,
        secret_len: usize,
        label: *const ::std::os::raw::c_char,
        label_len: usize,
        seed1: *const u8,
        seed1_len: usize,
        seed2: *const u8,
        seed2_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSKDF_digest(
        out_key: *mut u8,
        out_len: usize,
        digest: *const EVP_MD,
        secret: *const u8,
        secret_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSKDF_hmac(
        out_key: *mut u8,
        out_len: usize,
        digest: *const EVP_MD,
        secret: *const u8,
        secret_len: usize,
        info: *const u8,
        info_len: usize,
        salt: *const u8,
        salt_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn KBKDF_ctr_hmac(
        out_key: *mut u8,
        out_len: usize,
        digest: *const EVP_MD,
        secret: *const u8,
        secret_len: usize,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_hkdf_mode(
        ctx: *mut EVP_PKEY_CTX,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set_hkdf_md(
        ctx: *mut EVP_PKEY_CTX,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set1_hkdf_key(
        ctx: *mut EVP_PKEY_CTX,
        key: *const u8,
        key_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_set1_hkdf_salt(
        ctx: *mut EVP_PKEY_CTX,
        salt: *const u8,
        salt_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKEY_CTX_add1_hkdf_info(
        ctx: *mut EVP_PKEY_CTX,
        info: *const u8,
        info_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD4_Init(md4: *mut MD4_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD4_Update(
        md4: *mut MD4_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD4_Final(out: *mut u8, md4: *mut MD4_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MD4(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn MD4_Transform(md4: *mut MD4_CTX, block: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md4_state_st {
    pub h: [u32; 4usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_md4_state_st() {
    const UNINIT: ::std::mem::MaybeUninit<md4_state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<md4_state_st>(),
        92usize,
        concat!("Size of: ", stringify!(md4_state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<md4_state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(md4_state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nh) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_state_st),
            "::",
            stringify!(num)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_CRYPTO_BUFFER {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_CRL {
    _unused: [u8; 0],
}
extern "C" {
    pub fn PKCS7_get_raw_certificates(
        out_certs: *mut stack_st_CRYPTO_BUFFER,
        cbs: *mut CBS,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_certificates(
        out_certs: *mut stack_st_X509,
        cbs: *mut CBS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_bundle_raw_certificates(
        out: *mut CBB,
        certs: *const stack_st_CRYPTO_BUFFER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_bundle_certificates(
        out: *mut CBB,
        certs: *const stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_CRLs(out_crls: *mut stack_st_X509_CRL, cbs: *mut CBS)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_bundle_CRLs(
        out: *mut CBB,
        crls: *const stack_st_X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_PEM_certificates(
        out_certs: *mut stack_st_X509,
        pem_bio: *mut BIO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_get_PEM_CRLs(
        out_crls: *mut stack_st_X509_CRL,
        pem_bio: *mut BIO,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PKCS7_SIGNED {
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
}
#[test]
fn bindgen_test_layout_PKCS7_SIGNED() {
    const UNINIT: ::std::mem::MaybeUninit<PKCS7_SIGNED> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PKCS7_SIGNED>(),
        16usize,
        concat!("Size of: ", stringify!(PKCS7_SIGNED))
    );
    assert_eq!(
        ::std::mem::align_of::<PKCS7_SIGNED>(),
        8usize,
        concat!("Alignment of ", stringify!(PKCS7_SIGNED))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7_SIGNED),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7_SIGNED),
            "::",
            stringify!(crl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PKCS7_SIGN_ENVELOPE {
    pub cert: *mut stack_st_X509,
    pub crl: *mut stack_st_X509_CRL,
}
#[test]
fn bindgen_test_layout_PKCS7_SIGN_ENVELOPE() {
    const UNINIT: ::std::mem::MaybeUninit<PKCS7_SIGN_ENVELOPE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PKCS7_SIGN_ENVELOPE>(),
        16usize,
        concat!("Size of: ", stringify!(PKCS7_SIGN_ENVELOPE))
    );
    assert_eq!(
        ::std::mem::align_of::<PKCS7_SIGN_ENVELOPE>(),
        8usize,
        concat!("Alignment of ", stringify!(PKCS7_SIGN_ENVELOPE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cert) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7_SIGN_ENVELOPE),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7_SIGN_ENVELOPE),
            "::",
            stringify!(crl)
        )
    );
}
pub type PKCS7_ENVELOPE = ::std::os::raw::c_void;
pub type PKCS7_DIGEST = ::std::os::raw::c_void;
pub type PKCS7_ENCRYPT = ::std::os::raw::c_void;
pub type PKCS7_SIGNER_INFO = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PKCS7 {
    pub ber_bytes: *mut u8,
    pub ber_len: usize,
    pub type_: *mut ASN1_OBJECT,
    pub d: PKCS7__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PKCS7__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub data: *mut ASN1_OCTET_STRING,
    pub sign: *mut PKCS7_SIGNED,
    pub enveloped: *mut PKCS7_ENVELOPE,
    pub signed_and_enveloped: *mut PKCS7_SIGN_ENVELOPE,
    pub digest: *mut PKCS7_DIGEST,
    pub encrypted: *mut PKCS7_ENCRYPT,
    pub other: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_PKCS7__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<PKCS7__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PKCS7__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(PKCS7__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<PKCS7__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(PKCS7__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enveloped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(enveloped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signed_and_enveloped) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(signed_and_enveloped)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encrypted) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(encrypted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).other) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7__bindgen_ty_1),
            "::",
            stringify!(other)
        )
    );
}
#[test]
fn bindgen_test_layout_PKCS7() {
    const UNINIT: ::std::mem::MaybeUninit<PKCS7> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PKCS7>(),
        32usize,
        concat!("Size of: ", stringify!(PKCS7))
    );
    assert_eq!(
        ::std::mem::align_of::<PKCS7>(),
        8usize,
        concat!("Alignment of ", stringify!(PKCS7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ber_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7),
            "::",
            stringify!(ber_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ber_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7),
            "::",
            stringify!(ber_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PKCS7),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(PKCS7), "::", stringify!(d))
    );
}
extern "C" {
    pub fn d2i_PKCS7(out: *mut *mut PKCS7, inp: *mut *const u8, len: usize) -> *mut PKCS7;
}
extern "C" {
    pub fn d2i_PKCS7_bio(bio: *mut BIO, out: *mut *mut PKCS7) -> *mut PKCS7;
}
extern "C" {
    pub fn i2d_PKCS7(p7: *const PKCS7, out: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS7_bio(bio: *mut BIO, p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_free(p7: *mut PKCS7);
}
extern "C" {
    pub fn PKCS7_type_is_data(p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_type_is_digest(p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_type_is_encrypted(p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_type_is_enveloped(p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_type_is_signed(p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_type_is_signedAndEnveloped(p7: *const PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS7_sign(
        sign_cert: *mut X509,
        pkey: *mut EVP_PKEY,
        certs: *mut stack_st_X509,
        data: *mut BIO,
        flags: ::std::os::raw::c_int,
    ) -> *mut PKCS7;
}
pub type sk_CRYPTO_BUFFER_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CRYPTO_BUFFER)>;
pub type sk_CRYPTO_BUFFER_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const CRYPTO_BUFFER) -> *mut CRYPTO_BUFFER>;
pub type sk_CRYPTO_BUFFER_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const CRYPTO_BUFFER,
        arg2: *const *const CRYPTO_BUFFER,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_CRYPTO_BUFFER_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut CRYPTO_BUFFER,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn CRYPTO_BUFFER_POOL_new() -> *mut CRYPTO_BUFFER_POOL;
}
extern "C" {
    pub fn CRYPTO_BUFFER_POOL_free(pool: *mut CRYPTO_BUFFER_POOL);
}
extern "C" {
    pub fn CRYPTO_BUFFER_new(
        data: *const u8,
        len: usize,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_alloc(out_data: *mut *mut u8, len: usize) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_new_from_CBS(
        cbs: *const CBS,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_new_from_static_data_unsafe(
        data: *const u8,
        len: usize,
        pool: *mut CRYPTO_BUFFER_POOL,
    ) -> *mut CRYPTO_BUFFER;
}
extern "C" {
    pub fn CRYPTO_BUFFER_free(buf: *mut CRYPTO_BUFFER);
}
extern "C" {
    pub fn CRYPTO_BUFFER_up_ref(buf: *mut CRYPTO_BUFFER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CRYPTO_BUFFER_data(buf: *const CRYPTO_BUFFER) -> *const u8;
}
extern "C" {
    pub fn CRYPTO_BUFFER_len(buf: *const CRYPTO_BUFFER) -> usize;
}
extern "C" {
    pub fn CRYPTO_BUFFER_init_CBS(buf: *const CRYPTO_BUFFER, out: *mut CBS);
}
extern "C" {
    pub fn RSA_new_public_key(n: *const BIGNUM, e: *const BIGNUM) -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_private_key(
        n: *const BIGNUM,
        e: *const BIGNUM,
        d: *const BIGNUM,
        p: *const BIGNUM,
        q: *const BIGNUM,
        dmp1: *const BIGNUM,
        dmq1: *const BIGNUM,
        iqmp: *const BIGNUM,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_new() -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_method(engine: *const ENGINE) -> *mut RSA;
}
extern "C" {
    pub fn RSA_free(rsa: *mut RSA);
}
extern "C" {
    pub fn RSA_up_ref(rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_bits(rsa: *const RSA) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RSA_get0_n(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_e(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_d(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_p(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_q(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmp1(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_dmq1(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_iqmp(rsa: *const RSA) -> *const BIGNUM;
}
extern "C" {
    pub fn RSA_get0_key(
        rsa: *const RSA,
        out_n: *mut *const BIGNUM,
        out_e: *mut *const BIGNUM,
        out_d: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_get0_factors(rsa: *const RSA, out_p: *mut *const BIGNUM, out_q: *mut *const BIGNUM);
}
extern "C" {
    pub fn RSA_get0_crt_params(
        rsa: *const RSA,
        out_dmp1: *mut *const BIGNUM,
        out_dmq1: *mut *const BIGNUM,
        out_iqmp: *mut *const BIGNUM,
    );
}
extern "C" {
    pub fn RSA_set0_key(
        rsa: *mut RSA,
        n: *mut BIGNUM,
        e: *mut BIGNUM,
        d: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_factors(rsa: *mut RSA, p: *mut BIGNUM, q: *mut BIGNUM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set0_crt_params(
        rsa: *mut RSA,
        dmp1: *mut BIGNUM,
        dmq1: *mut BIGNUM,
        iqmp: *mut BIGNUM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key_ex(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        e: *const BIGNUM,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key_fips(
        rsa: *mut RSA,
        bits: ::std::os::raw::c_int,
        cb: *mut BN_GENCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_encrypt(
        rsa: *mut RSA,
        out_len: *mut usize,
        out: *mut u8,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_decrypt(
        rsa: *mut RSA,
        out_len: *mut usize,
        out: *mut u8,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_encrypt(
        flen: usize,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_decrypt(
        flen: usize,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign(
        hash_nid: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign_pss_mgf1(
        rsa: *mut RSA,
        out_len: *mut usize,
        out: *mut u8,
        max_out: usize,
        digest: *const u8,
        digest_len: usize,
        md: *const EVP_MD,
        mgf1_md: *const EVP_MD,
        salt_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_sign_raw(
        rsa: *mut RSA,
        out_len: *mut usize,
        out: *mut u8,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify(
        hash_nid: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
        sig: *const u8,
        sig_len: usize,
        rsa: *mut RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_pss_mgf1(
        rsa: *mut RSA,
        digest: *const u8,
        digest_len: usize,
        md: *const EVP_MD,
        mgf1_md: *const EVP_MD,
        salt_len: ::std::os::raw::c_int,
        sig: *const u8,
        sig_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_raw(
        rsa: *mut RSA,
        out_len: *mut usize,
        out: *mut u8,
        max_out: usize,
        in_: *const u8,
        in_len: usize,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_encrypt(
        flen: usize,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_decrypt(
        flen: usize,
        from: *const u8,
        to: *mut u8,
        rsa: *mut RSA,
        padding: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_size(rsa: *const RSA) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn RSA_is_opaque(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSAPublicKey_dup(rsa: *const RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSAPrivateKey_dup(rsa: *const RSA) -> *mut RSA;
}
extern "C" {
    pub fn RSA_check_key(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_check_fips(key: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS_mgf1(
        rsa: *const RSA,
        mHash: *const u8,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        EM: *const u8,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS_mgf1(
        rsa: *const RSA,
        EM: *mut u8,
        mHash: *const u8,
        Hash: *const EVP_MD,
        mgf1Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP_mgf1(
        to: *mut u8,
        to_len: usize,
        from: *const u8,
        from_len: usize,
        param: *const u8,
        param_len: usize,
        md: *const EVP_MD,
        mgf1md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS1_MGF1(
        out: *mut u8,
        len: usize,
        seed: *const u8,
        seed_len: usize,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_add_pkcs1_prefix(
        out_msg: *mut *mut u8,
        out_msg_len: *mut usize,
        is_alloced: *mut ::std::os::raw::c_int,
        hash_nid: ::std::os::raw::c_int,
        digest: *const u8,
        digest_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_parse_public_key(cbs: *mut CBS) -> *mut RSA;
}
extern "C" {
    pub fn RSA_public_key_from_bytes(in_: *const u8, in_len: usize) -> *mut RSA;
}
extern "C" {
    pub fn RSA_marshal_public_key(cbb: *mut CBB, rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_public_key_to_bytes(
        out_bytes: *mut *mut u8,
        out_len: *mut usize,
        rsa: *const RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_parse_private_key(cbs: *mut CBS) -> *mut RSA;
}
extern "C" {
    pub fn RSA_private_key_from_bytes(in_: *const u8, in_len: usize) -> *mut RSA;
}
extern "C" {
    pub fn RSA_marshal_private_key(cbb: *mut CBB, rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_private_key_to_bytes(
        out_bytes: *mut *mut u8,
        out_len: *mut usize,
        rsa: *const RSA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_new_private_key_no_crt(
        n: *const BIGNUM,
        e: *const BIGNUM,
        d: *const BIGNUM,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_private_key_no_e(n: *const BIGNUM, d: *const BIGNUM) -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_public_key_large_e(n: *const BIGNUM, e: *const BIGNUM) -> *mut RSA;
}
extern "C" {
    pub fn RSA_new_private_key_large_e(
        n: *const BIGNUM,
        e: *const BIGNUM,
        d: *const BIGNUM,
        p: *const BIGNUM,
        q: *const BIGNUM,
        dmp1: *const BIGNUM,
        dmq1: *const BIGNUM,
        iqmp: *const BIGNUM,
    ) -> *mut RSA;
}
extern "C" {
    pub fn RSA_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_set_ex_data(
        rsa: *mut RSA,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get_ex_data(
        rsa: *const RSA,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn RSA_flags(rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_test_flags(rsa: *const RSA, flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_on(rsa: *mut RSA, ctx: *mut BN_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_blinding_off_temp_for_accp_compatibility(rsa: *mut RSA);
}
extern "C" {
    pub fn RSA_pkey_ctx_ctrl(
        ctx: *mut EVP_PKEY_CTX,
        optype: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        p1: ::std::os::raw::c_int,
        p2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_generate_key(
        bits: ::std::os::raw::c_int,
        e: u64,
        callback: *mut ::std::os::raw::c_void,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn d2i_RSAPublicKey(
        out: *mut *mut RSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPublicKey(in_: *const RSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_RSAPrivateKey(
        out: *mut *mut RSA,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA;
}
extern "C" {
    pub fn i2d_RSAPrivateKey(in_: *const RSA, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_PSS(
        rsa: *const RSA,
        EM: *mut u8,
        mHash: *const u8,
        Hash: *const EVP_MD,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_verify_PKCS1_PSS(
        rsa: *const RSA,
        mHash: *const u8,
        Hash: *const EVP_MD,
        EM: *const u8,
        sLen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_padding_add_PKCS1_OAEP(
        to: *mut u8,
        to_len: usize,
        from: *const u8,
        from_len: usize,
        param: *const u8,
        param_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_print(
        bio: *mut BIO,
        rsa: *const RSA,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_print_fp(
        fp: *mut FILE,
        rsa: *const RSA,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RSA_get0_pss_params(rsa: *const RSA) -> *const RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_new_method_no_e(engine: *const ENGINE, n: *const BIGNUM) -> *mut RSA;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_meth_st {
    pub common: openssl_method_common_st,
    pub app_data: *mut ::std::os::raw::c_void,
    pub init: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    pub finish: ::std::option::Option<unsafe extern "C" fn(rsa: *mut RSA) -> ::std::os::raw::c_int>,
    pub size: ::std::option::Option<unsafe extern "C" fn(rsa: *const RSA) -> usize>,
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            type_: ::std::os::raw::c_int,
            m: *const u8,
            m_length: ::std::os::raw::c_uint,
            sigret: *mut u8,
            siglen: *mut ::std::os::raw::c_uint,
            rsa: *const RSA,
        ) -> ::std::os::raw::c_int,
    >,
    pub sign_raw: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            out_len: *mut usize,
            out: *mut u8,
            max_out: usize,
            in_: *const u8,
            in_len: usize,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub decrypt: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            out_len: *mut usize,
            out: *mut u8,
            max_out: usize,
            in_: *const u8,
            in_len: usize,
            padding: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub private_transform: ::std::option::Option<
        unsafe extern "C" fn(
            rsa: *mut RSA,
            out: *mut u8,
            in_: *const u8,
            len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rsa_meth_st() {
    const UNINIT: ::std::mem::MaybeUninit<rsa_meth_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsa_meth_st>(),
        80usize,
        concat!("Size of: ", stringify!(rsa_meth_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_meth_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_meth_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(common)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(app_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finish) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign_raw) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(sign_raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decrypt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(decrypt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_transform) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(private_transform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_meth_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type sk_X509_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509)>;
pub type sk_X509_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509) -> *mut X509>;
pub type sk_X509_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509,
        arg2: *const *const X509,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static X509_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_up_ref(x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_chain_up_ref(chain: *mut stack_st_X509) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_dup(x509: *mut X509) -> *mut X509;
}
extern "C" {
    pub fn X509_free(x509: *mut X509);
}
extern "C" {
    pub fn d2i_X509(
        out: *mut *mut X509,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_parse_from_buffer(buf: *mut CRYPTO_BUFFER) -> *mut X509;
}
extern "C" {
    pub fn i2d_X509(x509: *mut X509, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_version(x509: *const X509) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_get0_serialNumber(x509: *const X509) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_get0_notBefore(x509: *const X509) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_get0_notAfter(x509: *const X509) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_get_issuer_name(x509: *const X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_get_subject_name(x509: *const X509) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_get_X509_PUBKEY(x509: *const X509) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_get0_pubkey(x509: *const X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get_pubkey(x509: *const X509) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_get0_pubkey_bitstr(x509: *const X509) -> *mut ASN1_BIT_STRING;
}
extern "C" {
    pub fn X509_check_private_key(
        x509: *const X509,
        pkey: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get0_uids(
        x509: *const X509,
        out_issuer_uid: *mut *const ASN1_BIT_STRING,
        out_subject_uid: *mut *const ASN1_BIT_STRING,
    );
}
extern "C" {
    pub fn X509_get_extension_flags(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get_pathlen(x509: *mut X509) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_get_key_usage(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get_extended_key_usage(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get0_subject_key_id(x509: *mut X509) -> *const ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_get0_authority_key_id(x509: *mut X509) -> *const ASN1_OCTET_STRING;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_NAME {
    _unused: [u8; 0],
}
pub type sk_GENERAL_NAME_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GENERAL_NAME)>;
pub type sk_GENERAL_NAME_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const GENERAL_NAME) -> *mut GENERAL_NAME>;
pub type sk_GENERAL_NAME_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const GENERAL_NAME,
        arg2: *const *const GENERAL_NAME,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_GENERAL_NAME_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GENERAL_NAME,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type GENERAL_NAMES = stack_st_GENERAL_NAME;
extern "C" {
    pub fn X509_get0_authority_issuer(x509: *mut X509) -> *const GENERAL_NAMES;
}
extern "C" {
    pub fn X509_get0_authority_serial(x509: *mut X509) -> *const ASN1_INTEGER;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_EXTENSION {
    _unused: [u8; 0],
}
extern "C" {
    pub fn X509_get0_extensions(x509: *const X509) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_get_ext_count(x: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_NID(
        x: *const X509,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_OBJ(
        x: *const X509,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext_by_critical(
        x: *const X509,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ext(x: *const X509, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_get_ext_d2i(
        x509: *const X509,
        nid: ::std::os::raw::c_int,
        out_critical: *mut ::std::os::raw::c_int,
        out_idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_get0_tbs_sigalg(x509: *const X509) -> *const X509_ALGOR;
}
extern "C" {
    pub fn X509_get_signature_info(
        x509: *mut X509,
        digest_nid: *mut ::std::os::raw::c_int,
        pubkey_nid: *mut ::std::os::raw::c_int,
        sec_bits: *mut ::std::os::raw::c_int,
        flags: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get0_signature(
        out_sig: *mut *const ASN1_BIT_STRING,
        out_alg: *mut *const X509_ALGOR,
        x509: *const X509,
    );
}
extern "C" {
    pub fn X509_get_signature_nid(x509: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_tbs(
        x509: *mut X509,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_verify(x509: *mut X509, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get1_email(x509: *const X509) -> *mut stack_st_OPENSSL_STRING;
}
extern "C" {
    pub fn X509_get1_ocsp(x509: *const X509) -> *mut stack_st_OPENSSL_STRING;
}
extern "C" {
    pub fn X509_email_free(sk: *mut stack_st_OPENSSL_STRING);
}
extern "C" {
    pub fn X509_new() -> *mut X509;
}
extern "C" {
    pub fn X509_set_version(
        x509: *mut X509,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_serialNumber(
        x509: *mut X509,
        serial: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set1_notBefore(x509: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set1_notAfter(x509: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_getm_notBefore(x509: *mut X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_getm_notAfter(x: *mut X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_set_issuer_name(x509: *mut X509, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_subject_name(x509: *mut X509, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_pubkey(x509: *mut X509, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_delete_ext(x: *mut X509, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_add_ext(
        x: *mut X509,
        ex: *const X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_add1_ext_i2d(
        x: *mut X509,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_sign(
        x509: *mut X509,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_sign_ctx(x509: *mut X509, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_re_X509_tbs(
        x509: *mut X509,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set1_signature_algo(
        x509: *mut X509,
        algo: *const X509_ALGOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set1_signature_value(
        x509: *mut X509,
        sig: *const u8,
        sig_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_AUX(x509: *mut X509, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_AUX(
        x509: *mut *mut X509,
        inp: *mut *const u8,
        length: ::std::os::raw::c_long,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_alias_set1(
        x509: *mut X509,
        name: *const u8,
        len: ossl_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_keyid_set1(
        x509: *mut X509,
        id: *const u8,
        len: ossl_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_alias_get0(x509: *const X509, out_len: *mut ::std::os::raw::c_int) -> *const u8;
}
extern "C" {
    pub fn X509_keyid_get0(x509: *const X509, out_len: *mut ::std::os::raw::c_int) -> *const u8;
}
extern "C" {
    pub fn X509_add1_trust_object(
        x509: *mut X509,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_add1_reject_object(
        x509: *mut X509,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_trust_clear(x509: *mut X509);
}
extern "C" {
    pub fn X509_reject_clear(x509: *mut X509);
}
pub type sk_X509_CRL_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_CRL)>;
pub type sk_X509_CRL_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_CRL) -> *mut X509_CRL>;
pub type sk_X509_CRL_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_CRL,
        arg2: *const *const X509_CRL,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_CRL_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_CRL,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_REVOKED {
    _unused: [u8; 0],
}
pub type sk_X509_REVOKED_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_REVOKED)>;
pub type sk_X509_REVOKED_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_REVOKED) -> *mut X509_REVOKED>;
pub type sk_X509_REVOKED_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_REVOKED,
        arg2: *const *const X509_REVOKED,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_REVOKED_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_REVOKED,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static X509_CRL_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_CRL_up_ref(crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_dup(crl: *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_CRL_free(crl: *mut X509_CRL);
}
extern "C" {
    pub fn d2i_X509_CRL(
        out: *mut *mut X509_CRL,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn i2d_X509_CRL(crl: *mut X509_CRL, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_version(crl: *const X509_CRL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_CRL_get0_lastUpdate(crl: *const X509_CRL) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get0_nextUpdate(crl: *const X509_CRL) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_issuer(crl: *const X509_CRL) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_CRL_get0_by_serial(
        crl: *mut X509_CRL,
        out: *mut *mut X509_REVOKED,
        serial: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get0_by_cert(
        crl: *mut X509_CRL,
        out: *mut *mut X509_REVOKED,
        x509: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_REVOKED(crl: *mut X509_CRL) -> *mut stack_st_X509_REVOKED;
}
extern "C" {
    pub fn X509_CRL_get0_extensions(crl: *const X509_CRL) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_get_ext_count(x: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_NID(
        x: *const X509_CRL,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_OBJ(
        x: *const X509_CRL,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext_by_critical(
        x: *const X509_CRL,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_ext(x: *const X509_CRL, loc: ::std::os::raw::c_int) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_get_ext_d2i(
        crl: *const X509_CRL,
        nid: ::std::os::raw::c_int,
        out_critical: *mut ::std::os::raw::c_int,
        out_idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_CRL_get0_signature(
        crl: *const X509_CRL,
        out_sig: *mut *const ASN1_BIT_STRING,
        out_alg: *mut *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_CRL_get_signature_nid(crl: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_CRL_tbs(
        crl: *mut X509_CRL,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_verify(crl: *mut X509_CRL, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_new() -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_CRL_set_version(
        crl: *mut X509_CRL,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set_issuer_name(
        crl: *mut X509_CRL,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_lastUpdate(
        crl: *mut X509_CRL,
        tm: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_nextUpdate(
        crl: *mut X509_CRL,
        tm: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_add0_revoked(
        crl: *mut X509_CRL,
        rev: *mut X509_REVOKED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sort(crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_delete_ext(x: *mut X509_CRL, loc: ::std::os::raw::c_int)
        -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_CRL_add_ext(
        x: *mut X509_CRL,
        ex: *const X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_add1_ext_i2d(
        x: *mut X509_CRL,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sign(
        crl: *mut X509_CRL,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_sign_ctx(crl: *mut X509_CRL, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_re_X509_CRL_tbs(
        crl: *mut X509_CRL,
        outp: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_signature_algo(
        crl: *mut X509_CRL,
        algo: *const X509_ALGOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_set1_signature_value(
        crl: *mut X509_CRL,
        sig: *const u8,
        sig_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_http_nbio(
        rctx: *mut OCSP_REQ_CTX,
        pcrl: *mut *mut X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_REVOKED_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_REVOKED_new() -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REVOKED_free(rev: *mut X509_REVOKED);
}
extern "C" {
    pub fn d2i_X509_REVOKED(
        out: *mut *mut X509_REVOKED,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn i2d_X509_REVOKED(alg: *const X509_REVOKED, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_dup(rev: *const X509_REVOKED) -> *mut X509_REVOKED;
}
extern "C" {
    pub fn X509_REVOKED_get0_serialNumber(revoked: *const X509_REVOKED) -> *const ASN1_INTEGER;
}
extern "C" {
    pub fn X509_REVOKED_set_serialNumber(
        revoked: *mut X509_REVOKED,
        serial: *const ASN1_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_revocationDate(revoked: *const X509_REVOKED) -> *const ASN1_TIME;
}
extern "C" {
    pub fn X509_REVOKED_set_revocationDate(
        revoked: *mut X509_REVOKED,
        tm: *const ASN1_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get0_extensions(r: *const X509_REVOKED) -> *const stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_count(x: *const X509_REVOKED) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_NID(
        x: *const X509_REVOKED,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_OBJ(
        x: *const X509_REVOKED,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_by_critical(
        x: *const X509_REVOKED,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext(
        x: *const X509_REVOKED,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_delete_ext(
        x: *mut X509_REVOKED,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_REVOKED_add_ext(
        x: *mut X509_REVOKED,
        ex: *const X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REVOKED_get_ext_d2i(
        revoked: *const X509_REVOKED,
        nid: ::std::os::raw::c_int,
        out_critical: *mut ::std::os::raw::c_int,
        out_idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_REVOKED_add1_ext_i2d(
        x: *mut X509_REVOKED,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_REQ_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_REQ_dup(req: *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_free(req: *mut X509_REQ);
}
extern "C" {
    pub fn d2i_X509_REQ(
        out: *mut *mut X509_REQ,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn i2d_X509_REQ(req: *mut X509_REQ, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_version(req: *const X509_REQ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn X509_REQ_get_subject_name(req: *const X509_REQ) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_REQ_get0_pubkey(req: *const X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_get_pubkey(req: *const X509_REQ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_REQ_check_private_key(
        req: *const X509_REQ,
        pkey: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_count(req: *const X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr(
        req: *const X509_REQ,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_NID(
        req: *const X509_REQ,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_attr_by_OBJ(
        req: *const X509_REQ,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_extension_nid(nid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get_extensions(req: *const X509_REQ) -> *mut stack_st_X509_EXTENSION;
}
extern "C" {
    pub fn X509_REQ_get0_signature(
        req: *const X509_REQ,
        out_sig: *mut *const ASN1_BIT_STRING,
        out_alg: *mut *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_REQ_get_signature_nid(req: *const X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_verify(req: *mut X509_REQ, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_get1_email(req: *const X509_REQ) -> *mut stack_st_OPENSSL_STRING;
}
extern "C" {
    pub fn X509_REQ_new() -> *mut X509_REQ;
}
extern "C" {
    pub fn X509_REQ_set_version(
        req: *mut X509_REQ,
        version: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_subject_name(
        req: *mut X509_REQ,
        name: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set_pubkey(req: *mut X509_REQ, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_delete_attr(
        req: *mut X509_REQ,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_REQ_add1_attr(
        req: *mut X509_REQ,
        attr: *const X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_OBJ(
        req: *mut X509_REQ,
        obj: *const ASN1_OBJECT,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_NID(
        req: *mut X509_REQ,
        nid: ::std::os::raw::c_int,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add1_attr_by_txt(
        req: *mut X509_REQ,
        attrname: *const ::std::os::raw::c_char,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add_extensions_nid(
        req: *mut X509_REQ,
        exts: *const stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_add_extensions(
        req: *mut X509_REQ,
        exts: *const stack_st_X509_EXTENSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_sign(
        req: *mut X509_REQ,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_sign_ctx(req: *mut X509_REQ, ctx: *mut EVP_MD_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_re_X509_REQ_tbs(req: *mut X509_REQ, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set1_signature_algo(
        req: *mut X509_REQ,
        algo: *const X509_ALGOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_set1_signature_value(
        req: *mut X509_REQ,
        sig: *const u8,
        sig_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME_ENTRY {
    _unused: [u8; 0],
}
pub type sk_X509_NAME_ENTRY_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_NAME_ENTRY)>;
pub type sk_X509_NAME_ENTRY_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY,
>;
pub type sk_X509_NAME_ENTRY_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_NAME_ENTRY,
        arg2: *const *const X509_NAME_ENTRY,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_NAME_ENTRY_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_NAME_ENTRY,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_NAME {
    _unused: [u8; 0],
}
pub type sk_X509_NAME_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_NAME)>;
pub type sk_X509_NAME_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_NAME) -> *mut X509_NAME>;
pub type sk_X509_NAME_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_NAME,
        arg2: *const *const X509_NAME,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_NAME_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_NAME,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static X509_NAME_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_new() -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_free(name: *mut X509_NAME);
}
extern "C" {
    pub fn d2i_X509_NAME(
        out: *mut *mut X509_NAME,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_NAME;
}
extern "C" {
    pub fn i2d_X509_NAME(in_: *mut X509_NAME, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_dup(name: *mut X509_NAME) -> *mut X509_NAME;
}
extern "C" {
    pub fn X509_NAME_cmp(a: *const X509_NAME, b: *const X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get0_der(
        name: *mut X509_NAME,
        out_der: *mut *const u8,
        out_der_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_set(xn: *mut *mut X509_NAME, name: *mut X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_entry_count(name: *const X509_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_NID(
        name: *const X509_NAME,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_index_by_OBJ(
        name: *const X509_NAME,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_entry(
        name: *const X509_NAME,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_delete_entry(
        name: *mut X509_NAME,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_add_entry(
        name: *mut X509_NAME,
        entry: *const X509_NAME_ENTRY,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_OBJ(
        name: *mut X509_NAME,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_NID(
        name: *mut X509_NAME,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_add_entry_by_txt(
        name: *mut X509_NAME,
        field: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
        loc: ::std::os::raw::c_int,
        set: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static X509_NAME_ENTRY_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_NAME_ENTRY_new() -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_free(entry: *mut X509_NAME_ENTRY);
}
extern "C" {
    pub fn d2i_X509_NAME_ENTRY(
        out: *mut *mut X509_NAME_ENTRY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn i2d_X509_NAME_ENTRY(
        in_: *const X509_NAME_ENTRY,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_dup(entry: *const X509_NAME_ENTRY) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_object(entry: *const X509_NAME_ENTRY) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_object(
        entry: *mut X509_NAME_ENTRY,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_get_data(entry: *const X509_NAME_ENTRY) -> *mut ASN1_STRING;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set_data(
        entry: *mut X509_NAME_ENTRY,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_set(entry: *const X509_NAME_ENTRY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_OBJ(
        out: *mut *mut X509_NAME_ENTRY,
        obj: *const ASN1_OBJECT,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_NID(
        out: *mut *mut X509_NAME_ENTRY,
        nid: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub fn X509_NAME_ENTRY_create_by_txt(
        out: *mut *mut X509_NAME_ENTRY,
        field: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const u8,
        len: ossl_ssize_t,
    ) -> *mut X509_NAME_ENTRY;
}
extern "C" {
    pub static X509_PUBKEY_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_PUBKEY_new() -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn X509_PUBKEY_free(key: *mut X509_PUBKEY);
}
extern "C" {
    pub fn d2i_X509_PUBKEY(
        out: *mut *mut X509_PUBKEY,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_PUBKEY;
}
extern "C" {
    pub fn i2d_X509_PUBKEY(key: *const X509_PUBKEY, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_set(x: *mut *mut X509_PUBKEY, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0(key: *const X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_PUBKEY_get(key: *const X509_PUBKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn X509_PUBKEY_set0_param(
        pub_: *mut X509_PUBKEY,
        obj: *mut ASN1_OBJECT,
        param_type: ::std::os::raw::c_int,
        param_value: *mut ::std::os::raw::c_void,
        key: *mut u8,
        key_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0_param(
        out_obj: *mut *mut ASN1_OBJECT,
        out_key: *mut *const u8,
        out_key_len: *mut ::std::os::raw::c_int,
        out_alg: *mut *mut X509_ALGOR,
        pub_: *mut X509_PUBKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PUBKEY_get0_public_key(pub_: *const X509_PUBKEY) -> *const ASN1_BIT_STRING;
}
extern "C" {
    pub static X509_EXTENSION_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_EXTENSION_new() -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_free(ex: *mut X509_EXTENSION);
}
extern "C" {
    pub fn d2i_X509_EXTENSION(
        out: *mut *mut X509_EXTENSION,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn i2d_X509_EXTENSION(
        ex: *const X509_EXTENSION,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_dup(ex: *const X509_EXTENSION) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_NID(
        ex: *mut *mut X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        crit: ::std::os::raw::c_int,
        data: *const ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_create_by_OBJ(
        ex: *mut *mut X509_EXTENSION,
        obj: *const ASN1_OBJECT,
        crit: ::std::os::raw::c_int,
        data: *const ASN1_OCTET_STRING,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509_EXTENSION_get_object(ex: *const X509_EXTENSION) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_EXTENSION_get_data(ne: *const X509_EXTENSION) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_EXTENSION_get_critical(ex: *const X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_object(
        ex: *mut X509_EXTENSION,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_critical(
        ex: *mut X509_EXTENSION,
        crit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_EXTENSION_set_data(
        ex: *mut X509_EXTENSION,
        data: *const ASN1_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
pub type sk_X509_EXTENSION_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_EXTENSION)>;
pub type sk_X509_EXTENSION_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_EXTENSION) -> *mut X509_EXTENSION>;
pub type sk_X509_EXTENSION_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_EXTENSION,
        arg2: *const *const X509_EXTENSION,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_EXTENSION_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_EXTENSION,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_EXTENSIONS = stack_st_X509_EXTENSION;
extern "C" {
    pub static X509_EXTENSIONS_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_X509_EXTENSIONS(
        out: *mut *mut X509_EXTENSIONS,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_EXTENSIONS;
}
extern "C" {
    pub fn i2d_X509_EXTENSIONS(
        alg: *const X509_EXTENSIONS,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_count(x: *const stack_st_X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_NID(
        x: *const stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_OBJ(
        x: *const stack_st_X509_EXTENSION,
        obj: *const ASN1_OBJECT,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext_by_critical(
        x: *const stack_st_X509_EXTENSION,
        crit: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509v3_get_ext(
        x: *const stack_st_X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_delete_ext(
        x: *mut stack_st_X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509v3_add_ext(
        x: *mut *mut stack_st_X509_EXTENSION,
        ex: *const X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> *mut stack_st_X509_EXTENSION;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct otherName_st {
    pub type_id: *mut ASN1_OBJECT,
    pub value: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_otherName_st() {
    const UNINIT: ::std::mem::MaybeUninit<otherName_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<otherName_st>(),
        16usize,
        concat!("Size of: ", stringify!(otherName_st))
    );
    assert_eq!(
        ::std::mem::align_of::<otherName_st>(),
        8usize,
        concat!("Alignment of ", stringify!(otherName_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(otherName_st),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(otherName_st),
            "::",
            stringify!(value)
        )
    );
}
pub type OTHERNAME = otherName_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EDIPartyName_st {
    pub nameAssigner: *mut ASN1_STRING,
    pub partyName: *mut ASN1_STRING,
}
#[test]
fn bindgen_test_layout_EDIPartyName_st() {
    const UNINIT: ::std::mem::MaybeUninit<EDIPartyName_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<EDIPartyName_st>(),
        16usize,
        concat!("Size of: ", stringify!(EDIPartyName_st))
    );
    assert_eq!(
        ::std::mem::align_of::<EDIPartyName_st>(),
        8usize,
        concat!("Alignment of ", stringify!(EDIPartyName_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nameAssigner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EDIPartyName_st),
            "::",
            stringify!(nameAssigner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partyName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EDIPartyName_st),
            "::",
            stringify!(partyName)
        )
    );
}
pub type EDIPARTYNAME = EDIPartyName_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GENERAL_NAME_st {
    pub type_: ::std::os::raw::c_int,
    pub d: GENERAL_NAME_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GENERAL_NAME_st__bindgen_ty_1 {
    pub ptr: *mut ::std::os::raw::c_char,
    pub otherName: *mut OTHERNAME,
    pub rfc822Name: *mut ASN1_IA5STRING,
    pub dNSName: *mut ASN1_IA5STRING,
    pub x400Address: *mut ASN1_STRING,
    pub directoryName: *mut X509_NAME,
    pub ediPartyName: *mut EDIPARTYNAME,
    pub uniformResourceIdentifier: *mut ASN1_IA5STRING,
    pub iPAddress: *mut ASN1_OCTET_STRING,
    pub registeredID: *mut ASN1_OBJECT,
    pub ip: *mut ASN1_OCTET_STRING,
    pub dirn: *mut X509_NAME,
    pub ia5: *mut ASN1_IA5STRING,
    pub rid: *mut ASN1_OBJECT,
}
#[test]
fn bindgen_test_layout_GENERAL_NAME_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<GENERAL_NAME_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GENERAL_NAME_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(GENERAL_NAME_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GENERAL_NAME_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(GENERAL_NAME_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).otherName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(otherName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rfc822Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(rfc822Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dNSName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(dNSName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x400Address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(x400Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directoryName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(directoryName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ediPartyName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(ediPartyName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniformResourceIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(uniformResourceIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iPAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(iPAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registeredID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(registeredID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(dirn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ia5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(ia5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st__bindgen_ty_1),
            "::",
            stringify!(rid)
        )
    );
}
#[test]
fn bindgen_test_layout_GENERAL_NAME_st() {
    const UNINIT: ::std::mem::MaybeUninit<GENERAL_NAME_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GENERAL_NAME_st>(),
        16usize,
        concat!("Size of: ", stringify!(GENERAL_NAME_st))
    );
    assert_eq!(
        ::std::mem::align_of::<GENERAL_NAME_st>(),
        8usize,
        concat!("Alignment of ", stringify!(GENERAL_NAME_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_NAME_st),
            "::",
            stringify!(d)
        )
    );
}
extern "C" {
    pub fn GENERAL_NAME_new() -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn GENERAL_NAME_free(gen: *mut GENERAL_NAME);
}
extern "C" {
    pub fn d2i_GENERAL_NAME(
        out: *mut *mut GENERAL_NAME,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn i2d_GENERAL_NAME(in_: *mut GENERAL_NAME, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GENERAL_NAME_dup(gen: *mut GENERAL_NAME) -> *mut GENERAL_NAME;
}
extern "C" {
    pub fn GENERAL_NAMES_new() -> *mut GENERAL_NAMES;
}
extern "C" {
    pub fn GENERAL_NAMES_free(gens: *mut GENERAL_NAMES);
}
extern "C" {
    pub fn d2i_GENERAL_NAMES(
        out: *mut *mut GENERAL_NAMES,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut GENERAL_NAMES;
}
extern "C" {
    pub fn i2d_GENERAL_NAMES(in_: *mut GENERAL_NAMES, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OTHERNAME_new() -> *mut OTHERNAME;
}
extern "C" {
    pub fn OTHERNAME_free(name: *mut OTHERNAME);
}
extern "C" {
    pub fn EDIPARTYNAME_new() -> *mut EDIPARTYNAME;
}
extern "C" {
    pub fn EDIPARTYNAME_free(name: *mut EDIPARTYNAME);
}
extern "C" {
    pub fn GENERAL_NAME_set0_value(
        gen: *mut GENERAL_NAME,
        type_: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn GENERAL_NAME_get0_value(
        gen: *const GENERAL_NAME,
        out_type: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn GENERAL_NAME_set0_othername(
        gen: *mut GENERAL_NAME,
        oid: *mut ASN1_OBJECT,
        value: *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GENERAL_NAME_get0_otherName(
        gen: *const GENERAL_NAME,
        out_oid: *mut *mut ASN1_OBJECT,
        out_value: *mut *mut ASN1_TYPE,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ALGOR {
    _unused: [u8; 0],
}
pub type sk_X509_ALGOR_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_ALGOR)>;
pub type sk_X509_ALGOR_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_ALGOR) -> *mut X509_ALGOR>;
pub type sk_X509_ALGOR_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_ALGOR,
        arg2: *const *const X509_ALGOR,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_ALGOR_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_ALGOR,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static X509_ALGOR_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_ALGOR_new() -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_dup(alg: *const X509_ALGOR) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn X509_ALGOR_free(alg: *mut X509_ALGOR);
}
extern "C" {
    pub fn d2i_X509_ALGOR(
        out: *mut *mut X509_ALGOR,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ALGOR;
}
extern "C" {
    pub fn i2d_X509_ALGOR(alg: *const X509_ALGOR, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ALGOR_set0(
        alg: *mut X509_ALGOR,
        obj: *mut ASN1_OBJECT,
        param_type: ::std::os::raw::c_int,
        param_value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ALGOR_get0(
        out_obj: *mut *const ASN1_OBJECT,
        out_param_type: *mut ::std::os::raw::c_int,
        out_param_value: *mut *const ::std::os::raw::c_void,
        alg: *const X509_ALGOR,
    );
}
extern "C" {
    pub fn X509_ALGOR_set_md(alg: *mut X509_ALGOR, md: *const EVP_MD);
}
extern "C" {
    pub fn X509_ALGOR_cmp(a: *const X509_ALGOR, b: *const X509_ALGOR) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_ATTRIBUTE {
    _unused: [u8; 0],
}
pub type sk_X509_ATTRIBUTE_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_ATTRIBUTE)>;
pub type sk_X509_ATTRIBUTE_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE>;
pub type sk_X509_ATTRIBUTE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_ATTRIBUTE,
        arg2: *const *const X509_ATTRIBUTE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_ATTRIBUTE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_ATTRIBUTE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub static X509_ATTRIBUTE_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_ATTRIBUTE_new() -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_dup(attr: *const X509_ATTRIBUTE) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_free(attr: *mut X509_ATTRIBUTE);
}
extern "C" {
    pub fn d2i_X509_ATTRIBUTE(
        out: *mut *mut X509_ATTRIBUTE,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn i2d_X509_ATTRIBUTE(
        alg: *const X509_ATTRIBUTE,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create(
        nid: ::std::os::raw::c_int,
        attrtype: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_NID(
        attr: *mut *mut X509_ATTRIBUTE,
        nid: ::std::os::raw::c_int,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_OBJ(
        attr: *mut *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_create_by_txt(
        attr: *mut *mut X509_ATTRIBUTE,
        attrname: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        bytes: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> *mut X509_ATTRIBUTE;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_object(
        attr: *mut X509_ATTRIBUTE,
        obj: *const ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_set1_data(
        attr: *mut X509_ATTRIBUTE,
        attrtype: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_data(
        attr: *mut X509_ATTRIBUTE,
        idx: ::std::os::raw::c_int,
        attrtype: ::std::os::raw::c_int,
        unused: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_ATTRIBUTE_count(attr: *const X509_ATTRIBUTE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_object(attr: *mut X509_ATTRIBUTE) -> *mut ASN1_OBJECT;
}
extern "C" {
    pub fn X509_ATTRIBUTE_get0_type(
        attr: *mut X509_ATTRIBUTE,
        idx: ::std::os::raw::c_int,
    ) -> *mut ASN1_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spki_st {
    pub spkac: *mut NETSCAPE_SPKAC,
    pub sig_algor: *mut X509_ALGOR,
    pub signature: *mut ASN1_BIT_STRING,
}
#[test]
fn bindgen_test_layout_Netscape_spki_st() {
    const UNINIT: ::std::mem::MaybeUninit<Netscape_spki_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Netscape_spki_st>(),
        24usize,
        concat!("Size of: ", stringify!(Netscape_spki_st))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_spki_st>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_spki_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spkac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(spkac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig_algor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(sig_algor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spki_st),
            "::",
            stringify!(signature)
        )
    );
}
extern "C" {
    pub static NETSCAPE_SPKI_it: ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_SPKI_new() -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_free(spki: *mut NETSCAPE_SPKI);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKI(
        out: *mut *mut NETSCAPE_SPKI,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKI(
        spki: *const NETSCAPE_SPKI,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_verify(
        spki: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_decode(
        str_: *const ::std::os::raw::c_char,
        len: ossl_ssize_t,
    ) -> *mut NETSCAPE_SPKI;
}
extern "C" {
    pub fn NETSCAPE_SPKI_b64_encode(spki: *mut NETSCAPE_SPKI) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn NETSCAPE_SPKI_get_pubkey(spki: *const NETSCAPE_SPKI) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn NETSCAPE_SPKI_set_pubkey(
        spki: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_sign(
        spki: *mut NETSCAPE_SPKI,
        pkey: *mut EVP_PKEY,
        md: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Netscape_spkac_st {
    pub pubkey: *mut X509_PUBKEY,
    pub challenge: *mut ASN1_IA5STRING,
}
#[test]
fn bindgen_test_layout_Netscape_spkac_st() {
    const UNINIT: ::std::mem::MaybeUninit<Netscape_spkac_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Netscape_spkac_st>(),
        16usize,
        concat!("Size of: ", stringify!(Netscape_spkac_st))
    );
    assert_eq!(
        ::std::mem::align_of::<Netscape_spkac_st>(),
        8usize,
        concat!("Alignment of ", stringify!(Netscape_spkac_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pubkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spkac_st),
            "::",
            stringify!(pubkey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).challenge) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Netscape_spkac_st),
            "::",
            stringify!(challenge)
        )
    );
}
extern "C" {
    pub static NETSCAPE_SPKAC_it: ASN1_ITEM;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_new() -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn NETSCAPE_SPKAC_free(spkac: *mut NETSCAPE_SPKAC);
}
extern "C" {
    pub fn d2i_NETSCAPE_SPKAC(
        out: *mut *mut NETSCAPE_SPKAC,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut NETSCAPE_SPKAC;
}
extern "C" {
    pub fn i2d_NETSCAPE_SPKAC(
        spkac: *const NETSCAPE_SPKAC,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NETSCAPE_SPKI_print(out: *mut BIO, spki: *mut NETSCAPE_SPKI) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_pss_params_st {
    pub hashAlgorithm: *mut X509_ALGOR,
    pub maskGenAlgorithm: *mut X509_ALGOR,
    pub saltLength: *mut ASN1_INTEGER,
    pub trailerField: *mut ASN1_INTEGER,
    pub maskHash: *mut X509_ALGOR,
}
#[test]
fn bindgen_test_layout_rsa_pss_params_st() {
    const UNINIT: ::std::mem::MaybeUninit<rsa_pss_params_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rsa_pss_params_st>(),
        40usize,
        concat!("Size of: ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rsa_pss_params_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_pss_params_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashAlgorithm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(hashAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maskGenAlgorithm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(maskGenAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saltLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(saltLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailerField) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(trailerField)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maskHash) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_pss_params_st),
            "::",
            stringify!(maskHash)
        )
    );
}
extern "C" {
    pub static RSA_PSS_PARAMS_it: ASN1_ITEM;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_new() -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn RSA_PSS_PARAMS_free(params: *mut RSA_PSS_PARAMS);
}
extern "C" {
    pub fn d2i_RSA_PSS_PARAMS(
        out: *mut *mut RSA_PSS_PARAMS,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut RSA_PSS_PARAMS;
}
extern "C" {
    pub fn i2d_RSA_PSS_PARAMS(
        in_: *const RSA_PSS_PARAMS,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static PKCS8_PRIV_KEY_INFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_new() -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_PRIV_KEY_INFO_free(key: *mut PKCS8_PRIV_KEY_INFO);
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO(
        out: *mut *mut PKCS8_PRIV_KEY_INFO,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO(
        key: *const PKCS8_PRIV_KEY_INFO,
        outp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn EVP_PKCS82PKEY(p8: *const PKCS8_PRIV_KEY_INFO) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn EVP_PKEY2PKCS8(pkey: *const EVP_PKEY) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub static X509_SIG_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509_SIG_new() -> *mut X509_SIG;
}
extern "C" {
    pub fn X509_SIG_free(key: *mut X509_SIG);
}
extern "C" {
    pub fn d2i_X509_SIG(
        out: *mut *mut X509_SIG,
        inp: *mut *const u8,
        len: ::std::os::raw::c_long,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn i2d_X509_SIG(sig: *const X509_SIG, outp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_SIG_get0(
        sig: *const X509_SIG,
        out_alg: *mut *const X509_ALGOR,
        out_digest: *mut *const ASN1_OCTET_STRING,
    );
}
extern "C" {
    pub fn X509_SIG_getm(
        sig: *mut X509_SIG,
        out_alg: *mut *mut X509_ALGOR,
        out_digest: *mut *mut ASN1_OCTET_STRING,
    );
}
extern "C" {
    pub fn X509_print_ex(
        bp: *mut BIO,
        x: *mut X509,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_ex_fp(
        fp: *mut FILE,
        x: *mut X509,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_print_fp(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print(bp: *mut BIO, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_print_fp(fp: *mut FILE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print_ex(
        bp: *mut BIO,
        x: *mut X509_REQ,
        nmflag: ::std::os::raw::c_ulong,
        cflag: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print(bp: *mut BIO, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_print_fp(fp: *mut FILE, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print_ex(
        out: *mut BIO,
        nm: *const X509_NAME,
        indent: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_print(
        bp: *mut BIO,
        name: *const X509_NAME,
        obase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_oneline(
        name: *const X509_NAME,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_NAME_print_ex_fp(
        fp: *mut FILE,
        nm: *const X509_NAME,
        indent: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_signature_dump(
        bio: *mut BIO,
        sig: *const ASN1_STRING,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_signature_print(
        bio: *mut BIO,
        alg: *const X509_ALGOR,
        sig: *const ASN1_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_print(
        out: *mut BIO,
        ext: *const X509_EXTENSION,
        flag: ::std::os::raw::c_ulong,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_print_fp(
        out: *mut FILE,
        ext: *const X509_EXTENSION,
        flag: ::std::os::raw::c_int,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_extensions_print(
        out: *mut BIO,
        title: *const ::std::os::raw::c_char,
        exts: *const stack_st_X509_EXTENSION,
        flag: ::std::os::raw::c_ulong,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GENERAL_NAME_print(out: *mut BIO, gen: *const GENERAL_NAME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_pubkey_digest(
        x509: *const X509,
        md: *const EVP_MD,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_digest(
        x509: *const X509,
        md: *const EVP_MD,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_digest(
        crl: *const X509_CRL,
        md: *const EVP_MD,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_REQ_digest(
        req: *const X509_REQ,
        md: *const EVP_MD,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_digest(
        name: *const X509_NAME,
        md: *const EVP_MD,
        out: *mut u8,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_bio(bp: *mut BIO, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn d2i_X509_CRL_bio(bp: *mut BIO, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn d2i_X509_REQ_bio(bp: *mut BIO, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn d2i_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn d2i_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn d2i_PKCS8_bio(bp: *mut BIO, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_bio(
        bp: *mut BIO,
        p8inf: *mut *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn d2i_PUBKEY_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_DHparams_bio(bp: *mut BIO, dh: *mut *mut DH) -> *mut DH;
}
extern "C" {
    pub fn d2i_PrivateKey_bio(bp: *mut BIO, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_X509_bio(bp: *mut BIO, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_CRL_bio(bp: *mut BIO, crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_REQ_bio(bp: *mut BIO, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSAPublicKey_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_bio(bp: *mut BIO, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_bio(bp: *mut BIO, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_bio(bp: *mut BIO, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_bio(bp: *mut BIO, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ECPrivateKey_bio(bp: *mut BIO, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8_bio(bp: *mut BIO, p8: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_bio(
        bp: *mut BIO,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_bio(bp: *mut BIO, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PUBKEY_bio(bp: *mut BIO, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DHparams_bio(bp: *mut BIO, dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_bio(bp: *mut BIO, key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_X509_fp(fp: *mut FILE, x509: *mut *mut X509) -> *mut X509;
}
extern "C" {
    pub fn d2i_X509_CRL_fp(fp: *mut FILE, crl: *mut *mut X509_CRL) -> *mut X509_CRL;
}
extern "C" {
    pub fn d2i_X509_REQ_fp(fp: *mut FILE, req: *mut *mut X509_REQ) -> *mut X509_REQ;
}
extern "C" {
    pub fn d2i_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn d2i_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn d2i_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut *mut RSA) -> *mut RSA;
}
extern "C" {
    pub fn d2i_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn d2i_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut *mut DSA) -> *mut DSA;
}
extern "C" {
    pub fn d2i_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn d2i_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut *mut EC_KEY) -> *mut EC_KEY;
}
extern "C" {
    pub fn d2i_PKCS8_fp(fp: *mut FILE, p8: *mut *mut X509_SIG) -> *mut X509_SIG;
}
extern "C" {
    pub fn d2i_PKCS8_PRIV_KEY_INFO_fp(
        fp: *mut FILE,
        p8inf: *mut *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn d2i_PrivateKey_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn d2i_PUBKEY_fp(fp: *mut FILE, a: *mut *mut EVP_PKEY) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_X509_fp(fp: *mut FILE, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_CRL_fp(fp: *mut FILE, crl: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_X509_REQ_fp(fp: *mut FILE, req: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSAPrivateKey_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSAPublicKey_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_RSA_PUBKEY_fp(fp: *mut FILE, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSA_PUBKEY_fp(fp: *mut FILE, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_DSAPrivateKey_fp(fp: *mut FILE, dsa: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_EC_PUBKEY_fp(fp: *mut FILE, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_ECPrivateKey_fp(fp: *mut FILE, eckey: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8_fp(fp: *mut FILE, p8: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8_PRIV_KEY_INFO_fp(
        fp: *mut FILE,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKeyInfo_fp(fp: *mut FILE, key: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PrivateKey_fp(fp: *mut FILE, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PUBKEY_fp(fp: *mut FILE, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_find_by_issuer_and_serial(
        sk: *const stack_st_X509,
        name: *mut X509_NAME,
        serial: *const ASN1_INTEGER,
    ) -> *mut X509;
}
extern "C" {
    pub fn X509_find_by_subject(sk: *const stack_st_X509, name: *mut X509_NAME) -> *mut X509;
}
extern "C" {
    pub fn X509_cmp_time(s: *const ASN1_TIME, t: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_cmp_time_posix(s: *const ASN1_TIME, t: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_cmp_current_time(s: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_time_adj(
        s: *mut ASN1_TIME,
        offset_sec: ::std::os::raw::c_long,
        t: *const time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_time_adj_ex(
        s: *mut ASN1_TIME,
        offset_day: ::std::os::raw::c_int,
        offset_sec: ::std::os::raw::c_long,
        t: *const time_t,
    ) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_gmtime_adj(s: *mut ASN1_TIME, offset_sec: ::std::os::raw::c_long)
        -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_issuer_name_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_subject_name_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_cmp(a: *const X509_CRL, b: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_issuer_name_hash(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_subject_name_hash(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_issuer_name_hash_old(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_subject_name_hash_old(x509: *mut X509) -> u32;
}
extern "C" {
    pub fn X509_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_ex_data(
        r: *mut X509,
        idx: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_get_ex_data(
        r: *mut X509,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_STORE_CTX_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_ex_data(
        ctx: *mut X509_STORE_CTX,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509_STORE_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_ex_data(
        ctx: *mut X509_STORE,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_get_ex_data(
        ctx: *mut X509_STORE,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ASN1_digest(
        i2d: i2d_of_void,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_char,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_digest(
        it: *const ASN1_ITEM,
        type_: *const EVP_MD,
        data: *mut ::std::os::raw::c_void,
        md: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_verify(
        it: *const ASN1_ITEM,
        algor1: *const X509_ALGOR,
        signature: *const ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        data: *mut ::std::os::raw::c_void,
        pkey: *mut EVP_PKEY,
        type_: *const EVP_MD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ASN1_item_sign_ctx(
        it: *const ASN1_ITEM,
        algor1: *mut X509_ALGOR,
        algor2: *mut X509_ALGOR,
        signature: *mut ASN1_BIT_STRING,
        asn: *mut ::std::os::raw::c_void,
        ctx: *mut EVP_MD_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_supported_extension(ex: *const X509_EXTENSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_ca(x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_issued(issuer: *mut X509, subject: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_check(
        x509: *mut X509,
        nc: *mut NAME_CONSTRAINTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_host(
        x509: *const X509,
        chk: *const ::std::os::raw::c_char,
        chklen: usize,
        flags: ::std::os::raw::c_uint,
        out_peername: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_email(
        x509: *const X509,
        chk: *const ::std::os::raw::c_char,
        chklen: usize,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_ip(
        x509: *const X509,
        chk: *const u8,
        chklen: usize,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_ip_asc(
        x509: *const X509,
        ipasc: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct private_key_st {
    pub dec_pkey: *mut EVP_PKEY,
}
#[test]
fn bindgen_test_layout_private_key_st() {
    const UNINIT: ::std::mem::MaybeUninit<private_key_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<private_key_st>(),
        8usize,
        concat!("Size of: ", stringify!(private_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<private_key_st>(),
        8usize,
        concat!("Alignment of ", stringify!(private_key_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dec_pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(private_key_st),
            "::",
            stringify!(dec_pkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_info_st {
    pub x509: *mut X509,
    pub crl: *mut X509_CRL,
    pub x_pkey: *mut X509_PKEY,
    pub enc_cipher: EVP_CIPHER_INFO,
    pub enc_len: ::std::os::raw::c_int,
    pub enc_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_X509_info_st() {
    const UNINIT: ::std::mem::MaybeUninit<X509_info_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<X509_info_st>(),
        64usize,
        concat!("Size of: ", stringify!(X509_info_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_info_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_info_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x509) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(x509)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_pkey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(x_pkey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enc_cipher) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_cipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enc_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enc_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_info_st),
            "::",
            stringify!(enc_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_INFO {
    _unused: [u8; 0],
}
pub type sk_X509_INFO_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_INFO)>;
pub type sk_X509_INFO_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_INFO) -> *mut X509_INFO>;
pub type sk_X509_INFO_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_INFO,
        arg2: *const *const X509_INFO,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_INFO_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_INFO,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn X509_INFO_free(info: *mut X509_INFO);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_ctx {
    pub flags: ::std::os::raw::c_int,
    pub issuer_cert: *const X509,
    pub subject_cert: *const X509,
    pub subject_req: *const X509_REQ,
    pub crl: *const X509_CRL,
    pub db: *const CONF,
}
#[test]
fn bindgen_test_layout_v3_ext_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<v3_ext_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v3_ext_ctx>(),
        48usize,
        concat!("Size of: ", stringify!(v3_ext_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<v3_ext_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(v3_ext_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_ctx),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).issuer_cert) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_ctx),
            "::",
            stringify!(issuer_cert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_cert) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_ctx),
            "::",
            stringify!(subject_cert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_req) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_ctx),
            "::",
            stringify!(subject_req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_ctx),
            "::",
            stringify!(crl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_ctx),
            "::",
            stringify!(db)
        )
    );
}
extern "C" {
    pub fn X509V3_set_ctx(
        ctx: *mut X509V3_CTX,
        issuer: *const X509,
        subject: *const X509,
        req: *const X509_REQ,
        crl: *const X509_CRL,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn X509V3_set_nconf(ctx: *mut X509V3_CTX, conf: *const CONF);
}
extern "C" {
    pub fn X509V3_EXT_nconf(
        conf: *const CONF,
        ctx: *const X509V3_CTX,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_nconf_nid(
        conf: *const CONF,
        ctx: *const X509V3_CTX,
        ext_nid: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_conf_nid(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *const X509V3_CTX,
        ext_nid: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_EXT_add_nconf_sk(
        conf: *const CONF,
        ctx: *const X509V3_CTX,
        section: *const ::std::os::raw::c_char,
        sk: *mut *mut stack_st_X509_EXTENSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_add_nconf(
        conf: *const CONF,
        ctx: *const X509V3_CTX,
        section: *const ::std::os::raw::c_char,
        cert: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_REQ_add_nconf(
        conf: *const CONF,
        ctx: *const X509V3_CTX,
        section: *const ::std::os::raw::c_char,
        req: *mut X509_REQ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_CRL_add_nconf(
        conf: *const CONF,
        ctx: *const X509V3_CTX,
        section: *const ::std::os::raw::c_char,
        crl: *mut X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_conf(
        conf: *mut lhash_st_CONF_VALUE,
        ctx: *mut X509V3_CTX,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn i2s_ASN1_OCTET_STRING(
        method: *const X509V3_EXT_METHOD,
        oct: *const ASN1_OCTET_STRING,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn s2i_ASN1_OCTET_STRING(
        method: *const X509V3_EXT_METHOD,
        ctx: *const X509V3_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn i2s_ASN1_INTEGER(
        method: *const X509V3_EXT_METHOD,
        aint: *const ASN1_INTEGER,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn s2i_ASN1_INTEGER(
        method: *const X509V3_EXT_METHOD,
        value: *const ::std::os::raw::c_char,
    ) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn i2s_ASN1_ENUMERATED(
        method: *const X509V3_EXT_METHOD,
        aint: *const ASN1_ENUMERATED,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509V3_conf_free(val: *mut CONF_VALUE);
}
extern "C" {
    pub fn i2v_GENERAL_NAME(
        method: *const X509V3_EXT_METHOD,
        gen: *const GENERAL_NAME,
        ret: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn i2v_GENERAL_NAMES(
        method: *const X509V3_EXT_METHOD,
        gen: *const GENERAL_NAMES,
        extlist: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn a2i_IPADDRESS(ipasc: *const ::std::os::raw::c_char) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn a2i_IPADDRESS_NC(ipasc: *const ::std::os::raw::c_char) -> *mut ASN1_OCTET_STRING;
}
extern "C" {
    pub fn X509_get_notBefore(x509: *const X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_get_notAfter(x509: *const X509) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_set_notBefore(x509: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_set_notAfter(x509: *mut X509, tm: *const ASN1_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_CRL_get_lastUpdate(crl: *mut X509_CRL) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_CRL_get_nextUpdate(crl: *mut X509_CRL) -> *mut ASN1_TIME;
}
extern "C" {
    pub fn X509_get_serialNumber(x509: *mut X509) -> *mut ASN1_INTEGER;
}
extern "C" {
    pub fn X509_NAME_get_text_by_OBJ(
        name: *const X509_NAME,
        obj: *const ASN1_OBJECT,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_get_text_by_NID(
        name: *const X509_NAME,
        nid: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_parent_ctx(ctx: *mut X509_STORE_CTX) -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_LOOKUP_free(ctx: *mut X509_LOOKUP);
}
extern "C" {
    pub fn X509_STORE_CTX_cleanup(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509V3_add_standard_extensions() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_parse_list(line: *const ::std::os::raw::c_char) -> *mut stack_st_CONF_VALUE;
}
extern "C" {
    pub fn X509_STORE_CTX_get_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_trusted_stack(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
pub type X509_STORE_CTX_verify_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: *mut X509_STORE_CTX,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn X509_STORE_CTX_set_verify_cb(
        ctx: *mut X509_STORE_CTX,
        verify_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ok: ::std::os::raw::c_int,
                ctx: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn X509_STORE_set_verify_cb(store: *mut X509_STORE, verify_cb: X509_STORE_CTX_verify_cb);
}
pub type X509_STORE_CTX_get_crl_fn = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut X509_STORE_CTX,
        crl: *mut *mut X509_CRL,
        x: *mut X509,
    ) -> ::std::os::raw::c_int,
>;
pub type X509_STORE_CTX_check_crl_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut X509_STORE_CTX, crl: *mut X509_CRL) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn X509_STORE_set_get_crl(store: *mut X509_STORE, get_crl: X509_STORE_CTX_get_crl_fn);
}
extern "C" {
    pub fn X509_STORE_set_check_crl(store: *mut X509_STORE, check_crl: X509_STORE_CTX_check_crl_fn);
}
extern "C" {
    pub fn X509_STORE_CTX_set_chain(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X509_algor_st {
    pub algorithm: *mut ASN1_OBJECT,
    pub parameter: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_X509_algor_st() {
    const UNINIT: ::std::mem::MaybeUninit<X509_algor_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<X509_algor_st>(),
        16usize,
        concat!("Size of: ", stringify!(X509_algor_st))
    );
    assert_eq!(
        ::std::mem::align_of::<X509_algor_st>(),
        8usize,
        concat!("Alignment of ", stringify!(X509_algor_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_algor_st),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X509_algor_st),
            "::",
            stringify!(parameter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_DIST_POINT {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_trust_st {
    pub trust: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub check_trust: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const X509_TRUST,
            arg2: *mut X509,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: ::std::os::raw::c_int,
    pub arg2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_x509_trust_st() {
    const UNINIT: ::std::mem::MaybeUninit<x509_trust_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x509_trust_st>(),
        40usize,
        concat!("Size of: ", stringify!(x509_trust_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_trust_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_trust_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trust) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_trust) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(check_trust)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_trust_st),
            "::",
            stringify!(arg2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_TRUST {
    _unused: [u8; 0],
}
pub type sk_X509_TRUST_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_TRUST)>;
pub type sk_X509_TRUST_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_TRUST) -> *mut X509_TRUST>;
pub type sk_X509_TRUST_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_TRUST,
        arg2: *const *const X509_TRUST,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_TRUST_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_TRUST,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn X509_verify_cert_error_string(
        err: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_area() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_dir_env() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_cert_file_env() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_get_default_private_dir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_TRUST_set(
        t: *mut ::std::os::raw::c_int,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_cmp(a: *const X509, b: *const X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_NAME_hash(name: *mut X509_NAME) -> u32;
}
extern "C" {
    pub fn X509_NAME_hash_old(name: *mut X509_NAME) -> u32;
}
extern "C" {
    pub fn X509_CRL_match(a: *const X509_CRL, b: *const X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_verify_cert(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_trust(
        x: *mut X509,
        id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0(idx: ::std::os::raw::c_int) -> *const X509_TRUST;
}
extern "C" {
    pub fn X509_TRUST_get_by_id(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get_flags(xp: *const X509_TRUST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_TRUST_get0_name(xp: *const X509_TRUST) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_TRUST_get_trust(xp: *const X509_TRUST) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_OBJECT {
    _unused: [u8; 0],
}
pub type sk_X509_OBJECT_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_OBJECT)>;
pub type sk_X509_OBJECT_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_OBJECT) -> *mut X509_OBJECT>;
pub type sk_X509_OBJECT_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_OBJECT,
        arg2: *const *const X509_OBJECT,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_OBJECT_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_OBJECT,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn X509_STORE_set_depth(
        store: *mut X509_STORE,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_depth(ctx: *mut X509_STORE_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_LOOKUP_load_file(
        lookup: *mut X509_LOOKUP,
        path: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_add_dir(
        lookup: *mut X509_LOOKUP,
        path: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_new() -> *mut X509_OBJECT;
}
extern "C" {
    pub fn X509_OBJECT_free(obj: *mut X509_OBJECT);
}
extern "C" {
    pub fn X509_OBJECT_get_type(obj: *const X509_OBJECT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_get0_X509(obj: *const X509_OBJECT) -> *mut X509;
}
extern "C" {
    pub fn X509_OBJECT_get0_X509_CRL(a: *const X509_OBJECT) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_OBJECT_set1_X509(a: *mut X509_OBJECT, obj: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_OBJECT_set1_X509_CRL(
        a: *mut X509_OBJECT,
        obj: *mut X509_CRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_lock(v: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_unlock(v: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_new() -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_up_ref(store: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_free(store: *mut X509_STORE);
}
extern "C" {
    pub fn X509_STORE_get0_objects(st: *mut X509_STORE) -> *mut stack_st_X509_OBJECT;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_certs(
        st: *mut X509_STORE_CTX,
        nm: *mut X509_NAME,
    ) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_crls(
        st: *mut X509_STORE_CTX,
        nm: *mut X509_NAME,
    ) -> *mut stack_st_X509_CRL;
}
extern "C" {
    pub fn X509_STORE_set_flags(
        store: *mut X509_STORE,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_purpose(
        store: *mut X509_STORE,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_trust(
        store: *mut X509_STORE,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set1_param(
        store: *mut X509_STORE,
        param: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_get0_param(store: *mut X509_STORE) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_CTX_new() -> *mut X509_STORE_CTX;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_issuer(
        issuer: *mut *mut X509,
        ctx: *mut X509_STORE_CTX,
        x: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_free(ctx: *mut X509_STORE_CTX);
}
extern "C" {
    pub fn X509_STORE_CTX_init(
        ctx: *mut X509_STORE_CTX,
        store: *mut X509_STORE,
        x509: *mut X509,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_trusted_stack(ctx: *mut X509_STORE_CTX, sk: *mut stack_st_X509);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_store(ctx: *mut X509_STORE_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_cert(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_add_lookup(
        v: *mut X509_STORE,
        m: *const X509_LOOKUP_METHOD,
    ) -> *mut X509_LOOKUP;
}
extern "C" {
    pub fn X509_LOOKUP_hash_dir() -> *const X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_LOOKUP_file() -> *const X509_LOOKUP_METHOD;
}
extern "C" {
    pub fn X509_STORE_add_cert(ctx: *mut X509_STORE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_add_crl(ctx: *mut X509_STORE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_LOOKUP_ctrl(
        ctx: *mut X509_LOOKUP,
        cmd: ::std::os::raw::c_int,
        argc: *const ::std::os::raw::c_char,
        argl: ::std::os::raw::c_long,
        ret: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_cert_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_load_cert_crl_file(
        ctx: *mut X509_LOOKUP,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_load_locations(
        ctx: *mut X509_STORE,
        file: *const ::std::os::raw::c_char,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_set_default_paths(ctx: *mut X509_STORE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_error(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_error(ctx: *mut X509_STORE_CTX, s: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_STORE_CTX_get_error_depth(ctx: *mut X509_STORE_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_current_cert(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_issuer(ctx: *mut X509_STORE_CTX) -> *mut X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_current_crl(ctx: *mut X509_STORE_CTX) -> *mut X509_CRL;
}
extern "C" {
    pub fn X509_STORE_CTX_get0_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_get1_chain(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set_cert(c: *mut X509_STORE_CTX, x: *mut X509);
}
extern "C" {
    pub fn X509_STORE_CTX_get0_untrusted(ctx: *mut X509_STORE_CTX) -> *mut stack_st_X509;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_crls(c: *mut X509_STORE_CTX, sk: *mut stack_st_X509_CRL);
}
extern "C" {
    pub fn X509_STORE_CTX_set_purpose(
        ctx: *mut X509_STORE_CTX,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_trust(
        ctx: *mut X509_STORE_CTX,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_purpose_inherit(
        ctx: *mut X509_STORE_CTX,
        def_purpose: ::std::os::raw::c_int,
        purpose: ::std::os::raw::c_int,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_set_flags(ctx: *mut X509_STORE_CTX, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn X509_STORE_CTX_set_time(
        ctx: *mut X509_STORE_CTX,
        flags: ::std::os::raw::c_ulong,
        t: time_t,
    );
}
extern "C" {
    pub fn X509_STORE_CTX_set_time_posix(
        ctx: *mut X509_STORE_CTX,
        flags: ::std::os::raw::c_ulong,
        t: i64,
    );
}
extern "C" {
    pub fn X509_STORE_CTX_get0_param(ctx: *mut X509_STORE_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_STORE_CTX_set0_param(ctx: *mut X509_STORE_CTX, param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_STORE_CTX_set_default(
        ctx: *mut X509_STORE_CTX,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_STORE_CTX_get_by_subject(
        vs: *mut X509_STORE_CTX,
        type_: ::std::os::raw::c_int,
        name: *mut X509_NAME,
        ret: *mut X509_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_new() -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_free(param: *mut X509_VERIFY_PARAM);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_inherit(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1(
        to: *mut X509_VERIFY_PARAM,
        from: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_clear_flags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_flags(param: *const X509_VERIFY_PARAM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_purpose(
        param: *mut X509_VERIFY_PARAM,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_trust(
        param: *mut X509_VERIFY_PARAM,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_depth(param: *mut X509_VERIFY_PARAM, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_time(param: *mut X509_VERIFY_PARAM, t: time_t);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_time_posix(param: *mut X509_VERIFY_PARAM, t: i64);
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add0_policy(
        param: *mut X509_VERIFY_PARAM,
        policy: *mut ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_policies(
        param: *mut X509_VERIFY_PARAM,
        policies: *const stack_st_ASN1_OBJECT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
        namelen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_add1_host(
        param: *mut X509_VERIFY_PARAM,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set_hostflags(
        param: *mut X509_VERIFY_PARAM,
        flags: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_email(
        param: *mut X509_VERIFY_PARAM,
        email: *const ::std::os::raw::c_char,
        emaillen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip(
        param: *mut X509_VERIFY_PARAM,
        ip: *const ::std::os::raw::c_uchar,
        iplen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_set1_ip_asc(
        param: *mut X509_VERIFY_PARAM,
        ipasc: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_VERIFY_PARAM_get_depth(param: *const X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
pub type X509V3_EXT_NEW =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>;
pub type X509V3_EXT_FREE =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type X509V3_EXT_D2I = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *const ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type X509V3_EXT_I2D = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int,
>;
pub type X509V3_EXT_I2V = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const X509V3_EXT_METHOD,
        ext: *mut ::std::os::raw::c_void,
        extlist: *mut stack_st_CONF_VALUE,
    ) -> *mut stack_st_CONF_VALUE,
>;
pub type X509V3_EXT_V2I = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const X509V3_EXT_METHOD,
        ctx: *const X509V3_CTX,
        values: *const stack_st_CONF_VALUE,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type X509V3_EXT_I2S = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const X509V3_EXT_METHOD,
        ext: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
pub type X509V3_EXT_S2I = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const X509V3_EXT_METHOD,
        ctx: *const X509V3_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type X509V3_EXT_I2R = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const X509V3_EXT_METHOD,
        ext: *mut ::std::os::raw::c_void,
        out: *mut BIO,
        indent: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type X509V3_EXT_R2I = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const X509V3_EXT_METHOD,
        ctx: *const X509V3_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v3_ext_method {
    pub ext_nid: ::std::os::raw::c_int,
    pub ext_flags: ::std::os::raw::c_int,
    pub it: *const ASN1_ITEM_st,
    pub ext_new: X509V3_EXT_NEW,
    pub ext_free: X509V3_EXT_FREE,
    pub d2i: X509V3_EXT_D2I,
    pub i2d: X509V3_EXT_I2D,
    pub i2s: X509V3_EXT_I2S,
    pub s2i: X509V3_EXT_S2I,
    pub i2v: X509V3_EXT_I2V,
    pub v2i: X509V3_EXT_V2I,
    pub i2r: X509V3_EXT_I2R,
    pub r2i: X509V3_EXT_R2I,
    pub usr_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_v3_ext_method() {
    const UNINIT: ::std::mem::MaybeUninit<v3_ext_method> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v3_ext_method>(),
        104usize,
        concat!("Size of: ", stringify!(v3_ext_method))
    );
    assert_eq!(
        ::std::mem::align_of::<v3_ext_method>(),
        8usize,
        concat!("Alignment of ", stringify!(v3_ext_method))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext_nid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(ext_nid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext_flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(ext_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext_new) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(ext_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext_free) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(ext_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d2i) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(d2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2d) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(i2d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2s) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(i2s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s2i) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(s2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2v) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(i2v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2i) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(v2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2r) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(i2r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r2i) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(r2i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(v3_ext_method),
            "::",
            stringify!(usr_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509V3_EXT_METHOD {
    _unused: [u8; 0],
}
pub type sk_X509V3_EXT_METHOD_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509V3_EXT_METHOD)>;
pub type sk_X509V3_EXT_METHOD_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const X509V3_EXT_METHOD) -> *mut X509V3_EXT_METHOD,
>;
pub type sk_X509V3_EXT_METHOD_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509V3_EXT_METHOD,
        arg2: *const *const X509V3_EXT_METHOD,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509V3_EXT_METHOD_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509V3_EXT_METHOD,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BASIC_CONSTRAINTS_st {
    pub ca: ::std::os::raw::c_int,
    pub pathlen: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_BASIC_CONSTRAINTS_st() {
    const UNINIT: ::std::mem::MaybeUninit<BASIC_CONSTRAINTS_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BASIC_CONSTRAINTS_st>(),
        16usize,
        concat!("Size of: ", stringify!(BASIC_CONSTRAINTS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<BASIC_CONSTRAINTS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(BASIC_CONSTRAINTS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ca) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BASIC_CONSTRAINTS_st),
            "::",
            stringify!(ca)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BASIC_CONSTRAINTS_st),
            "::",
            stringify!(pathlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_DESCRIPTION_st {
    pub method: *mut ASN1_OBJECT,
    pub location: *mut GENERAL_NAME,
}
#[test]
fn bindgen_test_layout_ACCESS_DESCRIPTION_st() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_DESCRIPTION_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_DESCRIPTION_st>(),
        16usize,
        concat!("Size of: ", stringify!(ACCESS_DESCRIPTION_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_DESCRIPTION_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ACCESS_DESCRIPTION_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DESCRIPTION_st),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DESCRIPTION_st),
            "::",
            stringify!(location)
        )
    );
}
pub type ACCESS_DESCRIPTION = ACCESS_DESCRIPTION_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_ACCESS_DESCRIPTION {
    _unused: [u8; 0],
}
pub type sk_ACCESS_DESCRIPTION_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ACCESS_DESCRIPTION)>;
pub type sk_ACCESS_DESCRIPTION_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ACCESS_DESCRIPTION) -> *mut ACCESS_DESCRIPTION,
>;
pub type sk_ACCESS_DESCRIPTION_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const ACCESS_DESCRIPTION,
        arg2: *const *const ACCESS_DESCRIPTION,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_ACCESS_DESCRIPTION_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ACCESS_DESCRIPTION,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type AUTHORITY_INFO_ACCESS = stack_st_ACCESS_DESCRIPTION;
pub type EXTENDED_KEY_USAGE = stack_st_ASN1_OBJECT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DIST_POINT_NAME_st {
    pub type_: ::std::os::raw::c_int,
    pub name: DIST_POINT_NAME_st__bindgen_ty_1,
    pub dpname: *mut X509_NAME,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DIST_POINT_NAME_st__bindgen_ty_1 {
    pub fullname: *mut GENERAL_NAMES,
    pub relativename: *mut stack_st_X509_NAME_ENTRY,
}
#[test]
fn bindgen_test_layout_DIST_POINT_NAME_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<DIST_POINT_NAME_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DIST_POINT_NAME_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(DIST_POINT_NAME_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DIST_POINT_NAME_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(DIST_POINT_NAME_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_NAME_st__bindgen_ty_1),
            "::",
            stringify!(fullname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relativename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_NAME_st__bindgen_ty_1),
            "::",
            stringify!(relativename)
        )
    );
}
#[test]
fn bindgen_test_layout_DIST_POINT_NAME_st() {
    const UNINIT: ::std::mem::MaybeUninit<DIST_POINT_NAME_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DIST_POINT_NAME_st>(),
        24usize,
        concat!("Size of: ", stringify!(DIST_POINT_NAME_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DIST_POINT_NAME_st>(),
        8usize,
        concat!("Alignment of ", stringify!(DIST_POINT_NAME_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_NAME_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_NAME_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dpname) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_NAME_st),
            "::",
            stringify!(dpname)
        )
    );
}
pub type DIST_POINT_NAME = DIST_POINT_NAME_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIST_POINT_st {
    pub distpoint: *mut DIST_POINT_NAME,
    pub reasons: *mut ASN1_BIT_STRING,
    pub CRLissuer: *mut GENERAL_NAMES,
}
#[test]
fn bindgen_test_layout_DIST_POINT_st() {
    const UNINIT: ::std::mem::MaybeUninit<DIST_POINT_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DIST_POINT_st>(),
        24usize,
        concat!("Size of: ", stringify!(DIST_POINT_st))
    );
    assert_eq!(
        ::std::mem::align_of::<DIST_POINT_st>(),
        8usize,
        concat!("Alignment of ", stringify!(DIST_POINT_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_st),
            "::",
            stringify!(distpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reasons) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_st),
            "::",
            stringify!(reasons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CRLissuer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIST_POINT_st),
            "::",
            stringify!(CRLissuer)
        )
    );
}
pub type CRL_DIST_POINTS = stack_st_DIST_POINT;
pub type sk_DIST_POINT_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut DIST_POINT)>;
pub type sk_DIST_POINT_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const DIST_POINT) -> *mut DIST_POINT>;
pub type sk_DIST_POINT_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const DIST_POINT,
        arg2: *const *const DIST_POINT,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_DIST_POINT_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut DIST_POINT,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUTHORITY_KEYID_st {
    pub keyid: *mut ASN1_OCTET_STRING,
    pub issuer: *mut GENERAL_NAMES,
    pub serial: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_AUTHORITY_KEYID_st() {
    const UNINIT: ::std::mem::MaybeUninit<AUTHORITY_KEYID_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AUTHORITY_KEYID_st>(),
        24usize,
        concat!("Size of: ", stringify!(AUTHORITY_KEYID_st))
    );
    assert_eq!(
        ::std::mem::align_of::<AUTHORITY_KEYID_st>(),
        8usize,
        concat!("Alignment of ", stringify!(AUTHORITY_KEYID_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AUTHORITY_KEYID_st),
            "::",
            stringify!(keyid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).issuer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AUTHORITY_KEYID_st),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AUTHORITY_KEYID_st),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTICEREF_st {
    pub organization: *mut ASN1_STRING,
    pub noticenos: *mut stack_st_ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_NOTICEREF_st() {
    const UNINIT: ::std::mem::MaybeUninit<NOTICEREF_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NOTICEREF_st>(),
        16usize,
        concat!("Size of: ", stringify!(NOTICEREF_st))
    );
    assert_eq!(
        ::std::mem::align_of::<NOTICEREF_st>(),
        8usize,
        concat!("Alignment of ", stringify!(NOTICEREF_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).organization) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NOTICEREF_st),
            "::",
            stringify!(organization)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noticenos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NOTICEREF_st),
            "::",
            stringify!(noticenos)
        )
    );
}
pub type NOTICEREF = NOTICEREF_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USERNOTICE_st {
    pub noticeref: *mut NOTICEREF,
    pub exptext: *mut ASN1_STRING,
}
#[test]
fn bindgen_test_layout_USERNOTICE_st() {
    const UNINIT: ::std::mem::MaybeUninit<USERNOTICE_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<USERNOTICE_st>(),
        16usize,
        concat!("Size of: ", stringify!(USERNOTICE_st))
    );
    assert_eq!(
        ::std::mem::align_of::<USERNOTICE_st>(),
        8usize,
        concat!("Alignment of ", stringify!(USERNOTICE_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noticeref) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USERNOTICE_st),
            "::",
            stringify!(noticeref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exptext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USERNOTICE_st),
            "::",
            stringify!(exptext)
        )
    );
}
pub type USERNOTICE = USERNOTICE_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct POLICYQUALINFO_st {
    pub pqualid: *mut ASN1_OBJECT,
    pub d: POLICYQUALINFO_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union POLICYQUALINFO_st__bindgen_ty_1 {
    pub cpsuri: *mut ASN1_IA5STRING,
    pub usernotice: *mut USERNOTICE,
    pub other: *mut ASN1_TYPE,
}
#[test]
fn bindgen_test_layout_POLICYQUALINFO_st__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<POLICYQUALINFO_st__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POLICYQUALINFO_st__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(POLICYQUALINFO_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<POLICYQUALINFO_st__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(POLICYQUALINFO_st__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpsuri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYQUALINFO_st__bindgen_ty_1),
            "::",
            stringify!(cpsuri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usernotice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYQUALINFO_st__bindgen_ty_1),
            "::",
            stringify!(usernotice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).other) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYQUALINFO_st__bindgen_ty_1),
            "::",
            stringify!(other)
        )
    );
}
#[test]
fn bindgen_test_layout_POLICYQUALINFO_st() {
    const UNINIT: ::std::mem::MaybeUninit<POLICYQUALINFO_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POLICYQUALINFO_st>(),
        16usize,
        concat!("Size of: ", stringify!(POLICYQUALINFO_st))
    );
    assert_eq!(
        ::std::mem::align_of::<POLICYQUALINFO_st>(),
        8usize,
        concat!("Alignment of ", stringify!(POLICYQUALINFO_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pqualid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYQUALINFO_st),
            "::",
            stringify!(pqualid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYQUALINFO_st),
            "::",
            stringify!(d)
        )
    );
}
pub type POLICYQUALINFO = POLICYQUALINFO_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICYQUALINFO {
    _unused: [u8; 0],
}
pub type sk_POLICYQUALINFO_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut POLICYQUALINFO)>;
pub type sk_POLICYQUALINFO_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const POLICYQUALINFO) -> *mut POLICYQUALINFO>;
pub type sk_POLICYQUALINFO_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const POLICYQUALINFO,
        arg2: *const *const POLICYQUALINFO,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_POLICYQUALINFO_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut POLICYQUALINFO,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POLICYINFO_st {
    pub policyid: *mut ASN1_OBJECT,
    pub qualifiers: *mut stack_st_POLICYQUALINFO,
}
#[test]
fn bindgen_test_layout_POLICYINFO_st() {
    const UNINIT: ::std::mem::MaybeUninit<POLICYINFO_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POLICYINFO_st>(),
        16usize,
        concat!("Size of: ", stringify!(POLICYINFO_st))
    );
    assert_eq!(
        ::std::mem::align_of::<POLICYINFO_st>(),
        8usize,
        concat!("Alignment of ", stringify!(POLICYINFO_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).policyid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYINFO_st),
            "::",
            stringify!(policyid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qualifiers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICYINFO_st),
            "::",
            stringify!(qualifiers)
        )
    );
}
pub type POLICYINFO = POLICYINFO_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICYINFO {
    _unused: [u8; 0],
}
pub type CERTIFICATEPOLICIES = stack_st_POLICYINFO;
pub type sk_POLICYINFO_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut POLICYINFO)>;
pub type sk_POLICYINFO_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const POLICYINFO) -> *mut POLICYINFO>;
pub type sk_POLICYINFO_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const POLICYINFO,
        arg2: *const *const POLICYINFO,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_POLICYINFO_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut POLICYINFO,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POLICY_MAPPING_st {
    pub issuerDomainPolicy: *mut ASN1_OBJECT,
    pub subjectDomainPolicy: *mut ASN1_OBJECT,
}
#[test]
fn bindgen_test_layout_POLICY_MAPPING_st() {
    const UNINIT: ::std::mem::MaybeUninit<POLICY_MAPPING_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POLICY_MAPPING_st>(),
        16usize,
        concat!("Size of: ", stringify!(POLICY_MAPPING_st))
    );
    assert_eq!(
        ::std::mem::align_of::<POLICY_MAPPING_st>(),
        8usize,
        concat!("Alignment of ", stringify!(POLICY_MAPPING_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).issuerDomainPolicy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICY_MAPPING_st),
            "::",
            stringify!(issuerDomainPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subjectDomainPolicy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICY_MAPPING_st),
            "::",
            stringify!(subjectDomainPolicy)
        )
    );
}
pub type POLICY_MAPPING = POLICY_MAPPING_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_POLICY_MAPPING {
    _unused: [u8; 0],
}
pub type sk_POLICY_MAPPING_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut POLICY_MAPPING)>;
pub type sk_POLICY_MAPPING_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const POLICY_MAPPING) -> *mut POLICY_MAPPING>;
pub type sk_POLICY_MAPPING_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const POLICY_MAPPING,
        arg2: *const *const POLICY_MAPPING,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_POLICY_MAPPING_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut POLICY_MAPPING,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type POLICY_MAPPINGS = stack_st_POLICY_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GENERAL_SUBTREE_st {
    pub base: *mut GENERAL_NAME,
    pub minimum: *mut ASN1_INTEGER,
    pub maximum: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_GENERAL_SUBTREE_st() {
    const UNINIT: ::std::mem::MaybeUninit<GENERAL_SUBTREE_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GENERAL_SUBTREE_st>(),
        24usize,
        concat!("Size of: ", stringify!(GENERAL_SUBTREE_st))
    );
    assert_eq!(
        ::std::mem::align_of::<GENERAL_SUBTREE_st>(),
        8usize,
        concat!("Alignment of ", stringify!(GENERAL_SUBTREE_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_SUBTREE_st),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_SUBTREE_st),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GENERAL_SUBTREE_st),
            "::",
            stringify!(maximum)
        )
    );
}
pub type GENERAL_SUBTREE = GENERAL_SUBTREE_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_GENERAL_SUBTREE {
    _unused: [u8; 0],
}
pub type sk_GENERAL_SUBTREE_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GENERAL_SUBTREE)>;
pub type sk_GENERAL_SUBTREE_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const GENERAL_SUBTREE) -> *mut GENERAL_SUBTREE,
>;
pub type sk_GENERAL_SUBTREE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const GENERAL_SUBTREE,
        arg2: *const *const GENERAL_SUBTREE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_GENERAL_SUBTREE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GENERAL_SUBTREE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NAME_CONSTRAINTS_st {
    pub permittedSubtrees: *mut stack_st_GENERAL_SUBTREE,
    pub excludedSubtrees: *mut stack_st_GENERAL_SUBTREE,
}
#[test]
fn bindgen_test_layout_NAME_CONSTRAINTS_st() {
    const UNINIT: ::std::mem::MaybeUninit<NAME_CONSTRAINTS_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NAME_CONSTRAINTS_st>(),
        16usize,
        concat!("Size of: ", stringify!(NAME_CONSTRAINTS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<NAME_CONSTRAINTS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(NAME_CONSTRAINTS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).permittedSubtrees) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NAME_CONSTRAINTS_st),
            "::",
            stringify!(permittedSubtrees)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludedSubtrees) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NAME_CONSTRAINTS_st),
            "::",
            stringify!(excludedSubtrees)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POLICY_CONSTRAINTS_st {
    pub requireExplicitPolicy: *mut ASN1_INTEGER,
    pub inhibitPolicyMapping: *mut ASN1_INTEGER,
}
#[test]
fn bindgen_test_layout_POLICY_CONSTRAINTS_st() {
    const UNINIT: ::std::mem::MaybeUninit<POLICY_CONSTRAINTS_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POLICY_CONSTRAINTS_st>(),
        16usize,
        concat!("Size of: ", stringify!(POLICY_CONSTRAINTS_st))
    );
    assert_eq!(
        ::std::mem::align_of::<POLICY_CONSTRAINTS_st>(),
        8usize,
        concat!("Alignment of ", stringify!(POLICY_CONSTRAINTS_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requireExplicitPolicy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICY_CONSTRAINTS_st),
            "::",
            stringify!(requireExplicitPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inhibitPolicyMapping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POLICY_CONSTRAINTS_st),
            "::",
            stringify!(inhibitPolicyMapping)
        )
    );
}
pub type POLICY_CONSTRAINTS = POLICY_CONSTRAINTS_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISSUING_DIST_POINT_st {
    pub distpoint: *mut DIST_POINT_NAME,
    pub onlyuser: ASN1_BOOLEAN,
    pub onlyCA: ASN1_BOOLEAN,
    pub onlysomereasons: *mut ASN1_BIT_STRING,
    pub indirectCRL: ASN1_BOOLEAN,
    pub onlyattr: ASN1_BOOLEAN,
}
#[test]
fn bindgen_test_layout_ISSUING_DIST_POINT_st() {
    const UNINIT: ::std::mem::MaybeUninit<ISSUING_DIST_POINT_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ISSUING_DIST_POINT_st>(),
        32usize,
        concat!("Size of: ", stringify!(ISSUING_DIST_POINT_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ISSUING_DIST_POINT_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ISSUING_DIST_POINT_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distpoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ISSUING_DIST_POINT_st),
            "::",
            stringify!(distpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onlyuser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ISSUING_DIST_POINT_st),
            "::",
            stringify!(onlyuser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onlyCA) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ISSUING_DIST_POINT_st),
            "::",
            stringify!(onlyCA)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onlysomereasons) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ISSUING_DIST_POINT_st),
            "::",
            stringify!(onlysomereasons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indirectCRL) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ISSUING_DIST_POINT_st),
            "::",
            stringify!(indirectCRL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onlyattr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ISSUING_DIST_POINT_st),
            "::",
            stringify!(onlyattr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_purpose_st {
    pub purpose: ::std::os::raw::c_int,
    pub trust: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub check_purpose: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const x509_purpose_st,
            arg2: *const X509,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub name: *mut ::std::os::raw::c_char,
    pub sname: *mut ::std::os::raw::c_char,
    pub usr_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_x509_purpose_st() {
    const UNINIT: ::std::mem::MaybeUninit<x509_purpose_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<x509_purpose_st>(),
        48usize,
        concat!("Size of: ", stringify!(x509_purpose_st))
    );
    assert_eq!(
        ::std::mem::align_of::<x509_purpose_st>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_purpose_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).purpose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(purpose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trust) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(trust)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_purpose) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(check_purpose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(sname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_purpose_st),
            "::",
            stringify!(usr_data)
        )
    );
}
pub type X509_PURPOSE = x509_purpose_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509_PURPOSE {
    _unused: [u8; 0],
}
pub type sk_X509_PURPOSE_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut X509_PURPOSE)>;
pub type sk_X509_PURPOSE_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const X509_PURPOSE) -> *mut X509_PURPOSE>;
pub type sk_X509_PURPOSE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const X509_PURPOSE,
        arg2: *const *const X509_PURPOSE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_X509_PURPOSE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut X509_PURPOSE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn BASIC_CONSTRAINTS_new() -> *mut BASIC_CONSTRAINTS;
}
extern "C" {
    pub fn BASIC_CONSTRAINTS_free(a: *mut BASIC_CONSTRAINTS);
}
extern "C" {
    pub fn d2i_BASIC_CONSTRAINTS(
        a: *mut *mut BASIC_CONSTRAINTS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut BASIC_CONSTRAINTS;
}
extern "C" {
    pub fn i2d_BASIC_CONSTRAINTS(
        a: *const BASIC_CONSTRAINTS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static BASIC_CONSTRAINTS_it: ASN1_ITEM;
}
extern "C" {
    pub fn AUTHORITY_KEYID_new() -> *mut AUTHORITY_KEYID;
}
extern "C" {
    pub fn AUTHORITY_KEYID_free(a: *mut AUTHORITY_KEYID);
}
extern "C" {
    pub fn d2i_AUTHORITY_KEYID(
        a: *mut *mut AUTHORITY_KEYID,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut AUTHORITY_KEYID;
}
extern "C" {
    pub fn i2d_AUTHORITY_KEYID(
        a: *mut AUTHORITY_KEYID,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static AUTHORITY_KEYID_it: ASN1_ITEM;
}
extern "C" {
    pub fn EXTENDED_KEY_USAGE_new() -> *mut EXTENDED_KEY_USAGE;
}
extern "C" {
    pub fn EXTENDED_KEY_USAGE_free(a: *mut EXTENDED_KEY_USAGE);
}
extern "C" {
    pub fn d2i_EXTENDED_KEY_USAGE(
        a: *mut *mut EXTENDED_KEY_USAGE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut EXTENDED_KEY_USAGE;
}
extern "C" {
    pub fn i2d_EXTENDED_KEY_USAGE(
        a: *const EXTENDED_KEY_USAGE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static EXTENDED_KEY_USAGE_it: ASN1_ITEM;
}
extern "C" {
    pub fn CERTIFICATEPOLICIES_new() -> *mut CERTIFICATEPOLICIES;
}
extern "C" {
    pub fn CERTIFICATEPOLICIES_free(a: *mut CERTIFICATEPOLICIES);
}
extern "C" {
    pub fn d2i_CERTIFICATEPOLICIES(
        a: *mut *mut CERTIFICATEPOLICIES,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut CERTIFICATEPOLICIES;
}
extern "C" {
    pub fn i2d_CERTIFICATEPOLICIES(
        a: *const CERTIFICATEPOLICIES,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static CERTIFICATEPOLICIES_it: ASN1_ITEM;
}
extern "C" {
    pub fn POLICYINFO_new() -> *mut POLICYINFO;
}
extern "C" {
    pub fn POLICYINFO_free(a: *mut POLICYINFO);
}
extern "C" {
    pub fn d2i_POLICYINFO(
        a: *mut *mut POLICYINFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut POLICYINFO;
}
extern "C" {
    pub fn i2d_POLICYINFO(
        a: *const POLICYINFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static POLICYINFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn POLICYQUALINFO_new() -> *mut POLICYQUALINFO;
}
extern "C" {
    pub fn POLICYQUALINFO_free(a: *mut POLICYQUALINFO);
}
extern "C" {
    pub fn d2i_POLICYQUALINFO(
        a: *mut *mut POLICYQUALINFO,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut POLICYQUALINFO;
}
extern "C" {
    pub fn i2d_POLICYQUALINFO(
        a: *const POLICYQUALINFO,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static POLICYQUALINFO_it: ASN1_ITEM;
}
extern "C" {
    pub fn USERNOTICE_new() -> *mut USERNOTICE;
}
extern "C" {
    pub fn USERNOTICE_free(a: *mut USERNOTICE);
}
extern "C" {
    pub fn d2i_USERNOTICE(
        a: *mut *mut USERNOTICE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut USERNOTICE;
}
extern "C" {
    pub fn i2d_USERNOTICE(
        a: *const USERNOTICE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static USERNOTICE_it: ASN1_ITEM;
}
extern "C" {
    pub fn NOTICEREF_new() -> *mut NOTICEREF;
}
extern "C" {
    pub fn NOTICEREF_free(a: *mut NOTICEREF);
}
extern "C" {
    pub fn d2i_NOTICEREF(
        a: *mut *mut NOTICEREF,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut NOTICEREF;
}
extern "C" {
    pub fn i2d_NOTICEREF(
        a: *const NOTICEREF,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static NOTICEREF_it: ASN1_ITEM;
}
extern "C" {
    pub fn CRL_DIST_POINTS_new() -> *mut CRL_DIST_POINTS;
}
extern "C" {
    pub fn CRL_DIST_POINTS_free(a: *mut CRL_DIST_POINTS);
}
extern "C" {
    pub fn d2i_CRL_DIST_POINTS(
        a: *mut *mut CRL_DIST_POINTS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut CRL_DIST_POINTS;
}
extern "C" {
    pub fn i2d_CRL_DIST_POINTS(
        a: *mut CRL_DIST_POINTS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static CRL_DIST_POINTS_it: ASN1_ITEM;
}
extern "C" {
    pub fn DIST_POINT_new() -> *mut DIST_POINT;
}
extern "C" {
    pub fn DIST_POINT_free(a: *mut DIST_POINT);
}
extern "C" {
    pub fn d2i_DIST_POINT(
        a: *mut *mut DIST_POINT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut DIST_POINT;
}
extern "C" {
    pub fn i2d_DIST_POINT(
        a: *mut DIST_POINT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DIST_POINT_it: ASN1_ITEM;
}
extern "C" {
    pub fn DIST_POINT_NAME_new() -> *mut DIST_POINT_NAME;
}
extern "C" {
    pub fn DIST_POINT_NAME_free(a: *mut DIST_POINT_NAME);
}
extern "C" {
    pub fn d2i_DIST_POINT_NAME(
        a: *mut *mut DIST_POINT_NAME,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut DIST_POINT_NAME;
}
extern "C" {
    pub fn i2d_DIST_POINT_NAME(
        a: *mut DIST_POINT_NAME,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static DIST_POINT_NAME_it: ASN1_ITEM;
}
extern "C" {
    pub fn ISSUING_DIST_POINT_new() -> *mut ISSUING_DIST_POINT;
}
extern "C" {
    pub fn ISSUING_DIST_POINT_free(a: *mut ISSUING_DIST_POINT);
}
extern "C" {
    pub fn d2i_ISSUING_DIST_POINT(
        a: *mut *mut ISSUING_DIST_POINT,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ISSUING_DIST_POINT;
}
extern "C" {
    pub fn i2d_ISSUING_DIST_POINT(
        a: *mut ISSUING_DIST_POINT,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ISSUING_DIST_POINT_it: ASN1_ITEM;
}
extern "C" {
    pub fn DIST_POINT_set_dpname(
        dpn: *mut DIST_POINT_NAME,
        iname: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ACCESS_DESCRIPTION_new() -> *mut ACCESS_DESCRIPTION;
}
extern "C" {
    pub fn ACCESS_DESCRIPTION_free(a: *mut ACCESS_DESCRIPTION);
}
extern "C" {
    pub fn d2i_ACCESS_DESCRIPTION(
        a: *mut *mut ACCESS_DESCRIPTION,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut ACCESS_DESCRIPTION;
}
extern "C" {
    pub fn i2d_ACCESS_DESCRIPTION(
        a: *mut ACCESS_DESCRIPTION,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ACCESS_DESCRIPTION_it: ASN1_ITEM;
}
extern "C" {
    pub fn AUTHORITY_INFO_ACCESS_new() -> *mut AUTHORITY_INFO_ACCESS;
}
extern "C" {
    pub fn AUTHORITY_INFO_ACCESS_free(a: *mut AUTHORITY_INFO_ACCESS);
}
extern "C" {
    pub fn d2i_AUTHORITY_INFO_ACCESS(
        a: *mut *mut AUTHORITY_INFO_ACCESS,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut AUTHORITY_INFO_ACCESS;
}
extern "C" {
    pub fn i2d_AUTHORITY_INFO_ACCESS(
        a: *mut AUTHORITY_INFO_ACCESS,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static AUTHORITY_INFO_ACCESS_it: ASN1_ITEM;
}
extern "C" {
    pub static POLICY_MAPPING_it: ASN1_ITEM;
}
extern "C" {
    pub fn POLICY_MAPPING_new() -> *mut POLICY_MAPPING;
}
extern "C" {
    pub fn POLICY_MAPPING_free(a: *mut POLICY_MAPPING);
}
extern "C" {
    pub static POLICY_MAPPINGS_it: ASN1_ITEM;
}
extern "C" {
    pub static GENERAL_SUBTREE_it: ASN1_ITEM;
}
extern "C" {
    pub fn GENERAL_SUBTREE_new() -> *mut GENERAL_SUBTREE;
}
extern "C" {
    pub fn GENERAL_SUBTREE_free(a: *mut GENERAL_SUBTREE);
}
extern "C" {
    pub static NAME_CONSTRAINTS_it: ASN1_ITEM;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_new() -> *mut NAME_CONSTRAINTS;
}
extern "C" {
    pub fn NAME_CONSTRAINTS_free(a: *mut NAME_CONSTRAINTS);
}
extern "C" {
    pub fn POLICY_CONSTRAINTS_new() -> *mut POLICY_CONSTRAINTS;
}
extern "C" {
    pub fn POLICY_CONSTRAINTS_free(a: *mut POLICY_CONSTRAINTS);
}
extern "C" {
    pub static POLICY_CONSTRAINTS_it: ASN1_ITEM;
}
extern "C" {
    pub fn X509V3_EXT_add(ext: *mut X509V3_EXT_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_add_list(extlist: *mut X509V3_EXT_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_add_alias(
        nid_to: ::std::os::raw::c_int,
        nid_from: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_cleanup();
}
extern "C" {
    pub fn X509V3_EXT_get(ext: *const X509_EXTENSION) -> *const X509V3_EXT_METHOD;
}
extern "C" {
    pub fn X509V3_EXT_get_nid(nid: ::std::os::raw::c_int) -> *const X509V3_EXT_METHOD;
}
extern "C" {
    pub fn X509V3_EXT_d2i(ext: *const X509_EXTENSION) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509V3_get_d2i(
        extensions: *const stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        out_critical: *mut ::std::os::raw::c_int,
        out_idx: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn X509V3_EXT_free(
        nid: ::std::os::raw::c_int,
        ext_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509V3_EXT_i2d(
        ext_nid: ::std::os::raw::c_int,
        crit: ::std::os::raw::c_int,
        ext_struc: *mut ::std::os::raw::c_void,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn X509V3_add1_i2d(
        x: *mut *mut stack_st_X509_EXTENSION,
        nid: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_void,
        crit: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_check_purpose(
        x: *mut X509,
        id: ::std::os::raw::c_int,
        ca: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_set(
        p: *mut ::std::os::raw::c_int,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get0(idx: ::std::os::raw::c_int) -> *const X509_PURPOSE;
}
extern "C" {
    pub fn X509_PURPOSE_get_by_sname(sname: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get_by_id(id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get0_name(xp: *const X509_PURPOSE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_PURPOSE_get0_sname(xp: *const X509_PURPOSE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn X509_PURPOSE_get_trust(xp: *const X509_PURPOSE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn X509_PURPOSE_get_id(arg1: *const X509_PURPOSE) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_cert_id_st {
    _unused: [u8; 0],
}
pub type OCSP_CERTID = ocsp_cert_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_one_request_st {
    _unused: [u8; 0],
}
pub type OCSP_ONEREQ = ocsp_one_request_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_req_info_st {
    _unused: [u8; 0],
}
pub type OCSP_REQINFO = ocsp_req_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_signature_st {
    _unused: [u8; 0],
}
pub type OCSP_SIGNATURE = ocsp_signature_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_request_st {
    _unused: [u8; 0],
}
pub type OCSP_REQUEST = ocsp_request_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_resp_bytes_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPBYTES = ocsp_resp_bytes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_revoked_info_st {
    _unused: [u8; 0],
}
pub type OCSP_REVOKEDINFO = ocsp_revoked_info_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_cert_status_st {
    _unused: [u8; 0],
}
pub type OCSP_CERTSTATUS = ocsp_cert_status_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_single_response_st {
    _unused: [u8; 0],
}
pub type OCSP_SINGLERESP = ocsp_single_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_data_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPDATA = ocsp_response_data_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_response_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPONSE = ocsp_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_responder_id_st {
    _unused: [u8; 0],
}
pub type OCSP_RESPID = ocsp_responder_id_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ocsp_basic_response_st {
    _unused: [u8; 0],
}
pub type OCSP_BASICRESP = ocsp_basic_response_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_CERTID {
    _unused: [u8; 0],
}
pub type sk_OCSP_CERTID_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut OCSP_CERTID)>;
pub type sk_OCSP_CERTID_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const OCSP_CERTID) -> *mut OCSP_CERTID>;
pub type sk_OCSP_CERTID_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const OCSP_CERTID,
        arg2: *const *const OCSP_CERTID,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OCSP_CERTID_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut OCSP_CERTID,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_ONEREQ {
    _unused: [u8; 0],
}
pub type sk_OCSP_ONEREQ_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut OCSP_ONEREQ)>;
pub type sk_OCSP_ONEREQ_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const OCSP_ONEREQ) -> *mut OCSP_ONEREQ>;
pub type sk_OCSP_ONEREQ_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const OCSP_ONEREQ,
        arg2: *const *const OCSP_ONEREQ,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OCSP_ONEREQ_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut OCSP_ONEREQ,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_RESPID {
    _unused: [u8; 0],
}
pub type sk_OCSP_RESPID_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut OCSP_RESPID)>;
pub type sk_OCSP_RESPID_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const OCSP_RESPID) -> *mut OCSP_RESPID>;
pub type sk_OCSP_RESPID_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const OCSP_RESPID,
        arg2: *const *const OCSP_RESPID,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OCSP_RESPID_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut OCSP_RESPID,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_OCSP_SINGLERESP {
    _unused: [u8; 0],
}
pub type sk_OCSP_SINGLERESP_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut OCSP_SINGLERESP)>;
pub type sk_OCSP_SINGLERESP_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const OCSP_SINGLERESP) -> *mut OCSP_SINGLERESP,
>;
pub type sk_OCSP_SINGLERESP_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const OCSP_SINGLERESP,
        arg2: *const *const OCSP_SINGLERESP,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_OCSP_SINGLERESP_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut OCSP_SINGLERESP,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn OCSP_BASICRESP_new() -> *mut OCSP_BASICRESP;
}
extern "C" {
    pub fn OCSP_BASICRESP_free(a: *mut OCSP_BASICRESP);
}
extern "C" {
    pub fn d2i_OCSP_BASICRESP(
        a: *mut *mut OCSP_BASICRESP,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut OCSP_BASICRESP;
}
extern "C" {
    pub fn i2d_OCSP_BASICRESP(
        a: *mut OCSP_BASICRESP,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static OCSP_BASICRESP_it: ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_RESPONSE_new() -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn OCSP_RESPONSE_free(a: *mut OCSP_RESPONSE);
}
extern "C" {
    pub fn d2i_OCSP_RESPONSE(
        a: *mut *mut OCSP_RESPONSE,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn i2d_OCSP_RESPONSE(
        a: *mut OCSP_RESPONSE,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static OCSP_RESPONSE_it: ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_CERTID_new() -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_CERTID_free(a: *mut OCSP_CERTID);
}
extern "C" {
    pub fn d2i_OCSP_CERTID(
        a: *mut *mut OCSP_CERTID,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn i2d_OCSP_CERTID(
        a: *mut OCSP_CERTID,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static OCSP_CERTID_it: ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_REQUEST_new() -> *mut OCSP_REQUEST;
}
extern "C" {
    pub fn OCSP_REQUEST_free(a: *mut OCSP_REQUEST);
}
extern "C" {
    pub fn d2i_OCSP_REQUEST(
        a: *mut *mut OCSP_REQUEST,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut OCSP_REQUEST;
}
extern "C" {
    pub fn i2d_OCSP_REQUEST(
        a: *mut OCSP_REQUEST,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static OCSP_REQUEST_it: ASN1_ITEM;
}
extern "C" {
    pub fn OCSP_SINGLERESP_new() -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn OCSP_SINGLERESP_free(a: *mut OCSP_SINGLERESP);
}
extern "C" {
    pub fn d2i_OCSP_SINGLERESP(
        a: *mut *mut OCSP_SINGLERESP,
        in_: *mut *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn i2d_OCSP_SINGLERESP(
        a: *mut OCSP_SINGLERESP,
        out: *mut *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static OCSP_SINGLERESP_it: ASN1_ITEM;
}
extern "C" {
    pub fn d2i_OCSP_REQUEST_bio(bp: *mut BIO, preq: *mut *mut OCSP_REQUEST) -> *mut OCSP_REQUEST;
}
extern "C" {
    pub fn d2i_OCSP_RESPONSE_bio(
        bp: *mut BIO,
        presp: *mut *mut OCSP_RESPONSE,
    ) -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn i2d_OCSP_RESPONSE_bio(bp: *mut BIO, presp: *mut OCSP_RESPONSE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_OCSP_REQUEST_bio(bp: *mut BIO, preq: *mut OCSP_REQUEST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_CERTID_dup(id: *mut OCSP_CERTID) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_sendreq_bio(
        b: *mut BIO,
        path: *const ::std::os::raw::c_char,
        req: *mut OCSP_REQUEST,
    ) -> *mut OCSP_RESPONSE;
}
extern "C" {
    pub fn OCSP_sendreq_new(
        io: *mut BIO,
        path: *const ::std::os::raw::c_char,
        req: *mut OCSP_REQUEST,
        maxline: ::std::os::raw::c_int,
    ) -> *mut OCSP_REQ_CTX;
}
extern "C" {
    pub fn OCSP_sendreq_nbio(
        presp: *mut *mut OCSP_RESPONSE,
        rctx: *mut OCSP_REQ_CTX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_REQ_CTX_new(io: *mut BIO, maxline: ::std::os::raw::c_int) -> *mut OCSP_REQ_CTX;
}
extern "C" {
    pub fn OCSP_REQ_CTX_free(rctx: *mut OCSP_REQ_CTX);
}
extern "C" {
    pub fn OCSP_set_max_response_length(rctx: *mut OCSP_REQ_CTX, len: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn OCSP_REQ_CTX_http(
        rctx: *mut OCSP_REQ_CTX,
        op: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_REQ_CTX_set1_req(
        rctx: *mut OCSP_REQ_CTX,
        req: *mut OCSP_REQUEST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_REQ_CTX_add1_header(
        rctx: *mut OCSP_REQ_CTX,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_REQ_CTX_i2d(
        rctx: *mut OCSP_REQ_CTX,
        it: *const ASN1_ITEM,
        val: *mut ASN1_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_request_add0_id(req: *mut OCSP_REQUEST, cid: *mut OCSP_CERTID) -> *mut OCSP_ONEREQ;
}
extern "C" {
    pub fn OCSP_onereq_get0_id(one: *mut OCSP_ONEREQ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_request_add1_nonce(
        req: *mut OCSP_REQUEST,
        val: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_check_nonce(
        req: *mut OCSP_REQUEST,
        bs: *mut OCSP_BASICRESP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_request_set1_name(
        req: *mut OCSP_REQUEST,
        nm: *mut X509_NAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_request_add1_cert(req: *mut OCSP_REQUEST, cert: *mut X509)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_request_is_signed(req: *mut OCSP_REQUEST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_request_onereq_count(req: *mut OCSP_REQUEST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_request_onereq_get0(
        req: *mut OCSP_REQUEST,
        i: ::std::os::raw::c_int,
    ) -> *mut OCSP_ONEREQ;
}
extern "C" {
    pub fn OCSP_request_sign(
        req: *mut OCSP_REQUEST,
        signer: *mut X509,
        key: *mut EVP_PKEY,
        dgst: *const EVP_MD,
        certs: *mut stack_st_X509,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_response_status(resp: *mut OCSP_RESPONSE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_response_get1_basic(resp: *mut OCSP_RESPONSE) -> *mut OCSP_BASICRESP;
}
extern "C" {
    pub fn OCSP_resp_count(bs: *mut OCSP_BASICRESP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_resp_get0(bs: *mut OCSP_BASICRESP, idx: usize) -> *mut OCSP_SINGLERESP;
}
extern "C" {
    pub fn OCSP_single_get0_status(
        single: *mut OCSP_SINGLERESP,
        reason: *mut ::std::os::raw::c_int,
        revtime: *mut *mut ASN1_GENERALIZEDTIME,
        thisupd: *mut *mut ASN1_GENERALIZEDTIME,
        nextupd: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_resp_find(
        bs: *mut OCSP_BASICRESP,
        id: *mut OCSP_CERTID,
        last: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_resp_find_status(
        bs: *mut OCSP_BASICRESP,
        id: *mut OCSP_CERTID,
        status: *mut ::std::os::raw::c_int,
        reason: *mut ::std::os::raw::c_int,
        revtime: *mut *mut ASN1_GENERALIZEDTIME,
        thisupd: *mut *mut ASN1_GENERALIZEDTIME,
        nextupd: *mut *mut ASN1_GENERALIZEDTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_check_validity(
        thisUpdate: *mut ASN1_GENERALIZEDTIME,
        nextUpdate: *mut ASN1_GENERALIZEDTIME,
        drift_num_seconds: ::std::os::raw::c_long,
        max_age_seconds: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_basic_verify(
        bs: *mut OCSP_BASICRESP,
        certs: *mut stack_st_X509,
        st: *mut X509_STORE,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_cert_id_new(
        dgst: *const EVP_MD,
        issuerName: *const X509_NAME,
        issuerKey: *const ASN1_BIT_STRING,
        serialNumber: *const ASN1_INTEGER,
    ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_cert_to_id(
        dgst: *const EVP_MD,
        subject: *const X509,
        issuer: *const X509,
    ) -> *mut OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_parse_url(
        url: *const ::std::os::raw::c_char,
        phost: *mut *mut ::std::os::raw::c_char,
        pport: *mut *mut ::std::os::raw::c_char,
        ppath: *mut *mut ::std::os::raw::c_char,
        pssl: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_id_issuer_cmp(
        a: *const OCSP_CERTID,
        b: *const OCSP_CERTID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_id_cmp(a: *const OCSP_CERTID, b: *const OCSP_CERTID) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_id_get0_info(
        nameHash: *mut *mut ASN1_OCTET_STRING,
        algor: *mut *mut ASN1_OBJECT,
        keyHash: *mut *mut ASN1_OCTET_STRING,
        serial: *mut *mut ASN1_INTEGER,
        cid: *mut OCSP_CERTID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_basic_add1_cert(
        resp: *mut OCSP_BASICRESP,
        cert: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get0_id(x: *const OCSP_SINGLERESP) -> *const OCSP_CERTID;
}
extern "C" {
    pub fn OCSP_response_status_str(
        status_code: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OCSP_cert_status_str(
        status_code: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OCSP_crl_reason_str(
        status_code: ::std::os::raw::c_long,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn OCSP_REQUEST_print(
        bp: *mut BIO,
        req: *mut OCSP_REQUEST,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_RESPONSE_print(
        bp: *mut BIO,
        resp: *mut OCSP_RESPONSE,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext_by_NID(
        bs: *mut OCSP_BASICRESP,
        nid: ::std::os::raw::c_int,
        lastpos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_BASICRESP_get_ext(
        bs: *mut OCSP_BASICRESP,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
extern "C" {
    pub fn OCSP_SINGLERESP_add_ext(
        sresp: *mut OCSP_SINGLERESP,
        ex: *mut X509_EXTENSION,
        loc: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext_count(sresp: *mut OCSP_SINGLERESP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OCSP_SINGLERESP_get_ext(
        sresp: *mut OCSP_SINGLERESP,
        loc: ::std::os::raw::c_int,
    ) -> *mut X509_EXTENSION;
}
pub type pem_password_cb = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        rwflag: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn PEM_get_EVP_CIPHER_INFO(
        header: *mut ::std::os::raw::c_char,
        cipher: *mut EVP_CIPHER_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_do_header(
        cipher: *mut EVP_CIPHER_INFO,
        data: *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
        callback: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio(
        bp: *mut BIO,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio(
        bp: *mut BIO,
        name: *const ::std::os::raw::c_char,
        hdr: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_bytes_read_bio(
        pdata: *mut *mut ::std::os::raw::c_uchar,
        plen: *mut ::std::os::raw::c_long,
        pnm: *mut *mut ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read_bio(
        d2i: d2i_of_void,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        x: *mut *mut ::std::os::raw::c_void,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write_bio(
        i2d: i2d_of_void,
        name: *const ::std::os::raw::c_char,
        bp: *mut BIO,
        x: *mut ::std::os::raw::c_void,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_X509_INFO_read_bio(
        bp: *mut BIO,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_X509_INFO_read(
        fp: *mut FILE,
        sk: *mut stack_st_X509_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut stack_st_X509_INFO;
}
extern "C" {
    pub fn PEM_read(
        fp: *mut FILE,
        name: *mut *mut ::std::os::raw::c_char,
        header: *mut *mut ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_uchar,
        len: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        hdr: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_ASN1_read(
        d2i: d2i_of_void,
        name: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        x: *mut *mut ::std::os::raw::c_void,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn PEM_ASN1_write(
        i2d: i2d_of_void,
        name: *const ::std::os::raw::c_char,
        fp: *mut FILE,
        x: *mut ::std::os::raw::c_void,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        callback: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_def_callback(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        rwflag: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509(
        bp: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509(
        fp: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_AUX(
        bp: *mut BIO,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_read_X509_AUX(
        fp: *mut FILE,
        x: *mut *mut X509,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509;
}
extern "C" {
    pub fn PEM_write_bio_X509_AUX(bp: *mut BIO, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_AUX(fp: *mut FILE, x: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_REQ(
        bp: *mut BIO,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_read_X509_REQ(
        fp: *mut FILE,
        x: *mut *mut X509_REQ,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_REQ;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ(bp: *mut BIO, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ(fp: *mut FILE, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_X509_REQ_NEW(bp: *mut BIO, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_REQ_NEW(fp: *mut FILE, x: *mut X509_REQ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_X509_CRL(
        bp: *mut BIO,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_read_X509_CRL(
        fp: *mut FILE,
        x: *mut *mut X509_CRL,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_CRL;
}
extern "C" {
    pub fn PEM_write_bio_X509_CRL(bp: *mut BIO, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_X509_CRL(fp: *mut FILE, x: *mut X509_CRL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS7(
        bp: *mut BIO,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_read_PKCS7(
        fp: *mut FILE,
        x: *mut *mut PKCS7,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS7;
}
extern "C" {
    pub fn PEM_write_bio_PKCS7(bp: *mut BIO, x: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS7(fp: *mut FILE, x: *mut PKCS7) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8(
        bp: *mut BIO,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_read_PKCS8(
        fp: *mut FILE,
        x: *mut *mut X509_SIG,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8(bp: *mut BIO, x: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8(fp: *mut FILE, x: *mut X509_SIG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PKCS8_PRIV_KEY_INFO(
        bp: *mut BIO,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_read_PKCS8_PRIV_KEY_INFO(
        fp: *mut FILE,
        x: *mut *mut PKCS8_PRIV_KEY_INFO,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8_PRIV_KEY_INFO(
        bp: *mut BIO,
        x: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8_PRIV_KEY_INFO(
        fp: *mut FILE,
        x: *mut PKCS8_PRIV_KEY_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPrivateKey(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPrivateKey(
        bp: *mut BIO,
        x: *mut RSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPrivateKey(
        fp: *mut FILE,
        x: *mut RSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSAPublicKey(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSAPublicKey(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSAPublicKey(bp: *mut BIO, x: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSAPublicKey(fp: *mut FILE, x: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_RSA_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_read_RSA_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut RSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut RSA;
}
extern "C" {
    pub fn PEM_write_bio_RSA_PUBKEY(bp: *mut BIO, x: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_RSA_PUBKEY(fp: *mut FILE, x: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAPrivateKey(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAPrivateKey(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAPrivateKey(
        bp: *mut BIO,
        x: *mut DSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSAPrivateKey(
        fp: *mut FILE,
        x: *mut DSA,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSA_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSA_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSA_PUBKEY(bp: *mut BIO, x: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSA_PUBKEY(fp: *mut FILE, x: *mut DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DSAparams(
        bp: *mut BIO,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_read_DSAparams(
        fp: *mut FILE,
        x: *mut *mut DSA,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DSA;
}
extern "C" {
    pub fn PEM_write_bio_DSAparams(bp: *mut BIO, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DSAparams(fp: *mut FILE, x: *const DSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPrivateKey(
        bp: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_ECPrivateKey(
        fp: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_ECPrivateKey(
        bp: *mut BIO,
        x: *mut EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_ECPrivateKey(
        fp: *mut FILE,
        x: *mut EC_KEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_EC_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_read_EC_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut EC_KEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_KEY;
}
extern "C" {
    pub fn PEM_write_bio_EC_PUBKEY(bp: *mut BIO, x: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_EC_PUBKEY(fp: *mut FILE, x: *mut EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_DHparams(
        bp: *mut BIO,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_read_DHparams(
        fp: *mut FILE,
        x: *mut *mut DH,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut DH;
}
extern "C" {
    pub fn PEM_write_bio_DHparams(bp: *mut BIO, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_DHparams(fp: *mut FILE, x: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PrivateKey(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PrivateKey(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PrivateKey(
        bp: *mut BIO,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PrivateKey(
        fp: *mut FILE,
        x: *mut EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_uchar,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_PUBKEY(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_read_PUBKEY(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_bio_PUBKEY(bp: *mut BIO, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PUBKEY(fp: *mut FILE, x: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey_nid(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_bio_PKCS8PrivateKey(
        arg1: *mut BIO,
        arg2: *const EVP_PKEY,
        arg3: *const EVP_CIPHER,
        arg4: *mut ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
        arg6: pem_password_cb,
        arg7: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_bio(
        bp: *mut BIO,
        x: *const EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_bio(
        bp: *mut BIO,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS8PrivateKey_nid_fp(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey_nid(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        nid: ::std::os::raw::c_int,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_PKCS8PrivateKey_fp(
        fp: *mut FILE,
        x: *mut *mut EVP_PKEY,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PEM_write_PKCS8PrivateKey(
        fp: *mut FILE,
        x: *const EVP_PKEY,
        enc: *const EVP_CIPHER,
        kstr: *mut ::std::os::raw::c_char,
        klen: ::std::os::raw::c_int,
        cd: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_ECPKParameters(
        bio: *mut BIO,
        out_group: *mut *mut EC_GROUP,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut EC_GROUP;
}
extern "C" {
    pub fn PEM_write_bio_ECPKParameters(
        out: *mut BIO,
        group: *const EC_GROUP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS8_encrypt(
        pbe_nid: ::std::os::raw::c_int,
        cipher: *const EVP_CIPHER,
        pass: *const ::std::os::raw::c_char,
        pass_len: ::std::os::raw::c_int,
        salt: *const u8,
        salt_len: usize,
        iterations: ::std::os::raw::c_int,
        p8inf: *mut PKCS8_PRIV_KEY_INFO,
    ) -> *mut X509_SIG;
}
extern "C" {
    pub fn PKCS8_marshal_encrypted_private_key(
        out: *mut CBB,
        pbe_nid: ::std::os::raw::c_int,
        cipher: *const EVP_CIPHER,
        pass: *const ::std::os::raw::c_char,
        pass_len: usize,
        salt: *const u8,
        salt_len: usize,
        iterations: ::std::os::raw::c_int,
        pkey: *const EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS8_decrypt(
        pkcs8: *mut X509_SIG,
        pass: *const ::std::os::raw::c_char,
        pass_len: ::std::os::raw::c_int,
    ) -> *mut PKCS8_PRIV_KEY_INFO;
}
extern "C" {
    pub fn PKCS8_parse_encrypted_private_key(
        cbs: *mut CBS,
        pass: *const ::std::os::raw::c_char,
        pass_len: usize,
    ) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn PKCS12_get_key_and_certs(
        out_key: *mut *mut EVP_PKEY,
        out_certs: *mut stack_st_X509,
        in_: *mut CBS,
        password: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS12_PBE_add();
}
extern "C" {
    pub fn d2i_PKCS12(
        out_p12: *mut *mut PKCS12,
        ber_bytes: *mut *const u8,
        ber_len: usize,
    ) -> *mut PKCS12;
}
extern "C" {
    pub fn d2i_PKCS12_bio(bio: *mut BIO, out_p12: *mut *mut PKCS12) -> *mut PKCS12;
}
extern "C" {
    pub fn d2i_PKCS12_fp(fp: *mut FILE, out_p12: *mut *mut PKCS12) -> *mut PKCS12;
}
extern "C" {
    pub fn i2d_PKCS12(p12: *const PKCS12, out: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS12_bio(bio: *mut BIO, p12: *const PKCS12) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_PKCS12_fp(fp: *mut FILE, p12: *const PKCS12) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS12_parse(
        p12: *const PKCS12,
        password: *const ::std::os::raw::c_char,
        out_pkey: *mut *mut EVP_PKEY,
        out_cert: *mut *mut X509,
        out_ca_certs: *mut *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS12_verify_mac(
        p12: *const PKCS12,
        password: *const ::std::os::raw::c_char,
        password_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PKCS12_create(
        password: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pkey: *const EVP_PKEY,
        cert: *mut X509,
        chain: *const stack_st_X509,
        key_nid: ::std::os::raw::c_int,
        cert_nid: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
        mac_iterations: ::std::os::raw::c_int,
        key_type: ::std::os::raw::c_int,
    ) -> *mut PKCS12;
}
extern "C" {
    pub fn PKCS12_new() -> *mut PKCS12;
}
extern "C" {
    pub fn PKCS12_free(p12: *mut PKCS12);
}
pub type poly1305_state = [u8; 512usize];
extern "C" {
    pub fn CRYPTO_poly1305_init(state: *mut poly1305_state, key: *const u8);
}
extern "C" {
    pub fn CRYPTO_poly1305_update(state: *mut poly1305_state, in_: *const u8, in_len: usize);
}
extern "C" {
    pub fn CRYPTO_poly1305_finish(state: *mut poly1305_state, mac: *mut u8);
}
extern "C" {
    pub fn RAND_bytes(buf: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_priv_bytes(buf: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_enable_fork_unsafe_buffering(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RAND_get_system_entropy_for_custom_prng(buf: *mut u8, len: usize);
}
extern "C" {
    pub fn RAND_pseudo_bytes(buf: *mut u8, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_seed(buf: *const ::std::os::raw::c_void, num: ::std::os::raw::c_int);
}
extern "C" {
    pub fn RAND_load_file(
        path: *const ::std::os::raw::c_char,
        num: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_write_file(file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_file_name(
        buf: *mut ::std::os::raw::c_char,
        num: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn RAND_add(buf: *const ::std::os::raw::c_void, num: ::std::os::raw::c_int, entropy: f64);
}
extern "C" {
    pub fn RAND_egd(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_poll() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_status() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_cleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rand_meth_st {
    pub seed: ::std::option::Option<
        unsafe extern "C" fn(buf: *const ::std::os::raw::c_void, num: ::std::os::raw::c_int),
    >,
    pub bytes: ::std::option::Option<
        unsafe extern "C" fn(buf: *mut u8, num: usize) -> ::std::os::raw::c_int,
    >,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn()>,
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            buf: *const ::std::os::raw::c_void,
            num: ::std::os::raw::c_int,
            entropy: f64,
        ),
    >,
    pub pseudorand: ::std::option::Option<
        unsafe extern "C" fn(buf: *mut u8, num: usize) -> ::std::os::raw::c_int,
    >,
    pub status: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_rand_meth_st() {
    const UNINIT: ::std::mem::MaybeUninit<rand_meth_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rand_meth_st>(),
        48usize,
        concat!("Size of: ", stringify!(rand_meth_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rand_meth_st>(),
        8usize,
        concat!("Alignment of ", stringify!(rand_meth_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_meth_st),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_meth_st),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_meth_st),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_meth_st),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudorand) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_meth_st),
            "::",
            stringify!(pseudorand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_meth_st),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn RAND_SSLeay() -> *mut RAND_METHOD;
}
extern "C" {
    pub fn RAND_OpenSSL() -> *mut RAND_METHOD;
}
extern "C" {
    pub fn RAND_get_rand_method() -> *const RAND_METHOD;
}
extern "C" {
    pub fn RAND_set_rand_method(arg1: *const RAND_METHOD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RAND_keep_random_devices_open(a: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc4_key_st {
    pub x: u32,
    pub y: u32,
    pub data: [u32; 256usize],
}
#[test]
fn bindgen_test_layout_rc4_key_st() {
    const UNINIT: ::std::mem::MaybeUninit<rc4_key_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rc4_key_st>(),
        1032usize,
        concat!("Size of: ", stringify!(rc4_key_st))
    );
    assert_eq!(
        ::std::mem::align_of::<rc4_key_st>(),
        4usize,
        concat!("Alignment of ", stringify!(rc4_key_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc4_key_st),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rc4_key_st),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc4_key_st),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn RC4_set_key(rc4key: *mut RC4_KEY, len: ::std::os::raw::c_uint, key: *const u8);
}
extern "C" {
    pub fn RC4(key: *mut RC4_KEY, len: usize, in_: *const u8, out: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RIPEMD160state_st {
    pub h: [u32; 5usize],
    pub Nl: u32,
    pub Nh: u32,
    pub data: [u8; 64usize],
    pub num: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_RIPEMD160state_st() {
    const UNINIT: ::std::mem::MaybeUninit<RIPEMD160state_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RIPEMD160state_st>(),
        96usize,
        concat!("Size of: ", stringify!(RIPEMD160state_st))
    );
    assert_eq!(
        ::std::mem::align_of::<RIPEMD160state_st>(),
        4usize,
        concat!("Alignment of ", stringify!(RIPEMD160state_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RIPEMD160state_st),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nl) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RIPEMD160state_st),
            "::",
            stringify!(Nl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RIPEMD160state_st),
            "::",
            stringify!(Nh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RIPEMD160state_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RIPEMD160state_st),
            "::",
            stringify!(num)
        )
    );
}
extern "C" {
    pub fn RIPEMD160_Init(ctx: *mut RIPEMD160_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RIPEMD160_Update(
        ctx: *mut RIPEMD160_CTX,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RIPEMD160_Final(out: *mut u8, ctx: *mut RIPEMD160_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RIPEMD160(data: *const u8, len: usize, out: *mut u8) -> *mut u8;
}
extern "C" {
    pub fn FIPS_service_indicator_before_call() -> u64;
}
extern "C" {
    pub fn FIPS_service_indicator_after_call() -> u64;
}
extern "C" {
    pub fn awslc_version_string() -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FIPSStatus {
    AWSLC_NOT_APPROVED = 0,
    AWSLC_APPROVED = 1,
}
extern "C" {
    pub fn SIPHASH_24(key: *const u64, input: *const u8, input_len: usize) -> u64;
}
extern "C" {
    pub fn SSHKDF(
        evp_md: *const EVP_MD,
        key: *const u8,
        key_len: usize,
        xcghash: *const u8,
        xcghash_len: usize,
        session_id: *const u8,
        session_id_len: usize,
        type_: ::std::os::raw::c_char,
        out: *mut u8,
        out_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct static_assertion_at_line_255_error_is_max_overheads_are_inconsistent {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_static_assertion_at_line_255_error_is_max_overheads_are_inconsistent() {
    assert_eq!(
        ::std::mem::size_of::<static_assertion_at_line_255_error_is_max_overheads_are_inconsistent>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(static_assertion_at_line_255_error_is_max_overheads_are_inconsistent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<static_assertion_at_line_255_error_is_max_overheads_are_inconsistent>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(static_assertion_at_line_255_error_is_max_overheads_are_inconsistent)
        )
    );
}
impl static_assertion_at_line_255_error_is_max_overheads_are_inconsistent {
    #[inline]
    pub fn static_assertion_at_line_255_error_is_max_overheads_are_inconsistent(
        &self,
    ) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_static_assertion_at_line_255_error_is_max_overheads_are_inconsistent(
        &mut self,
        val: ::std::os::raw::c_uint,
    ) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        static_assertion_at_line_255_error_is_max_overheads_are_inconsistent : :: std :: os :: raw :: c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let static_assertion_at_line_255_error_is_max_overheads_are_inconsistent: u32 = unsafe {
                ::std::mem::transmute(
                    static_assertion_at_line_255_error_is_max_overheads_are_inconsistent,
                )
            };
            static_assertion_at_line_255_error_is_max_overheads_are_inconsistent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    const UNINIT: ::std::mem::MaybeUninit<timeval64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    const UNINIT: ::std::mem::MaybeUninit<clockinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tickadj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tickadj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stathz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profhz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_with_buffers_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_with_buffers_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_CTX_new(method: *const SSL_METHOD) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_CTX_up_ref(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_free(ctx: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_new(ctx: *mut SSL_CTX) -> *mut SSL;
}
extern "C" {
    pub fn SSL_free(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_get_SSL_CTX(ssl: *const SSL) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_set_connect_state(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_set_accept_state(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_is_server(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_is_dtls(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_bio(ssl: *mut SSL, rbio: *mut BIO, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_set0_rbio(ssl: *mut SSL, rbio: *mut BIO);
}
extern "C" {
    pub fn SSL_set0_wbio(ssl: *mut SSL, wbio: *mut BIO);
}
extern "C" {
    pub fn SSL_get_rbio(ssl: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_get_wbio(ssl: *const SSL) -> *mut BIO;
}
extern "C" {
    pub fn SSL_get_fd(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_rfd(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_wfd(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_fd(ssl: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_rfd(ssl: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_wfd(ssl: *mut SSL, fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_do_handshake(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_connect(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_accept(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_read(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_read_ex(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: usize,
        read_bytes: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_peek(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_peek_ex(
        ssl: *mut SSL,
        buf: *mut ::std::os::raw::c_void,
        num: usize,
        read_bytes: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_pending(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_has_pending(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_write(
        ssl: *mut SSL,
        buf: *const ::std::os::raw::c_void,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_write_ex(
        s: *mut SSL,
        buf: *const ::std::os::raw::c_void,
        num: usize,
        written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_key_update(
        ssl: *mut SSL,
        request_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_key_update_type(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_shutdown(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_quiet_shutdown(ctx: *mut SSL_CTX, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_quiet_shutdown(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_quiet_shutdown(ssl: *mut SSL, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_quiet_shutdown(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_error(ssl: *const SSL, ret_code: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_error_description(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_set_mtu(ssl: *mut SSL, mtu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DTLSv1_set_initial_timeout_duration(ssl: *mut SSL, duration_ms: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn DTLSv1_get_timeout(ssl: *const SSL, out: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DTLSv1_handle_timeout(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_min_proto_version(ctx: *mut SSL_CTX, version: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_max_proto_version(ctx: *mut SSL_CTX, version: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_min_proto_version(ctx: *const SSL_CTX) -> u16;
}
extern "C" {
    pub fn SSL_CTX_get_max_proto_version(ctx: *const SSL_CTX) -> u16;
}
extern "C" {
    pub fn SSL_set_min_proto_version(ssl: *mut SSL, version: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_max_proto_version(ssl: *mut SSL, version: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_min_proto_version(ssl: *const SSL) -> u16;
}
extern "C" {
    pub fn SSL_get_max_proto_version(ssl: *const SSL) -> u16;
}
extern "C" {
    pub fn SSL_version(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_options(ctx: *mut SSL_CTX, options: u32) -> u32;
}
extern "C" {
    pub fn SSL_CTX_clear_options(ctx: *mut SSL_CTX, options: u32) -> u32;
}
extern "C" {
    pub fn SSL_CTX_get_options(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_set_options(ssl: *mut SSL, options: u32) -> u32;
}
extern "C" {
    pub fn SSL_clear_options(ssl: *mut SSL, options: u32) -> u32;
}
extern "C" {
    pub fn SSL_get_options(ssl: *const SSL) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_mode(ctx: *mut SSL_CTX, mode: u32) -> u32;
}
extern "C" {
    pub fn SSL_CTX_clear_mode(ctx: *mut SSL_CTX, mode: u32) -> u32;
}
extern "C" {
    pub fn SSL_CTX_get_mode(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_set_mode(ssl: *mut SSL, mode: u32) -> u32;
}
extern "C" {
    pub fn SSL_clear_mode(ssl: *mut SSL, mode: u32) -> u32;
}
extern "C" {
    pub fn SSL_get_mode(ssl: *const SSL) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set0_buffer_pool(ctx: *mut SSL_CTX, pool: *mut CRYPTO_BUFFER_POOL);
}
extern "C" {
    pub fn SSL_CTX_use_certificate(ctx: *mut SSL_CTX, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate(ssl: *mut SSL, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey(ctx: *mut SSL_CTX, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey(ssl: *mut SSL, pkey: *mut EVP_PKEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set0_chain(
        ctx: *mut SSL_CTX,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_chain(
        ctx: *mut SSL_CTX,
        chain: *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set0_chain(ssl: *mut SSL, chain: *mut stack_st_X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_chain(ssl: *mut SSL, chain: *mut stack_st_X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add0_chain_cert(ctx: *mut SSL_CTX, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add1_chain_cert(ctx: *mut SSL_CTX, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add0_chain_cert(ssl: *mut SSL, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_extra_chain_cert(
        ctx: *mut SSL_CTX,
        x509: *mut X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add1_chain_cert(ssl: *mut SSL, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_build_cert_chain(
        ctx: *mut SSL_CTX,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_build_cert_chain(
        ssl: *mut SSL,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_clear_chain_certs(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_clear_extra_chain_certs(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_clear_chain_certs(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cert_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_set_cert_cb(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_certificate_types(ssl: *const SSL, out_types: *mut *const u8) -> usize;
}
extern "C" {
    pub fn SSL_get0_peer_verify_algorithms(ssl: *const SSL, out_sigalgs: *mut *const u16) -> usize;
}
extern "C" {
    pub fn SSL_get0_peer_delegation_algorithms(
        ssl: *const SSL,
        out_sigalgs: *mut *const u16,
    ) -> usize;
}
extern "C" {
    pub fn SSL_certs_clear(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_CTX_check_private_key(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_check_private_key(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get0_certificate(ctx: *const SSL_CTX) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_certificate(ssl: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_CTX_get0_privatekey(ctx: *const SSL_CTX) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn SSL_get_privatekey(ssl: *const SSL) -> *mut EVP_PKEY;
}
extern "C" {
    pub fn SSL_CTX_get0_chain_certs(
        ctx: *const SSL_CTX,
        out_chain: *mut *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_extra_chain_certs(
        ctx: *const SSL_CTX,
        out_chain: *mut *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_chain_certs(
        ssl: *const SSL,
        out_chain: *mut *mut stack_st_X509,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_signed_cert_timestamp_list(
        ctx: *mut SSL_CTX,
        list: *const u8,
        list_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_signed_cert_timestamp_list(
        ctx: *mut SSL,
        list: *const u8,
        list_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ocsp_response(
        ctx: *mut SSL_CTX,
        response: *const u8,
        response_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_ocsp_response(
        ssl: *mut SSL,
        response: *const u8,
        response_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_signature_algorithm_name(
        sigalg: u16,
        include_curve: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_all_signature_algorithm_names(
        out: *mut *const ::std::os::raw::c_char,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_get_signature_algorithm_key_type(sigalg: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_signature_algorithm_digest(sigalg: u16) -> *const EVP_MD;
}
extern "C" {
    pub fn SSL_is_signature_algorithm_rsa_pss(sigalg: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_signing_algorithm_prefs(
        ctx: *mut SSL_CTX,
        prefs: *const u16,
        num_prefs: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_signing_algorithm_prefs(
        ssl: *mut SSL,
        prefs: *const u16,
        num_prefs: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_chain_and_key(
        ctx: *mut SSL_CTX,
        certs: *const *mut CRYPTO_BUFFER,
        num_certs: usize,
        privkey: *mut EVP_PKEY,
        privkey_method: *const SSL_PRIVATE_KEY_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_chain_and_key(
        ssl: *mut SSL,
        certs: *const *mut CRYPTO_BUFFER,
        num_certs: usize,
        privkey: *mut EVP_PKEY,
        privkey_method: *const SSL_PRIVATE_KEY_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get0_chain(ctx: *const SSL_CTX) -> *const stack_st_CRYPTO_BUFFER;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey(ctx: *mut SSL_CTX, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey(ssl: *mut SSL, rsa: *mut RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_ASN1(
        ctx: *mut SSL_CTX,
        der_len: usize,
        der: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_ASN1(
        ssl: *mut SSL,
        der: *const u8,
        der_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_ASN1(
        pk: ::std::os::raw::c_int,
        ctx: *mut SSL_CTX,
        der: *const u8,
        der_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_ASN1(
        type_: ::std::os::raw::c_int,
        ssl: *mut SSL,
        der: *const u8,
        der_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_ASN1(
        ctx: *mut SSL_CTX,
        der: *const u8,
        der_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_ASN1(
        ssl: *mut SSL,
        der: *const u8,
        der_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_RSAPrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_RSAPrivateKey_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_PrivateKey_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_PrivateKey_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_use_certificate_chain_file(
        ctx: *mut SSL_CTX,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_certificate_chain_file(
        ssl: *mut SSL,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb(ctx: *mut SSL_CTX, cb: pem_password_cb);
}
extern "C" {
    pub fn SSL_CTX_get_default_passwd_cb(ctx: *const SSL_CTX) -> pem_password_cb;
}
extern "C" {
    pub fn SSL_CTX_set_default_passwd_cb_userdata(
        ctx: *mut SSL_CTX,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_get_default_passwd_cb_userdata(
        ctx: *const SSL_CTX,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_private_key_result_t {
    ssl_private_key_success = 0,
    ssl_private_key_retry = 1,
    ssl_private_key_failure = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_private_key_method_st {
    pub sign: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            out: *mut u8,
            out_len: *mut usize,
            max_out: usize,
            signature_algorithm: u16,
            in_: *const u8,
            in_len: usize,
        ) -> ssl_private_key_result_t,
    >,
    pub decrypt: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            out: *mut u8,
            out_len: *mut usize,
            max_out: usize,
            in_: *const u8,
            in_len: usize,
        ) -> ssl_private_key_result_t,
    >,
    pub complete: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            out: *mut u8,
            out_len: *mut usize,
            max_out: usize,
        ) -> ssl_private_key_result_t,
    >,
}
#[test]
fn bindgen_test_layout_ssl_private_key_method_st() {
    const UNINIT: ::std::mem::MaybeUninit<ssl_private_key_method_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ssl_private_key_method_st>(),
        24usize,
        concat!("Size of: ", stringify!(ssl_private_key_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_private_key_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_private_key_method_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_private_key_method_st),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decrypt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_private_key_method_st),
            "::",
            stringify!(decrypt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complete) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_private_key_method_st),
            "::",
            stringify!(complete)
        )
    );
}
extern "C" {
    pub fn SSL_set_private_key_method(ssl: *mut SSL, key_method: *const SSL_PRIVATE_KEY_METHOD);
}
extern "C" {
    pub fn SSL_CTX_set_private_key_method(
        ctx: *mut SSL_CTX,
        key_method: *const SSL_PRIVATE_KEY_METHOD,
    );
}
extern "C" {
    pub fn SSL_can_release_private_key(ssl: *const SSL) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_CIPHER {
    _unused: [u8; 0],
}
pub type sk_SSL_CIPHER_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const SSL_CIPHER)>;
pub type sk_SSL_CIPHER_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const SSL_CIPHER) -> *const SSL_CIPHER>;
pub type sk_SSL_CIPHER_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const SSL_CIPHER,
        arg2: *const *const SSL_CIPHER,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_SSL_CIPHER_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const SSL_CIPHER,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_get_cipher_by_value(value: u16) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_find(ssl: *mut SSL, ptr: *const ::std::os::raw::c_uchar)
        -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CIPHER_get_id(cipher: *const SSL_CIPHER) -> u32;
}
extern "C" {
    pub fn SSL_CIPHER_get_protocol_id(cipher: *const SSL_CIPHER) -> u16;
}
extern "C" {
    pub fn SSL_CIPHER_is_aead(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_is_block_cipher(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_cipher_nid(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_digest_nid(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_kx_nid(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_auth_nid(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_handshake_digest(cipher: *const SSL_CIPHER) -> *const EVP_MD;
}
extern "C" {
    pub fn SSL_CIPHER_get_prf_nid(cipher: *const SSL_CIPHER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_get_min_version(cipher: *const SSL_CIPHER) -> u16;
}
extern "C" {
    pub fn SSL_CIPHER_get_max_version(cipher: *const SSL_CIPHER) -> u16;
}
extern "C" {
    pub fn SSL_CIPHER_standard_name(cipher: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_name(cipher: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_kx_name(cipher: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_bits(
        cipher: *const SSL_CIPHER,
        out_alg_bits: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_all_cipher_names(
        out: *mut *const ::std::os::raw::c_char,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_get_all_standard_cipher_names(
        out: *mut *const ::std::os::raw::c_char,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set_strict_cipher_list(
        ctx: *mut SSL_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cipher_list(
        ctx: *mut SSL_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_strict_cipher_list(
        ssl: *mut SSL,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ciphersuites(
        ctx: *mut SSL_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_ciphersuites(
        ssl: *mut SSL,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_cipher_list(
        ssl: *mut SSL,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_ciphers(ctx: *const SSL_CTX) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_CTX_cipher_in_group(ctx: *const SSL_CTX, i: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ciphers(ssl: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_is_init_finished(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_in_init(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_in_false_start(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_peer_certificate(ssl: *const SSL) -> *mut X509;
}
extern "C" {
    pub fn SSL_get_peer_cert_chain(ssl: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_get_peer_full_cert_chain(ssl: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_get0_verified_chain(ssl: *const SSL) -> *mut stack_st_X509;
}
extern "C" {
    pub fn SSL_get0_peer_certificates(ssl: *const SSL) -> *const stack_st_CRYPTO_BUFFER;
}
extern "C" {
    pub fn SSL_get0_signed_cert_timestamp_list(
        ssl: *const SSL,
        out: *mut *const u8,
        out_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_get0_ocsp_response(ssl: *const SSL, out: *mut *const u8, out_len: *mut usize);
}
extern "C" {
    pub fn SSL_get_tls_unique(
        ssl: *const SSL,
        out: *mut u8,
        out_len: *mut usize,
        max_out: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_extms_support(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_current_cipher(ssl: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_get_client_ciphers(ssl: *const SSL) -> *mut stack_st_SSL_CIPHER;
}
extern "C" {
    pub fn SSL_client_hello_get0_ciphers(
        ssl: *mut SSL,
        out: *mut *const ::std::os::raw::c_uchar,
    ) -> usize;
}
extern "C" {
    pub fn SSL_session_reused(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_secure_renegotiation_support(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_export_keying_material(
        ssl: *mut SSL,
        out: *mut u8,
        out_len: usize,
        label: *const ::std::os::raw::c_char,
        label_len: usize,
        context: *const u8,
        context_len: usize,
        use_context: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type SSL_custom_ext_add_cb = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        extension_value: ::std::os::raw::c_uint,
        out: *mut *const u8,
        out_len: *mut usize,
        out_alert_value: *mut ::std::os::raw::c_int,
        add_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type SSL_custom_ext_free_cb = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        extension_value: ::std::os::raw::c_uint,
        out: *const u8,
        add_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type SSL_custom_ext_parse_cb = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        extension_value: ::std::os::raw::c_uint,
        contents: *const u8,
        contents_len: usize,
        out_alert_value: *mut ::std::os::raw::c_int,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_extension_supported(
        extension_value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_custom_ext(
        ctx: *mut SSL_CTX,
        extension_value: ::std::os::raw::c_uint,
        add_cb: SSL_custom_ext_add_cb,
        free_cb: SSL_custom_ext_free_cb,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: SSL_custom_ext_parse_cb,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_server_custom_ext(
        ctx: *mut SSL_CTX,
        extension_value: ::std::os::raw::c_uint,
        add_cb: SSL_custom_ext_add_cb,
        free_cb: SSL_custom_ext_free_cb,
        add_arg: *mut ::std::os::raw::c_void,
        parse_cb: SSL_custom_ext_parse_cb,
        parse_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_read_bio_SSL_SESSION(
        bp: *mut BIO,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_read_SSL_SESSION(
        fp: *mut FILE,
        x: *mut *mut SSL_SESSION,
        cb: pem_password_cb,
        u: *mut ::std::os::raw::c_void,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn PEM_write_bio_SSL_SESSION(bp: *mut BIO, x: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PEM_write_SSL_SESSION(fp: *mut FILE, x: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_new(ctx: *const SSL_CTX) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_up_ref(session: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_free(session: *mut SSL_SESSION);
}
extern "C" {
    pub fn SSL_SESSION_to_bytes(
        in_: *const SSL_SESSION,
        out_data: *mut *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_to_bytes_for_ticket(
        in_: *const SSL_SESSION,
        out_data: *mut *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_from_bytes(
        in_: *const u8,
        in_len: usize,
        ctx: *const SSL_CTX,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_SESSION_get_version(session: *const SSL_SESSION) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_SESSION_get_protocol_version(session: *const SSL_SESSION) -> u16;
}
extern "C" {
    pub fn SSL_SESSION_set_protocol_version(
        session: *mut SSL_SESSION,
        version: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_id(
        session: *const SSL_SESSION,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> *const u8;
}
extern "C" {
    pub fn SSL_SESSION_set1_id(
        session: *mut SSL_SESSION,
        sid: *const u8,
        sid_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_time(session: *const SSL_SESSION) -> u64;
}
extern "C" {
    pub fn SSL_SESSION_get_timeout(session: *const SSL_SESSION) -> u32;
}
extern "C" {
    pub fn SSL_SESSION_get0_peer(session: *const SSL_SESSION) -> *mut X509;
}
extern "C" {
    pub fn SSL_SESSION_get0_peer_certificates(
        session: *const SSL_SESSION,
    ) -> *const stack_st_CRYPTO_BUFFER;
}
extern "C" {
    pub fn SSL_SESSION_get0_signed_cert_timestamp_list(
        session: *const SSL_SESSION,
        out: *mut *const u8,
        out_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_SESSION_get0_ocsp_response(
        session: *const SSL_SESSION,
        out: *mut *const u8,
        out_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_SESSION_get_master_key(
        session: *const SSL_SESSION,
        out: *mut u8,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_SESSION_set_time(session: *mut SSL_SESSION, time: u64) -> u64;
}
extern "C" {
    pub fn SSL_SESSION_set_timeout(session: *mut SSL_SESSION, timeout: u32) -> u32;
}
extern "C" {
    pub fn SSL_SESSION_get0_id_context(
        session: *const SSL_SESSION,
        out_len: *mut ::std::os::raw::c_uint,
    ) -> *const u8;
}
extern "C" {
    pub fn SSL_SESSION_set1_id_context(
        session: *mut SSL_SESSION,
        sid_ctx: *const u8,
        sid_ctx_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_should_be_single_use(session: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_is_resumable(session: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_has_ticket(session: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_ticket(
        session: *const SSL_SESSION,
        out_ticket: *mut *const u8,
        out_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_SESSION_set_ticket(
        session: *mut SSL_SESSION,
        ticket: *const u8,
        ticket_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ticket_lifetime_hint(session: *const SSL_SESSION) -> u32;
}
extern "C" {
    pub fn SSL_SESSION_get0_cipher(session: *const SSL_SESSION) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_SESSION_has_peer_sha256(session: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get0_peer_sha256(
        session: *const SSL_SESSION,
        out_ptr: *mut *const u8,
        out_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_CTX_set_session_cache_mode(
        ctx: *mut SSL_CTX,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_session_cache_mode(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session(ssl: *mut SSL, session: *mut SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_timeout(ctx: *mut SSL_CTX, timeout: u32) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_session_psk_dhe_timeout(ctx: *mut SSL_CTX, timeout: u32);
}
extern "C" {
    pub fn SSL_CTX_get_timeout(ctx: *const SSL_CTX) -> u32;
}
extern "C" {
    pub fn SSL_CTX_set_session_id_context(
        ctx: *mut SSL_CTX,
        sid_ctx: *const u8,
        sid_ctx_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_session_id_context(
        ssl: *mut SSL,
        sid_ctx: *const u8,
        sid_ctx_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_session_id_context(ssl: *const SSL, out_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn SSL_CTX_sess_set_cache_size(
        ctx: *mut SSL_CTX,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_sess_get_cache_size(ctx: *const SSL_CTX) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SSL_CTX_sess_number(ctx: *const SSL_CTX) -> usize;
}
extern "C" {
    pub fn SSL_CTX_add_session(
        ctx: *mut SSL_CTX,
        session: *mut SSL_SESSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_remove_session(
        ctx: *mut SSL_CTX,
        session: *mut SSL_SESSION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_flush_sessions(ctx: *mut SSL_CTX, time: u64);
}
extern "C" {
    pub fn SSL_CTX_sess_set_new_cb(
        ctx: *mut SSL_CTX,
        new_session_cb: ::std::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, session: *mut SSL_SESSION) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_new_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut SSL, arg1: *mut SSL_SESSION) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_CTX_sess_set_remove_cb(
        ctx: *mut SSL_CTX,
        remove_session_cb: ::std::option::Option<
            unsafe extern "C" fn(ctx: *mut SSL_CTX, session: *mut SSL_SESSION),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_remove_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<unsafe extern "C" fn(ctx: *mut SSL_CTX, arg1: *mut SSL_SESSION)>;
}
extern "C" {
    pub fn SSL_CTX_sess_set_get_cb(
        ctx: *mut SSL_CTX,
        get_session_cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                id: *const u8,
                id_len: ::std::os::raw::c_int,
                out_copy: *mut ::std::os::raw::c_int,
            ) -> *mut SSL_SESSION,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_sess_get_get_cb(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut SSL,
            arg1: *const u8,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_int,
        ) -> *mut SSL_SESSION,
    >;
}
extern "C" {
    pub fn SSL_magic_pending_session_ptr() -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_CTX_get_tlsext_ticket_keys(
        ctx: *mut SSL_CTX,
        out: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_ticket_keys(
        ctx: *mut SSL_CTX,
        in_: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_ticket_key_cb(
        ctx: *mut SSL_CTX,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                key_name: *mut u8,
                iv: *mut u8,
                ctx: *mut EVP_CIPHER_CTX,
                hmac_ctx: *mut HMAC_CTX,
                encrypt: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_ticket_aead_result_t {
    ssl_ticket_aead_success = 0,
    ssl_ticket_aead_retry = 1,
    ssl_ticket_aead_ignore_ticket = 2,
    ssl_ticket_aead_error = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ticket_aead_method_st {
    pub max_overhead: ::std::option::Option<unsafe extern "C" fn(ssl: *mut SSL) -> usize>,
    pub seal: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            out: *mut u8,
            out_len: *mut usize,
            max_out_len: usize,
            in_: *const u8,
            in_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            out: *mut u8,
            out_len: *mut usize,
            max_out_len: usize,
            in_: *const u8,
            in_len: usize,
        ) -> ssl_ticket_aead_result_t,
    >,
}
#[test]
fn bindgen_test_layout_ssl_ticket_aead_method_st() {
    const UNINIT: ::std::mem::MaybeUninit<ssl_ticket_aead_method_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ssl_ticket_aead_method_st>(),
        24usize,
        concat!("Size of: ", stringify!(ssl_ticket_aead_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_ticket_aead_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ticket_aead_method_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_overhead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_aead_method_st),
            "::",
            stringify!(max_overhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_aead_method_st),
            "::",
            stringify!(seal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_aead_method_st),
            "::",
            stringify!(open)
        )
    );
}
extern "C" {
    pub fn SSL_CTX_set_ticket_aead_method(
        ctx: *mut SSL_CTX,
        aead_method: *const SSL_TICKET_AEAD_METHOD,
    );
}
extern "C" {
    pub fn SSL_process_tls13_new_session_ticket(
        ssl: *mut SSL,
        buf: *const u8,
        buf_len: usize,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_CTX_set_num_tickets(ctx: *mut SSL_CTX, num_tickets: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_num_tickets(ctx: *const SSL_CTX) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set1_groups(
        ctx: *mut SSL_CTX,
        groups: *const ::std::os::raw::c_int,
        num_groups: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_groups(
        ssl: *mut SSL,
        groups: *const ::std::os::raw::c_int,
        num_groups: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_groups_list(
        ctx: *mut SSL_CTX,
        groups: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_groups_list(
        ssl: *mut SSL,
        groups: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_group_id(ssl: *const SSL) -> u16;
}
extern "C" {
    pub fn SSL_get_group_name(group_id: u16) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_to_bytes(
        in_: *const SSL,
        out_data: *mut *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_from_bytes(in_: *const u8, in_len: usize, ctx: *mut SSL_CTX) -> *mut SSL;
}
extern "C" {
    pub fn SSL_get_all_group_names(
        out: *mut *const ::std::os::raw::c_char,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set_verify(
        ctx: *mut SSL_CTX,
        mode: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                ok: ::std::os::raw::c_int,
                store_ctx: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_set_verify(
        ssl: *mut SSL,
        mode: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                ok: ::std::os::raw::c_int,
                store_ctx: *mut X509_STORE_CTX,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_verify_result_t {
    ssl_verify_ok = 0,
    ssl_verify_invalid = 1,
    ssl_verify_retry = 2,
}
extern "C" {
    pub fn SSL_CTX_set_custom_verify(
        ctx: *mut SSL_CTX,
        mode: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, out_alert: *mut u8) -> ssl_verify_result_t,
        >,
    );
}
extern "C" {
    pub fn SSL_set_custom_verify(
        ssl: *mut SSL,
        mode: ::std::os::raw::c_int,
        callback: ::std::option::Option<
            unsafe extern "C" fn(ssl: *mut SSL, out_alert: *mut u8) -> ssl_verify_result_t,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_verify_mode(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_mode(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_verify_callback(
        ctx: *const SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: ::std::os::raw::c_int,
            arg1: *mut X509_STORE_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_get_verify_callback(
        ssl: *const SSL,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ssl: ::std::os::raw::c_int,
            arg1: *mut X509_STORE_CTX,
        ) -> ::std::os::raw::c_int,
    >;
}
extern "C" {
    pub fn SSL_set1_host(
        ssl: *mut SSL,
        hostname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_hostflags(ssl: *mut SSL, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn SSL_CTX_set_verify_depth(ctx: *mut SSL_CTX, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_verify_depth(ssl: *mut SSL, depth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_get_verify_depth(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_depth(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_param(
        ctx: *mut SSL_CTX,
        param: *const X509_VERIFY_PARAM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_param(ssl: *mut SSL, param: *const X509_VERIFY_PARAM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get0_param(ctx: *mut SSL_CTX) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_get0_param(ssl: *mut SSL) -> *mut X509_VERIFY_PARAM;
}
extern "C" {
    pub fn SSL_CTX_set_purpose(
        ctx: *mut SSL_CTX,
        purpose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_purpose(ssl: *mut SSL, purpose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_trust(
        ctx: *mut SSL_CTX,
        trust: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_trust(ssl: *mut SSL, trust: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cert_store(ctx: *mut SSL_CTX, store: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_CTX_set1_cert_store(ctx: *mut SSL_CTX, store: *mut X509_STORE);
}
extern "C" {
    pub fn SSL_CTX_get_cert_store(ctx: *const SSL_CTX) -> *mut X509_STORE;
}
extern "C" {
    pub fn SSL_CTX_set_default_verify_paths(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_load_verify_locations(
        ctx: *mut SSL_CTX,
        ca_file: *const ::std::os::raw::c_char,
        ca_dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_verify_result(ssl: *const SSL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_alert_from_verify_result(result: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ex_data_X509_STORE_CTX_idx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_cert_verify_callback(
        ctx: *mut SSL_CTX,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                store_ctx: *mut X509_STORE_CTX,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_enable_signed_cert_timestamps(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_CTX_enable_signed_cert_timestamps(ctx: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_enable_ocsp_stapling(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_CTX_enable_ocsp_stapling(ctx: *mut SSL_CTX);
}
extern "C" {
    pub fn SSL_CTX_set0_verify_cert_store(
        ctx: *mut SSL_CTX,
        store: *mut X509_STORE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_verify_cert_store(
        ctx: *mut SSL_CTX,
        store: *mut X509_STORE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set0_verify_cert_store(
        ssl: *mut SSL,
        store: *mut X509_STORE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_verify_cert_store(
        ssl: *mut SSL,
        store: *mut X509_STORE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_verify_algorithm_prefs(
        ctx: *mut SSL_CTX,
        prefs: *const u16,
        num_prefs: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_verify_algorithm_prefs(
        ssl: *mut SSL,
        prefs: *const u16,
        num_prefs: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_client_CA_list(ssl: *mut SSL, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_CTX_set_client_CA_list(ctx: *mut SSL_CTX, name_list: *mut stack_st_X509_NAME);
}
extern "C" {
    pub fn SSL_set0_client_CAs(ssl: *mut SSL, name_list: *mut stack_st_CRYPTO_BUFFER);
}
extern "C" {
    pub fn SSL_CTX_set0_client_CAs(ctx: *mut SSL_CTX, name_list: *mut stack_st_CRYPTO_BUFFER);
}
extern "C" {
    pub fn SSL_get_client_CA_list(ssl: *const SSL) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_get0_server_requested_CAs(ssl: *const SSL) -> *const stack_st_CRYPTO_BUFFER;
}
extern "C" {
    pub fn SSL_CTX_get_client_CA_list(ctx: *const SSL_CTX) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_client_CA(ssl: *mut SSL, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_add_client_CA(ctx: *mut SSL_CTX, x509: *mut X509) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_load_client_CA_file(file: *const ::std::os::raw::c_char) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_dup_CA_list(list: *mut stack_st_X509_NAME) -> *mut stack_st_X509_NAME;
}
extern "C" {
    pub fn SSL_add_file_cert_subjects_to_stack(
        out: *mut stack_st_X509_NAME,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add_bio_cert_subjects_to_stack(
        out: *mut stack_st_X509_NAME,
        bio: *mut BIO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_host_name(
        ssl: *mut SSL,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_servername(
        ssl: *const SSL,
        type_: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_servername_type(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_servername_callback(
        ctx: *mut SSL_CTX,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out_alert: *mut ::std::os::raw::c_int,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_servername_arg(
        ctx: *mut SSL_CTX,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_SSL_CTX(ssl: *mut SSL, ctx: *mut SSL_CTX) -> *mut SSL_CTX;
}
extern "C" {
    pub fn SSL_CTX_set_alpn_protos(
        ctx: *mut SSL_CTX,
        protos: *const u8,
        protos_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_alpn_protos(
        ssl: *mut SSL,
        protos: *const u8,
        protos_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_alpn_select_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out: *mut *const u8,
                out_len: *mut u8,
                in_: *const u8,
                in_len: ::std::os::raw::c_uint,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_alpn_selected(
        ssl: *const SSL,
        out_data: *mut *const u8,
        out_len: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SSL_CTX_set_allow_unknown_alpn_protos(ctx: *mut SSL_CTX, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_add_application_settings(
        ssl: *mut SSL,
        proto: *const u8,
        proto_len: usize,
        settings: *const u8,
        settings_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_peer_application_settings(
        ssl: *const SSL,
        out_data: *mut *const u8,
        out_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_has_application_settings(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_alps_use_new_codepoint(ssl: *mut SSL, use_new: ::std::os::raw::c_int);
}
pub type ssl_cert_compression_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        out: *mut CBB,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type ssl_cert_decompression_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        out: *mut *mut CRYPTO_BUFFER,
        uncompressed_len: usize,
        in_: *const u8,
        in_len: usize,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_add_cert_compression_alg(
        ctx: *mut SSL_CTX,
        alg_id: u16,
        compress: ssl_cert_compression_func_t,
        decompress: ssl_cert_decompression_func_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_next_protos_advertised_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out: *mut *const u8,
                out_len: *mut ::std::os::raw::c_uint,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_CTX_set_next_proto_select_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out: *mut *mut u8,
                out_len: *mut u8,
                in_: *const u8,
                in_len: ::std::os::raw::c_uint,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn SSL_get0_next_proto_negotiated(
        ssl: *const SSL,
        out_data: *mut *const u8,
        out_len: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn SSL_select_next_proto(
        out: *mut *mut u8,
        out_len: *mut u8,
        peer: *const u8,
        peer_len: ::std::os::raw::c_uint,
        supported: *const u8,
        supported_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tls_channel_id_enabled(ctx: *mut SSL_CTX, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_tls_channel_id_enabled(ssl: *mut SSL, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_set1_tls_channel_id(
        ctx: *mut SSL_CTX,
        private_key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_tls_channel_id(
        ssl: *mut SSL,
        private_key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_tls_channel_id(ssl: *mut SSL, out: *mut u8, max_out: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srtp_protection_profile_st {
    pub name: *const ::std::os::raw::c_char,
    pub id: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_srtp_protection_profile_st() {
    const UNINIT: ::std::mem::MaybeUninit<srtp_protection_profile_st> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<srtp_protection_profile_st>(),
        16usize,
        concat!("Size of: ", stringify!(srtp_protection_profile_st))
    );
    assert_eq!(
        ::std::mem::align_of::<srtp_protection_profile_st>(),
        8usize,
        concat!("Alignment of ", stringify!(srtp_protection_profile_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_protection_profile_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srtp_protection_profile_st),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SRTP_PROTECTION_PROFILE {
    _unused: [u8; 0],
}
pub type sk_SRTP_PROTECTION_PROFILE_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const SRTP_PROTECTION_PROFILE)>;
pub type sk_SRTP_PROTECTION_PROFILE_copy_func = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const SRTP_PROTECTION_PROFILE) -> *const SRTP_PROTECTION_PROFILE,
>;
pub type sk_SRTP_PROTECTION_PROFILE_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const SRTP_PROTECTION_PROFILE,
        arg2: *const *const SRTP_PROTECTION_PROFILE,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_SRTP_PROTECTION_PROFILE_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const SRTP_PROTECTION_PROFILE,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_CTX_set_srtp_profiles(
        ctx: *mut SSL_CTX,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_srtp_profiles(
        ssl: *mut SSL,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_srtp_profiles(ssl: *const SSL) -> *const stack_st_SRTP_PROTECTION_PROFILE;
}
extern "C" {
    pub fn SSL_get_selected_srtp_profile(ssl: *mut SSL) -> *const SRTP_PROTECTION_PROFILE;
}
pub type SSL_psk_client_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        hint: *const ::std::os::raw::c_char,
        identity: *mut ::std::os::raw::c_char,
        max_identity_len: ::std::os::raw::c_uint,
        psk: *mut u8,
        max_psk_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn SSL_CTX_set_psk_client_callback(ctx: *mut SSL_CTX, cb: SSL_psk_client_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_client_callback(ssl: *mut SSL, cb: SSL_psk_client_cb_func);
}
pub type SSL_psk_server_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        ssl: *mut SSL,
        identity: *const ::std::os::raw::c_char,
        psk: *mut u8,
        max_psk_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub fn SSL_CTX_set_psk_server_callback(ctx: *mut SSL_CTX, cb: SSL_psk_server_cb_func);
}
extern "C" {
    pub fn SSL_set_psk_server_callback(ssl: *mut SSL, cb: SSL_psk_server_cb_func);
}
extern "C" {
    pub fn SSL_CTX_use_psk_identity_hint(
        ctx: *mut SSL_CTX,
        identity_hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_use_psk_identity_hint(
        ssl: *mut SSL,
        identity_hint: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_psk_identity_hint(ssl: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_psk_identity(ssl: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_set1_delegated_credential(
        ssl: *mut SSL,
        dc: *mut CRYPTO_BUFFER,
        pkey: *mut EVP_PKEY,
        key_method: *const SSL_PRIVATE_KEY_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_delegated_credential_used(ssl: *const SSL) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_encryption_level_t {
    ssl_encryption_initial = 0,
    ssl_encryption_early_data = 1,
    ssl_encryption_handshake = 2,
    ssl_encryption_application = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_quic_method_st {
    pub set_read_secret: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            level: ssl_encryption_level_t,
            cipher: *const SSL_CIPHER,
            secret: *const u8,
            secret_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_write_secret: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            level: ssl_encryption_level_t,
            cipher: *const SSL_CIPHER,
            secret: *const u8,
            secret_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_handshake_data: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            level: ssl_encryption_level_t,
            data: *const u8,
            len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub flush_flight:
        ::std::option::Option<unsafe extern "C" fn(ssl: *mut SSL) -> ::std::os::raw::c_int>,
    pub send_alert: ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *mut SSL,
            level: ssl_encryption_level_t,
            alert: u8,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_ssl_quic_method_st() {
    const UNINIT: ::std::mem::MaybeUninit<ssl_quic_method_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ssl_quic_method_st>(),
        40usize,
        concat!("Size of: ", stringify!(ssl_quic_method_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_quic_method_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_quic_method_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_read_secret) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_quic_method_st),
            "::",
            stringify!(set_read_secret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_write_secret) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_quic_method_st),
            "::",
            stringify!(set_write_secret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_handshake_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_quic_method_st),
            "::",
            stringify!(add_handshake_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_flight) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_quic_method_st),
            "::",
            stringify!(flush_flight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_alert) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_quic_method_st),
            "::",
            stringify!(send_alert)
        )
    );
}
extern "C" {
    pub fn SSL_quic_max_handshake_flight_len(
        ssl: *const SSL,
        level: ssl_encryption_level_t,
    ) -> usize;
}
extern "C" {
    pub fn SSL_quic_read_level(ssl: *const SSL) -> ssl_encryption_level_t;
}
extern "C" {
    pub fn SSL_quic_write_level(ssl: *const SSL) -> ssl_encryption_level_t;
}
extern "C" {
    pub fn SSL_provide_quic_data(
        ssl: *mut SSL,
        level: ssl_encryption_level_t,
        data: *const u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_process_quic_post_handshake(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_quic_method(
        ctx: *mut SSL_CTX,
        quic_method: *const SSL_QUIC_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_quic_method(
        ssl: *mut SSL,
        quic_method: *const SSL_QUIC_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_quic_transport_params(
        ssl: *mut SSL,
        params: *const u8,
        params_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_peer_quic_transport_params(
        ssl: *const SSL,
        out_params: *mut *const u8,
        out_params_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_set_quic_use_legacy_codepoint(ssl: *mut SSL, use_legacy: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_quic_early_data_context(
        ssl: *mut SSL,
        context: *const u8,
        context_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_early_data_enabled(ctx: *mut SSL_CTX, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_early_data_enabled(ssl: *mut SSL, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_in_early_data(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_early_data_capable(session: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_copy_without_early_data(session: *mut SSL_SESSION) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_early_data_accepted(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_reset_early_data_reject(ssl: *mut SSL);
}
extern "C" {
    pub fn SSL_get_ticket_age_skew(ssl: *const SSL) -> i32;
}
impl ssl_early_data_reason_t {
    pub const ssl_early_data_reason_max_value: ssl_early_data_reason_t =
        ssl_early_data_reason_t::ssl_early_data_unsupported_with_custom_extension;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_early_data_reason_t {
    ssl_early_data_unknown = 0,
    ssl_early_data_disabled = 1,
    ssl_early_data_accepted = 2,
    ssl_early_data_protocol_version = 3,
    ssl_early_data_peer_declined = 4,
    ssl_early_data_no_session_offered = 5,
    ssl_early_data_session_not_resumed = 6,
    ssl_early_data_unsupported_for_session = 7,
    ssl_early_data_hello_retry_request = 8,
    ssl_early_data_alpn_mismatch = 9,
    ssl_early_data_channel_id = 10,
    ssl_early_data_ticket_age_skew = 12,
    ssl_early_data_quic_parameter_mismatch = 13,
    ssl_early_data_alps_mismatch = 14,
    ssl_early_data_unsupported_with_custom_extension = 15,
}
extern "C" {
    pub fn SSL_get_early_data_reason(ssl: *const SSL) -> ssl_early_data_reason_t;
}
extern "C" {
    pub fn SSL_early_data_reason_string(
        reason: ssl_early_data_reason_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_set_enable_ech_grease(ssl: *mut SSL, enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set1_ech_config_list(
        ssl: *mut SSL,
        ech_config_list: *const u8,
        ech_config_list_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get0_ech_name_override(
        ssl: *const SSL,
        out_name: *mut *const ::std::os::raw::c_char,
        out_name_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_get0_ech_retry_configs(
        ssl: *const SSL,
        out_retry_configs: *mut *const u8,
        out_retry_configs_len: *mut usize,
    );
}
extern "C" {
    pub fn SSL_marshal_ech_config(
        out: *mut *mut u8,
        out_len: *mut usize,
        config_id: u8,
        key: *const EVP_HPKE_KEY,
        public_name: *const ::std::os::raw::c_char,
        max_name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ECH_KEYS_new() -> *mut SSL_ECH_KEYS;
}
extern "C" {
    pub fn SSL_ECH_KEYS_up_ref(keys: *mut SSL_ECH_KEYS);
}
extern "C" {
    pub fn SSL_ECH_KEYS_free(keys: *mut SSL_ECH_KEYS);
}
extern "C" {
    pub fn SSL_ECH_KEYS_add(
        keys: *mut SSL_ECH_KEYS,
        is_retry_config: ::std::os::raw::c_int,
        ech_config: *const u8,
        ech_config_len: usize,
        key: *const EVP_HPKE_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ECH_KEYS_has_duplicate_config_id(keys: *const SSL_ECH_KEYS)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ECH_KEYS_marshal_retry_configs(
        keys: *const SSL_ECH_KEYS,
        out: *mut *mut u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_ech_keys(
        ctx: *mut SSL_CTX,
        keys: *mut SSL_ECH_KEYS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_ech_accepted(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_alert_type_string_long(
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string_long(
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_send_fatal_alert(ssl: *mut SSL, alert: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_ex_data(
        ssl: *mut SSL,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ex_data(
        ssl: *const SSL,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_set_ex_data(
        session: *mut SSL_SESSION,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_get_ex_data(
        session: *const SSL_SESSION,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_SESSION_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_ex_data(
        ctx: *mut SSL_CTX,
        idx: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_ex_data(
        ctx: *const SSL_CTX,
        idx: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SSL_CTX_get_ex_new_index(
        argl: ::std::os::raw::c_long,
        argp: *mut ::std::os::raw::c_void,
        unused: *mut CRYPTO_EX_unused,
        dup_unused: CRYPTO_EX_dup,
        free_func: CRYPTO_EX_free,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_ivs(
        ssl: *const SSL,
        out_read_iv: *mut *const u8,
        out_write_iv: *mut *const u8,
        out_iv_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_key_block_len(ssl: *const SSL) -> usize;
}
extern "C" {
    pub fn SSL_generate_key_block(
        ssl: *const SSL,
        out: *mut u8,
        out_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_read_sequence(ssl: *const SSL) -> u64;
}
extern "C" {
    pub fn SSL_get_write_sequence(ssl: *const SSL) -> u64;
}
extern "C" {
    pub fn SSL_CTX_set_record_protocol_version(
        ctx: *mut SSL_CTX,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_serialize_capabilities(ssl: *const SSL, out: *mut CBB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_request_handshake_hints(
        ssl: *mut SSL,
        client_hello: *const u8,
        client_hello_len: usize,
        capabilities: *const u8,
        capabilities_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_serialize_handshake_hints(ssl: *const SSL, out: *mut CBB) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_handshake_hints(
        ssl: *mut SSL,
        hints: *const u8,
        hints_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_msg_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                is_write: ::std::os::raw::c_int,
                version: ::std::os::raw::c_int,
                content_type: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_void,
                len: usize,
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_msg_callback_arg(ctx: *mut SSL_CTX, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SSL_set_msg_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                write_p: ::std::os::raw::c_int,
                version: ::std::os::raw::c_int,
                content_type: ::std::os::raw::c_int,
                buf: *const ::std::os::raw::c_void,
                len: usize,
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_set_msg_callback_arg(ssl: *mut SSL, arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SSL_CTX_set_keylog_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(ssl: *const SSL, line: *const ::std::os::raw::c_char),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_keylog_callback(
        ctx: *const SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(ctx: *const SSL, arg1: *const ::std::os::raw::c_char),
    >;
}
extern "C" {
    pub fn SSL_CTX_set_current_time_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<unsafe extern "C" fn(ssl: *const SSL, out_clock: *mut timeval)>,
    );
}
extern "C" {
    pub fn SSL_set_shed_handshake_config(ssl: *mut SSL, enable: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_renegotiate_mode_t {
    ssl_renegotiate_never = 0,
    ssl_renegotiate_once = 1,
    ssl_renegotiate_freely = 2,
    ssl_renegotiate_ignore = 3,
    ssl_renegotiate_explicit = 4,
}
extern "C" {
    pub fn SSL_set_renegotiate_mode(ssl: *mut SSL, mode: ssl_renegotiate_mode_t);
}
extern "C" {
    pub fn SSL_renegotiate(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_renegotiate_pending(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_total_renegotiations(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_max_cert_list(ctx: *const SSL_CTX) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set_max_cert_list(ctx: *mut SSL_CTX, max_cert_list: usize);
}
extern "C" {
    pub fn SSL_get_max_cert_list(ssl: *const SSL) -> usize;
}
extern "C" {
    pub fn SSL_set_max_cert_list(ssl: *mut SSL, max_cert_list: usize);
}
extern "C" {
    pub fn SSL_CTX_set_max_send_fragment(
        ctx: *mut SSL_CTX,
        max_send_fragment: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_max_send_fragment(
        ssl: *mut SSL,
        max_send_fragment: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_early_callback_ctx {
    pub ssl: *mut SSL,
    pub client_hello: *const u8,
    pub client_hello_len: usize,
    pub version: u16,
    pub random: *const u8,
    pub random_len: usize,
    pub session_id: *const u8,
    pub session_id_len: usize,
    pub cipher_suites: *const u8,
    pub cipher_suites_len: usize,
    pub compression_methods: *const u8,
    pub compression_methods_len: usize,
    pub extensions: *const u8,
    pub extensions_len: usize,
}
#[test]
fn bindgen_test_layout_ssl_early_callback_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<ssl_early_callback_ctx> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ssl_early_callback_ctx>(),
        112usize,
        concat!("Size of: ", stringify!(ssl_early_callback_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_early_callback_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_early_callback_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ssl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(ssl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_hello) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(client_hello)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_hello_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(client_hello_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).random) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(random)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).random_len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(random_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).session_id_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(session_id_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cipher_suites) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(cipher_suites)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cipher_suites_len) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(cipher_suites_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compression_methods) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(compression_methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compression_methods_len) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(compression_methods_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions_len) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_early_callback_ctx),
            "::",
            stringify!(extensions_len)
        )
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ssl_select_cert_result_t {
    ssl_select_cert_success = 1,
    ssl_select_cert_retry = 0,
    ssl_select_cert_error = -1,
}
extern "C" {
    pub fn SSL_early_callback_ctx_extension_get(
        client_hello: *const SSL_CLIENT_HELLO,
        extension_type: u16,
        out_data: *mut *const u8,
        out_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_select_certificate_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const SSL_CLIENT_HELLO) -> ssl_select_cert_result_t,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_dos_protection_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const SSL_CLIENT_HELLO) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_reverify_on_resume(ctx: *mut SSL_CTX, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_enforce_rsa_key_usage(ssl: *mut SSL, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_was_key_usage_invalid(ssl: *const SSL) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum OSSL_HANDSHAKE_STATE {
    TLS_ST_OK = 3,
    TLS_ST_BEFORE = 12288,
}
extern "C" {
    pub fn SSL_CTX_set_info_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *const SSL,
                type_: ::std::os::raw::c_int,
                value: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_get_info_callback(
        ctx: *mut SSL_CTX,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *const SSL,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn SSL_set_info_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *const SSL,
                type_: ::std::os::raw::c_int,
                value: ::std::os::raw::c_int,
            ),
        >,
    );
}
extern "C" {
    pub fn SSL_get_info_callback(
        ssl: *const SSL,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            ssl: *const SSL,
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
        ),
    >;
}
extern "C" {
    pub fn SSL_state_string_long(ssl: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_shutdown(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_peer_signature_algorithm(ssl: *const SSL) -> u16;
}
extern "C" {
    pub fn SSL_get_peer_signature_nid(
        ssl: *const SSL,
        psig_nid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_peer_signature_type_nid(
        ssl: *const SSL,
        psigtype_nid: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_client_random(ssl: *const SSL, out: *mut u8, max_out: usize) -> usize;
}
extern "C" {
    pub fn SSL_get_server_random(ssl: *const SSL, out: *mut u8, max_out: usize) -> usize;
}
extern "C" {
    pub fn SSL_get_pending_cipher(ssl: *const SSL) -> *const SSL_CIPHER;
}
extern "C" {
    pub fn SSL_set_retain_only_sha256_of_client_certs(ssl: *mut SSL, enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_set_retain_only_sha256_of_client_certs(
        ctx: *mut SSL_CTX,
        enable: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SSL_CTX_set_grease_enabled(ctx: *mut SSL_CTX, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_set_permute_extensions(ctx: *mut SSL_CTX, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_permute_extensions(ssl: *mut SSL, enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_max_seal_overhead(ssl: *const SSL) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set_false_start_allowed_without_alpn(
        ctx: *mut SSL_CTX,
        allowed: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn SSL_used_hello_retry_request(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_jdk11_workaround(ssl: *mut SSL, enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_sess_connect(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_connect_good(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_connect_renegotiate(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_accept(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_accept_renegotiate(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_accept_good(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_hits(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_cb_hits(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_misses(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_timeouts(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_sess_cache_full(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_library_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CIPHER_description(
        cipher: *const SSL_CIPHER,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CIPHER_get_version(cipher: *const SSL_CIPHER) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSLv23_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv23_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSLv23_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn TLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLS_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_server_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn DTLSv1_2_client_method() -> *const SSL_METHOD;
}
extern "C" {
    pub fn SSL_clear(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_cutthrough_complete(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_num_renegotiations(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_read_ahead(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_read_ahead(
        ctx: *mut SSL_CTX,
        yes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_read_ahead(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_read_ahead(ssl: *mut SSL, yes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_default_read_buffer_len(
        ctx: *mut SSL_CTX,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_default_read_buffer_len(ssl: *mut SSL, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn i2d_SSL_SESSION(in_: *mut SSL_SESSION, pp: *mut *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_SSL_SESSION(
        a: *mut *mut SSL_SESSION,
        pp: *mut *const u8,
        length: ::std::os::raw::c_long,
    ) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn i2d_SSL_SESSION_bio(bio: *mut BIO, session: *const SSL_SESSION)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d2i_SSL_SESSION_bio(bio: *mut BIO, out: *mut *mut SSL_SESSION) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_use_srtp(
        ctx: *mut SSL_CTX,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_use_srtp(
        ssl: *mut SSL,
        profiles: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_sigalgs(
        ctx: *mut SSL_CTX,
        values: *const ::std::os::raw::c_int,
        num_values: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_sigalgs(
        ssl: *mut SSL,
        values: *const ::std::os::raw::c_int,
        num_values: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_sigalgs_list(
        ctx: *mut SSL_CTX,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_sigalgs_list(
        ssl: *mut SSL,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_SESSION_print(bp: *mut BIO, sess: *const SSL_SESSION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_cache_hit(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_default_timeout(ssl: *const SSL) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_get_version(ssl: *const SSL) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_all_version_names(
        out: *mut *const ::std::os::raw::c_char,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_get_cipher_list(
        ssl: *const SSL,
        n: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_CTX_set_client_cert_cb(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                out_x509: *mut *mut X509,
                out_pkey: *mut *mut EVP_PKEY,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn SSL_want(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_finished(
        ssl: *const SSL,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_get_peer_finished(
        ssl: *const SSL,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_alert_type_string(value: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_alert_desc_string(value: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_state_string(ssl: *const SSL) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_conf_ctx_st {
    _unused: [u8; 0],
}
pub type SSL_CONF_CTX = ssl_conf_ctx_st;
extern "C" {
    pub fn SSL_state(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_shutdown(ssl: *mut SSL, mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_CTX_set_tmp_ecdh(ctx: *mut SSL_CTX, ec_key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tmp_ecdh(ssl: *mut SSL, ec_key: *const EC_KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_add_dir_cert_subjects_to_stack(
        out: *mut stack_st_X509_NAME,
        dir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_enable_tls_channel_id(ctx: *mut SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_enable_tls_channel_id(ssl: *mut SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BIO_f_ssl() -> *const BIO_METHOD;
}
extern "C" {
    pub fn BIO_set_ssl(
        bio: *mut BIO,
        ssl: *mut SSL,
        take_owership: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_get_session(ssl: *const SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn SSL_get1_session(ssl: *mut SSL) -> *mut SSL_SESSION;
}
extern "C" {
    pub fn OPENSSL_init_ssl(
        opts: u64,
        settings: *const OPENSSL_INIT_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_status_type(
        ssl: *mut SSL,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_tlsext_status_type(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tlsext_status_ocsp_resp(
        ssl: *mut SSL,
        resp: *mut u8,
        resp_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_tlsext_status_ocsp_resp(ssl: *const SSL, out: *mut *const u8) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_status_cb(
        ctx: *mut SSL_CTX,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                arg: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_get_tlsext_status_cb(
        ctx: *mut SSL_CTX,
        callback: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut SSL,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tlsext_status_arg(
        ctx: *mut SSL_CTX,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_get_curve_id(ssl: *const SSL) -> u16;
}
extern "C" {
    pub fn SSL_get_curve_name(curve_id: u16) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_all_curve_names(
        out: *mut *const ::std::os::raw::c_char,
        max_out: usize,
    ) -> usize;
}
extern "C" {
    pub fn SSL_CTX_set1_curves(
        ctx: *mut SSL_CTX,
        curves: *const ::std::os::raw::c_int,
        num_curves: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_curves(
        ssl: *mut SSL,
        curves: *const ::std::os::raw::c_int,
        num_curves: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set1_curves_list(
        ctx: *mut SSL_CTX,
        curves: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set1_curves_list(
        ssl: *mut SSL,
        curves: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type COMP_METHOD = ::std::os::raw::c_void;
pub type SSL_COMP = ssl_comp_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_SSL_COMP {
    _unused: [u8; 0],
}
extern "C" {
    pub fn SSL_COMP_get_compression_methods() -> *mut stack_st_SSL_COMP;
}
extern "C" {
    pub fn SSL_COMP_add_compression_method(
        id: ::std::os::raw::c_int,
        cm: *mut COMP_METHOD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_COMP_get_name(comp: *const COMP_METHOD) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_COMP_get0_name(comp: *const SSL_COMP) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_COMP_get_id(comp: *const SSL_COMP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_COMP_free_compression_methods();
}
extern "C" {
    pub fn SSL_get_current_compression(ssl: *mut SSL) -> *const COMP_METHOD;
}
extern "C" {
    pub fn SSL_get_current_expansion(ssl: *mut SSL) -> *const COMP_METHOD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_comp_st {
    pub id: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub method: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ssl_comp_st() {
    const UNINIT: ::std::mem::MaybeUninit<ssl_comp_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ssl_comp_st>(),
        24usize,
        concat!("Size of: ", stringify!(ssl_comp_st))
    );
    assert_eq!(
        ::std::mem::align_of::<ssl_comp_st>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_comp_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_comp_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_comp_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_comp_st),
            "::",
            stringify!(method)
        )
    );
}
pub type sk_SSL_COMP_free_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut SSL_COMP)>;
pub type sk_SSL_COMP_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const SSL_COMP) -> *mut SSL_COMP>;
pub type sk_SSL_COMP_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const SSL_COMP,
        arg2: *const *const SSL_COMP,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_SSL_COMP_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut SSL_COMP,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn SSL_get_server_tmp_key(
        ssl: *mut SSL,
        out_key: *mut *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tmp_dh(ctx: *mut SSL_CTX, dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tmp_dh(ssl: *mut SSL, dh: *const DH) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tmp_dh_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_dh_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut DH,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_set_dh_auto(
        ctx: *mut SSL_CTX,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SSL_CTX_get_security_level(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_security_level(ctx: *const SSL_CTX, level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_set_state(ssl: *mut SSL, state: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SSL_get_shared_ciphers(
        ssl: *const SSL,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SSL_get_shared_sigalgs(
        ssl: *mut SSL,
        idx: ::std::os::raw::c_int,
        psign: *mut ::std::os::raw::c_int,
        phash: *mut ::std::os::raw::c_int,
        psignandhash: *mut ::std::os::raw::c_int,
        rsig: *mut u8,
        rhash: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ERR_load_SSL_strings();
}
extern "C" {
    pub fn SSL_load_error_strings();
}
extern "C" {
    pub fn SSL_CTX_set_tmp_rsa_callback(
        ctx: *mut SSL_CTX,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut RSA,
        >,
    );
}
extern "C" {
    pub fn SSL_set_tmp_rsa_callback(
        ssl: *mut SSL,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                ssl: *mut SSL,
                is_export: ::std::os::raw::c_int,
                keylength: ::std::os::raw::c_int,
            ) -> *mut RSA,
        >,
    );
}
extern "C" {
    pub fn SSL_CTX_need_tmp_RSA(ctx: *const SSL_CTX) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_need_tmp_RSA(ssl: *const SSL) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_CTX_set_tmp_rsa(ctx: *mut SSL_CTX, rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SSL_set_tmp_rsa(ssl: *mut SSL, rsa: *const RSA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_posix_to_tm(time: i64, out_tm: *mut tm) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OPENSSL_tm_to_posix(tm: *const tm, out: *mut i64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_experiment_v1() -> *const TRUST_TOKEN_METHOD;
}
extern "C" {
    pub fn TRUST_TOKEN_experiment_v2_voprf() -> *const TRUST_TOKEN_METHOD;
}
extern "C" {
    pub fn TRUST_TOKEN_experiment_v2_pmb() -> *const TRUST_TOKEN_METHOD;
}
extern "C" {
    pub fn TRUST_TOKEN_pst_v1_voprf() -> *const TRUST_TOKEN_METHOD;
}
extern "C" {
    pub fn TRUST_TOKEN_pst_v1_pmb() -> *const TRUST_TOKEN_METHOD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trust_token_st {
    pub data: *mut u8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_trust_token_st() {
    const UNINIT: ::std::mem::MaybeUninit<trust_token_st> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<trust_token_st>(),
        16usize,
        concat!("Size of: ", stringify!(trust_token_st))
    );
    assert_eq!(
        ::std::mem::align_of::<trust_token_st>(),
        8usize,
        concat!("Alignment of ", stringify!(trust_token_st))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trust_token_st),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trust_token_st),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_TRUST_TOKEN {
    _unused: [u8; 0],
}
pub type sk_TRUST_TOKEN_free_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut TRUST_TOKEN)>;
pub type sk_TRUST_TOKEN_copy_func =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const TRUST_TOKEN) -> *mut TRUST_TOKEN>;
pub type sk_TRUST_TOKEN_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const *const TRUST_TOKEN,
        arg2: *const *const TRUST_TOKEN,
    ) -> ::std::os::raw::c_int,
>;
pub type sk_TRUST_TOKEN_delete_if_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut TRUST_TOKEN,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn TRUST_TOKEN_new(data: *const u8, len: usize) -> *mut TRUST_TOKEN;
}
extern "C" {
    pub fn TRUST_TOKEN_free(token: *mut TRUST_TOKEN);
}
extern "C" {
    pub fn TRUST_TOKEN_generate_key(
        method: *const TRUST_TOKEN_METHOD,
        out_priv_key: *mut u8,
        out_priv_key_len: *mut usize,
        max_priv_key_len: usize,
        out_pub_key: *mut u8,
        out_pub_key_len: *mut usize,
        max_pub_key_len: usize,
        id: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_derive_key_from_secret(
        method: *const TRUST_TOKEN_METHOD,
        out_priv_key: *mut u8,
        out_priv_key_len: *mut usize,
        max_priv_key_len: usize,
        out_pub_key: *mut u8,
        out_pub_key_len: *mut usize,
        max_pub_key_len: usize,
        id: u32,
        secret: *const u8,
        secret_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_new(
        method: *const TRUST_TOKEN_METHOD,
        max_batchsize: usize,
    ) -> *mut TRUST_TOKEN_CLIENT;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_free(ctx: *mut TRUST_TOKEN_CLIENT);
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_add_key(
        ctx: *mut TRUST_TOKEN_CLIENT,
        out_key_index: *mut usize,
        key: *const u8,
        key_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_set_srr_key(
        ctx: *mut TRUST_TOKEN_CLIENT,
        key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_begin_issuance(
        ctx: *mut TRUST_TOKEN_CLIENT,
        out: *mut *mut u8,
        out_len: *mut usize,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_begin_issuance_over_message(
        ctx: *mut TRUST_TOKEN_CLIENT,
        out: *mut *mut u8,
        out_len: *mut usize,
        count: usize,
        msg: *const u8,
        msg_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_finish_issuance(
        ctx: *mut TRUST_TOKEN_CLIENT,
        out_key_index: *mut usize,
        response: *const u8,
        response_len: usize,
    ) -> *mut stack_st_TRUST_TOKEN;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_begin_redemption(
        ctx: *mut TRUST_TOKEN_CLIENT,
        out: *mut *mut u8,
        out_len: *mut usize,
        token: *const TRUST_TOKEN,
        data: *const u8,
        data_len: usize,
        time: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_CLIENT_finish_redemption(
        ctx: *mut TRUST_TOKEN_CLIENT,
        out_rr: *mut *mut u8,
        out_rr_len: *mut usize,
        out_sig: *mut *mut u8,
        out_sig_len: *mut usize,
        response: *const u8,
        response_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_new(
        method: *const TRUST_TOKEN_METHOD,
        max_batchsize: usize,
    ) -> *mut TRUST_TOKEN_ISSUER;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_free(ctx: *mut TRUST_TOKEN_ISSUER);
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_add_key(
        ctx: *mut TRUST_TOKEN_ISSUER,
        key: *const u8,
        key_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_set_srr_key(
        ctx: *mut TRUST_TOKEN_ISSUER,
        key: *mut EVP_PKEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_set_metadata_key(
        ctx: *mut TRUST_TOKEN_ISSUER,
        key: *const u8,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_issue(
        ctx: *const TRUST_TOKEN_ISSUER,
        out: *mut *mut u8,
        out_len: *mut usize,
        out_tokens_issued: *mut usize,
        request: *const u8,
        request_len: usize,
        public_metadata: u32,
        private_metadata: u8,
        max_issuance: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_redeem(
        ctx: *const TRUST_TOKEN_ISSUER,
        out_public: *mut u32,
        out_private: *mut u8,
        out_token: *mut *mut TRUST_TOKEN,
        out_client_data: *mut *mut u8,
        out_client_data_len: *mut usize,
        request: *const u8,
        request_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_ISSUER_redeem_over_message(
        ctx: *const TRUST_TOKEN_ISSUER,
        out_public: *mut u32,
        out_private: *mut u8,
        out_token: *mut *mut TRUST_TOKEN,
        out_client_data: *mut *mut u8,
        out_client_data_len: *mut usize,
        request: *const u8,
        request_len: usize,
        msg: *const u8,
        msg_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TRUST_TOKEN_decode_private_metadata(
        method: *const TRUST_TOKEN_METHOD,
        out_value: *mut u8,
        key: *const u8,
        key_len: usize,
        nonce: *const u8,
        nonce_len: usize,
        encrypted_bit: u8,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CRYPTO_dynlock_value {
    pub _address: u8,
}
