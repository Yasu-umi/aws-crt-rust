/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const PRInSTR: &[u8; 5] = b"%.*s\0";
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140400;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const AWS_PACKAGE_SLOTS: u32 = 32;
pub const AWS_C_COMMON_PACKAGE_ID: u32 = 0;
pub const AWS_OP_SUCCESS: u32 = 0;
pub const AWS_OP_ERR: i32 = -1;
pub const AWS_ERROR_ENUM_STRIDE_BITS: u32 = 10;
pub const AWS_ERROR_ENUM_STRIDE: u32 = 1024;
pub const DYNAMIC_TARGETS_ENABLED: u32 = 0;
pub const TARGET_OS_MAC: u32 = 1;
pub const TARGET_OS_OSX: u32 = 1;
pub const TARGET_OS_IPHONE: u32 = 0;
pub const TARGET_OS_IOS: u32 = 0;
pub const TARGET_OS_WATCH: u32 = 0;
pub const TARGET_OS_TV: u32 = 0;
pub const TARGET_OS_MACCATALYST: u32 = 0;
pub const TARGET_OS_UIKITFORMAC: u32 = 0;
pub const TARGET_OS_SIMULATOR: u32 = 0;
pub const TARGET_OS_EMBEDDED: u32 = 0;
pub const TARGET_OS_UNIX: u32 = 0;
pub const TARGET_OS_RTKIT: u32 = 0;
pub const TARGET_RT_LITTLE_ENDIAN: u32 = 1;
pub const TARGET_RT_BIG_ENDIAN: u32 = 0;
pub const TARGET_RT_64_BIT: u32 = 1;
pub const TARGET_RT_MAC_CFM: u32 = 0;
pub const TARGET_RT_MAC_MACHO: u32 = 1;
pub const TARGET_CPU_ARM64: u32 = 1;
pub const TARGET_OS_VISION: u32 = 0;
pub const TARGET_OS_DRIVERKIT: u32 = 0;
pub const TARGET_OS_WIN32: u32 = 0;
pub const TARGET_OS_WINDOWS: u32 = 0;
pub const TARGET_OS_LINUX: u32 = 0;
pub const TARGET_CPU_PPC: u32 = 0;
pub const TARGET_CPU_PPC64: u32 = 0;
pub const TARGET_CPU_68K: u32 = 0;
pub const TARGET_CPU_X86: u32 = 0;
pub const TARGET_CPU_X86_64: u32 = 0;
pub const TARGET_CPU_ARM: u32 = 0;
pub const TARGET_CPU_MIPS: u32 = 0;
pub const TARGET_CPU_SPARC: u32 = 0;
pub const TARGET_CPU_ALPHA: u32 = 0;
pub const TARGET_IPHONE_SIMULATOR: u32 = 0;
pub const TARGET_OS_NANO: u32 = 0;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const SIZE_BITS: u32 = 64;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const SO_RESOLVER_SIGNATURE: u32 = 4401;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const AWS_C_IO_PACKAGE_ID: u32 = 1;
pub const AWS_PATH_DELIM: u8 = 47u8;
pub const AWS_PATH_DELIM_STR: &[u8; 2] = b"/\0";
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const TIME_UTC: u32 = 1;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const AWS_THREAD_NAME_RECOMMENDED_STRLEN: u32 = 15;
pub const AWS_LOG_LEVEL_NONE: u32 = 0;
pub const AWS_LOG_LEVEL_FATAL: u32 = 1;
pub const AWS_LOG_LEVEL_ERROR: u32 = 2;
pub const AWS_LOG_LEVEL_WARN: u32 = 3;
pub const AWS_LOG_LEVEL_INFO: u32 = 4;
pub const AWS_LOG_LEVEL_DEBUG: u32 = 5;
pub const AWS_LOG_LEVEL_TRACE: u32 = 6;
pub const AWS_NETWORK_INTERFACE_NAME_MAX: u32 = 16;
pub const SOL_LOCAL: u32 = 0;
pub const LOCAL_PEERCRED: u32 = 1;
pub const LOCAL_PEERPID: u32 = 2;
pub const LOCAL_PEEREPID: u32 = 3;
pub const LOCAL_PEERUUID: u32 = 4;
pub const LOCAL_PEEREUUID: u32 = 5;
pub const LOCAL_PEERTOKEN: u32 = 6;
pub const AWS_TLS_NEGOTIATED_PROTOCOL_MESSAGE: u32 = 1;
pub type static_assertion_at_line_60 = [::std::os::raw::c_char; 1usize];
pub type static_assertion_at_line_61 = [::std::os::raw::c_char; 1usize];
pub type static_assertion_at_line_62 = [::std::os::raw::c_char; 1usize];
pub const AWS_CACHE_LINE: _bindgen_ty_1 = _bindgen_ty_1::AWS_CACHE_LINE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    AWS_CACHE_LINE = 64,
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_fatal_assert(
        cond_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> !;
}
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_reserved: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_secure_time_in_system) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_time_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_secure_ptime_in_system) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_secure_ptime_in_system)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
#[doc = " @deprecated Use int64_t instead for offsets in public APIs."]
pub type aws_off_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_allocator {
    pub mem_acquire: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_release: ::std::option::Option<
        unsafe extern "C" fn(allocator: *mut aws_allocator, ptr: *mut ::std::os::raw::c_void),
    >,
    pub mem_realloc: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            oldptr: *mut ::std::os::raw::c_void,
            oldsize: usize,
            newsize: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub mem_calloc: ::std::option::Option<
        unsafe extern "C" fn(
            allocator: *mut aws_allocator,
            num: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_allocator() {
    const UNINIT: ::std::mem::MaybeUninit<aws_allocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_allocator>(),
        40usize,
        concat!("Size of: ", stringify!(aws_allocator))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_allocator>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_allocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_acquire) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_acquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_release) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_realloc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_calloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(mem_calloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_allocator),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Inexpensive (constant time) check of data-structure invariants."]
    pub fn aws_allocator_is_valid(alloc: *const aws_allocator) -> bool;
}
extern "C" {
    pub fn aws_default_allocator() -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_aligned_allocator() -> *mut aws_allocator;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __CFAllocator {
    _unused: [u8; 0],
}
pub type CFAllocatorRef = *const __CFAllocator;
extern "C" {
    #[doc = " Wraps a CFAllocator around aws_allocator. For Mac only. Use this anytime you need a CFAllocatorRef for interacting\n with Apple Frameworks. Unfortunately, it allocates memory so we can't make it static file scope, be sure to call\n aws_wrapped_cf_allocator_destroy when finished."]
    pub fn aws_wrapped_cf_allocator_new(allocator: *mut aws_allocator) -> CFAllocatorRef;
}
extern "C" {
    #[doc = " Cleans up any resources alloced in aws_wrapped_cf_allocator_new."]
    pub fn aws_wrapped_cf_allocator_destroy(allocator: CFAllocatorRef);
}
extern "C" {
    #[doc = " Returns at least `size` of memory ready for usage. In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_acquire(
        allocator: *mut aws_allocator,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocates a block of memory for an array of num elements, each of them size bytes long, and initializes all its bits\n to zero. In versions v0.6.8 and prior, this function was allowed to return NULL.\n In later versions, if allocator->mem_calloc() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_calloc() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_calloc(
        allocator: *mut aws_allocator,
        num: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocates many chunks of bytes into a single block. Expects to be called with alternating void ** (dest), size_t\n (size). The first void ** will be set to the root of the allocation. Alignment is assumed to be sizeof(intmax_t).\n\n This is useful for allocating structs using the pimpl pattern, as you may allocate the public object and impl object\n in the same contiguous block of memory.\n\n Returns a pointer to the allocation.\n\n In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_acquire() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_acquire() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_acquire_many(
        allocator: *mut aws_allocator,
        count: usize,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Releases ptr back to whatever allocated it.\n Nothing happens if ptr is NULL."]
    pub fn aws_mem_release(allocator: *mut aws_allocator, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Attempts to adjust the size of the pointed-to memory buffer from oldsize to\n newsize. The pointer (*ptr) may be changed if the memory needs to be\n reallocated.\n\n In versions v0.6.8 and prior, this function was allowed to return\n NULL. In later versions, if allocator->mem_realloc() returns NULL, this function will assert and exit. To handle\n conditions where OOM is not a fatal error, allocator->mem_realloc() is responsible for finding/reclaiming/running a\n GC etc...before returning."]
    pub fn aws_mem_realloc(
        allocator: *mut aws_allocator,
        ptr: *mut *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_mem_trace_level {
    AWS_MEMTRACE_NONE = 0,
    AWS_MEMTRACE_BYTES = 1,
    AWS_MEMTRACE_STACKS = 2,
}
extern "C" {
    pub fn aws_mem_tracer_new(
        allocator: *mut aws_allocator,
        deprecated: *mut aws_allocator,
        level: aws_mem_trace_level,
        frames_per_stack: usize,
    ) -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_mem_tracer_destroy(trace_allocator: *mut aws_allocator) -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_mem_tracer_dump(trace_allocator: *mut aws_allocator);
}
extern "C" {
    pub fn aws_mem_tracer_bytes(trace_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_mem_tracer_count(trace_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_new(
        allocator: *mut aws_allocator,
        multi_threaded: bool,
    ) -> *mut aws_allocator;
}
extern "C" {
    pub fn aws_small_block_allocator_destroy(sba_allocator: *mut aws_allocator);
}
extern "C" {
    pub fn aws_small_block_allocator_bytes_active(sba_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_bytes_reserved(sba_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_page_size(sba_allocator: *mut aws_allocator) -> usize;
}
extern "C" {
    pub fn aws_small_block_allocator_page_size_available(
        sba_allocator: *mut aws_allocator,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_error_info {
    pub error_code: ::std::os::raw::c_int,
    pub literal_name: *const ::std::os::raw::c_char,
    pub error_str: *const ::std::os::raw::c_char,
    pub lib_name: *const ::std::os::raw::c_char,
    pub formatted_name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aws_error_info() {
    const UNINIT: ::std::mem::MaybeUninit<aws_error_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_error_info>(),
        40usize,
        concat!("Size of: ", stringify!(aws_error_info))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_error_info>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_error_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).literal_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(literal_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_str) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(error_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lib_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(lib_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatted_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info),
            "::",
            stringify!(formatted_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_error_info_list {
    pub error_list: *const aws_error_info,
    pub count: u16,
}
#[test]
fn bindgen_test_layout_aws_error_info_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_error_info_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_error_info_list>(),
        16usize,
        concat!("Size of: ", stringify!(aws_error_info_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_error_info_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_error_info_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info_list),
            "::",
            stringify!(error_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_error_info_list),
            "::",
            stringify!(count)
        )
    );
}
pub type aws_error_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(err: ::std::os::raw::c_int, ctx: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn aws_last_error() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_error_str(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_error_name(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_error_lib_name(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_error_debug_str(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn aws_raise_error_private(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn aws_reset_error();
}
extern "C" {
    pub fn aws_restore_error(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn aws_set_global_error_handler_fn(
        handler: aws_error_handler_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> aws_error_handler_fn;
}
extern "C" {
    pub fn aws_set_thread_local_error_handler_fn(
        handler: aws_error_handler_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> aws_error_handler_fn;
}
extern "C" {
    #[doc = " TODO: this needs to be a private function (wait till we have the cmake story\n better before moving it though). It should be external for the purpose of\n other libs we own, but customers should not be able to hit it without going\n out of their way to do so."]
    pub fn aws_register_error_info(error_info: *const aws_error_info_list);
}
extern "C" {
    pub fn aws_unregister_error_info(error_info: *const aws_error_info_list);
}
extern "C" {
    #[doc = " Convert a c library io error into an aws error, and raise it.\n If no conversion is found, fallback_aws_error_code is raised.\n Always returns AWS_OP_ERR."]
    pub fn aws_translate_and_raise_io_error_or(
        error_no: ::std::os::raw::c_int,
        fallback_aws_error_code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a c library io error into an aws error, and raise it.\n If no conversion is found, AWS_ERROR_SYS_CALL_FAILURE is raised.\n Always returns AWS_OP_ERR."]
    pub fn aws_translate_and_raise_io_error(
        error_no: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_common_error {
    AWS_ERROR_SUCCESS = 0,
    AWS_ERROR_OOM = 1,
    AWS_ERROR_NO_SPACE = 2,
    AWS_ERROR_UNKNOWN = 3,
    AWS_ERROR_SHORT_BUFFER = 4,
    AWS_ERROR_OVERFLOW_DETECTED = 5,
    AWS_ERROR_UNSUPPORTED_OPERATION = 6,
    AWS_ERROR_INVALID_BUFFER_SIZE = 7,
    AWS_ERROR_INVALID_HEX_STR = 8,
    AWS_ERROR_INVALID_BASE64_STR = 9,
    AWS_ERROR_INVALID_INDEX = 10,
    AWS_ERROR_THREAD_INVALID_SETTINGS = 11,
    AWS_ERROR_THREAD_INSUFFICIENT_RESOURCE = 12,
    AWS_ERROR_THREAD_NO_PERMISSIONS = 13,
    AWS_ERROR_THREAD_NOT_JOINABLE = 14,
    AWS_ERROR_THREAD_NO_SUCH_THREAD_ID = 15,
    AWS_ERROR_THREAD_DEADLOCK_DETECTED = 16,
    AWS_ERROR_MUTEX_NOT_INIT = 17,
    AWS_ERROR_MUTEX_TIMEOUT = 18,
    AWS_ERROR_MUTEX_CALLER_NOT_OWNER = 19,
    AWS_ERROR_MUTEX_FAILED = 20,
    AWS_ERROR_COND_VARIABLE_INIT_FAILED = 21,
    AWS_ERROR_COND_VARIABLE_TIMED_OUT = 22,
    AWS_ERROR_COND_VARIABLE_ERROR_UNKNOWN = 23,
    AWS_ERROR_CLOCK_FAILURE = 24,
    AWS_ERROR_LIST_EMPTY = 25,
    AWS_ERROR_DEST_COPY_TOO_SMALL = 26,
    AWS_ERROR_LIST_EXCEEDS_MAX_SIZE = 27,
    AWS_ERROR_LIST_STATIC_MODE_CANT_SHRINK = 28,
    AWS_ERROR_PRIORITY_QUEUE_FULL = 29,
    AWS_ERROR_PRIORITY_QUEUE_EMPTY = 30,
    AWS_ERROR_PRIORITY_QUEUE_BAD_NODE = 31,
    AWS_ERROR_HASHTBL_ITEM_NOT_FOUND = 32,
    AWS_ERROR_INVALID_DATE_STR = 33,
    AWS_ERROR_INVALID_ARGUMENT = 34,
    AWS_ERROR_RANDOM_GEN_FAILED = 35,
    AWS_ERROR_MALFORMED_INPUT_STRING = 36,
    AWS_ERROR_UNIMPLEMENTED = 37,
    AWS_ERROR_INVALID_STATE = 38,
    AWS_ERROR_ENVIRONMENT_GET = 39,
    AWS_ERROR_ENVIRONMENT_SET = 40,
    AWS_ERROR_ENVIRONMENT_UNSET = 41,
    AWS_ERROR_STREAM_UNSEEKABLE = 42,
    AWS_ERROR_NO_PERMISSION = 43,
    AWS_ERROR_FILE_INVALID_PATH = 44,
    AWS_ERROR_MAX_FDS_EXCEEDED = 45,
    AWS_ERROR_SYS_CALL_FAILURE = 46,
    AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED = 47,
    AWS_ERROR_STRING_MATCH_NOT_FOUND = 48,
    AWS_ERROR_DIVIDE_BY_ZERO = 49,
    AWS_ERROR_INVALID_FILE_HANDLE = 50,
    AWS_ERROR_OPERATION_INTERUPTED = 51,
    AWS_ERROR_DIRECTORY_NOT_EMPTY = 52,
    AWS_ERROR_PLATFORM_NOT_SUPPORTED = 53,
    AWS_ERROR_INVALID_UTF8 = 54,
    AWS_ERROR_GET_HOME_DIRECTORY_FAILED = 55,
    AWS_ERROR_INVALID_XML = 56,
    AWS_ERROR_FILE_OPEN_FAILURE = 57,
    AWS_ERROR_FILE_READ_FAILURE = 58,
    AWS_ERROR_FILE_WRITE_FAILURE = 59,
    AWS_ERROR_INVALID_CBOR = 60,
    AWS_ERROR_CBOR_UNEXPECTED_TYPE = 61,
    AWS_ERROR_END_COMMON_RANGE = 1023,
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Securely zeroes a memory buffer. This function will attempt to ensure that\n the compiler will not optimize away this zeroing operation."]
    pub fn aws_secure_zero(pBuf: *mut ::std::os::raw::c_void, bufsize: usize);
}
extern "C" {
    #[doc = " Initializes internal data structures used by aws-c-common.\n Must be called before using any functionality in aws-c-common."]
    pub fn aws_common_library_init(allocator: *mut aws_allocator);
}
extern "C" {
    #[doc = " Shuts down the internal data structures used by aws-c-common."]
    pub fn aws_common_library_clean_up();
}
extern "C" {
    pub fn aws_common_fatal_assert_library_initialized();
}
extern "C" {
    #[doc = " Adds [num] arguments (expected to be of size_t), and returns the result in *r.\n If the result overflows, returns AWS_OP_ERR; otherwise returns AWS_OP_SUCCESS."]
    pub fn aws_add_size_checked_varargs(num: usize, r: *mut usize, ...) -> ::std::os::raw::c_int;
}
pub const AWS_ARRAY_LIST_DEBUG_FILL: _bindgen_ty_2 = _bindgen_ty_2::AWS_ARRAY_LIST_DEBUG_FILL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    AWS_ARRAY_LIST_DEBUG_FILL = 221,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_array_list {
    pub alloc: *mut aws_allocator,
    pub current_size: usize,
    pub length: usize,
    pub item_size: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_array_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_array_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_array_list>(),
        40usize,
        concat!("Size of: ", stringify!(aws_array_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_array_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_array_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(current_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(item_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_array_list),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Prototype for a comparator function for sorting elements.\n\n a and b should be cast to pointers to the element type held in the list\n before being dereferenced. The function should compare the elements and\n return a positive number if a > b, zero if a = b, and a negative number\n if a < b."]
pub type aws_array_list_comparator_fn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " If in dynamic mode, shrinks the allocated array size to the minimum amount necessary to store its elements."]
    pub fn aws_array_list_shrink_to_fit(list: *mut aws_array_list) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the elements from from to to. If to is in static mode, it must at least be the same length as from. Any data\n in to will be overwritten in this copy."]
    pub fn aws_array_list_copy(
        from: *const aws_array_list,
        to: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Ensures that the array list has enough capacity to store a value at the specified index. If there is not already\n enough capacity, and the list is in dynamic mode, this function will attempt to allocate more memory, expanding the\n list. In static mode, if 'index' is beyond the maximum index, AWS_ERROR_INVALID_INDEX will be raised."]
    pub fn aws_array_list_ensure_capacity(
        list: *mut aws_array_list,
        index: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Swap elements at the specified indices, which must be within the bounds of the array."]
    pub fn aws_array_list_swap(list: *mut aws_array_list, a: usize, b: usize);
}
extern "C" {
    #[doc = " Sort elements in the list in-place according to the comparator function."]
    pub fn aws_array_list_sort(list: *mut aws_array_list, compare_fn: aws_array_list_comparator_fn);
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    const UNINIT: ::std::mem::MaybeUninit<sa_endpoints> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcif) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddrlen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    const UNINIT: ::std::mem::MaybeUninit<so_np_extensions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sockaddr_header {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
}
#[test]
fn bindgen_test_layout___sockaddr_header() {
    const UNINIT: ::std::mem::MaybeUninit<__sockaddr_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sockaddr_header>(),
        2usize,
        concat!("Size of: ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        ::std::mem::align_of::<__sockaddr_header>(),
        1usize,
        concat!("Alignment of ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_family)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    const UNINIT: ::std::mem::MaybeUninit<sockproto> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_protocol) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    const UNINIT: ::std::mem::MaybeUninit<sf_hdtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trl_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    const UNINIT: ::std::mem::MaybeUninit<__msfilterreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_fmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_nsrcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_nsrcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__msfr_align) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(__msfr_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_srcs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_srcs)
        )
    );
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in6_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_mtuinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Represents a length-delimited binary string or buffer. If byte buffer points\n to constant memory or memory that should otherwise not be freed by this\n struct, set allocator to NULL and free function will be a no-op.\n\n This structure used to define the output for all functions that write to a buffer.\n\n Note that this structure allocates memory at the buffer pointer only. The\n struct itself does not get dynamically allocated and must be either\n maintained or copied to avoid losing access to the memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_byte_buf {
    pub len: usize,
    pub buffer: *mut u8,
    pub capacity: usize,
    pub allocator: *mut aws_allocator,
}
#[test]
fn bindgen_test_layout_aws_byte_buf() {
    const UNINIT: ::std::mem::MaybeUninit<aws_byte_buf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_byte_buf>(),
        32usize,
        concat!("Size of: ", stringify!(aws_byte_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_byte_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_byte_buf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_buf),
            "::",
            stringify!(allocator)
        )
    );
}
#[doc = " Represents a movable pointer within a larger binary string or buffer.\n\n This structure is used to define buffers for reading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_byte_cursor {
    pub len: usize,
    pub ptr: *mut u8,
}
#[test]
fn bindgen_test_layout_aws_byte_cursor() {
    const UNINIT: ::std::mem::MaybeUninit<aws_byte_cursor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_byte_cursor>(),
        16usize,
        concat!("Size of: ", stringify!(aws_byte_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_byte_cursor>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_byte_cursor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_cursor),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_byte_cursor),
            "::",
            stringify!(ptr)
        )
    );
}
#[doc = " Signature for function argument to trim APIs"]
pub type aws_byte_predicate_fn = ::std::option::Option<unsafe extern "C" fn(value: u8) -> bool>;
extern "C" {
    #[doc = " Compare two arrays.\n Return whether their contents are equivalent.\n NULL may be passed as the array pointer if its length is declared to be 0."]
    pub fn aws_array_eq(
        array_a: *const ::std::os::raw::c_void,
        len_a: usize,
        array_b: *const ::std::os::raw::c_void,
        len_b: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of two arrays.\n Return whether their contents are equivalent.\n NULL may be passed as the array pointer if its length is declared to be 0.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_array_eq_ignore_case(
        array_a: *const ::std::os::raw::c_void,
        len_a: usize,
        array_b: *const ::std::os::raw::c_void,
        len_b: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Compare an array and a null-terminated string.\n Returns true if their contents are equivalent.\n The array should NOT contain a null-terminator, or the comparison will always return false.\n NULL may be passed as the array pointer if its length is declared to be 0."]
    pub fn aws_array_eq_c_str(
        array: *const ::std::os::raw::c_void,
        array_len: usize,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an array and a null-terminated string.\n Return whether their contents are equivalent.\n The array should NOT contain a null-terminator, or the comparison will always return false.\n NULL may be passed as the array pointer if its length is declared to be 0.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_array_eq_c_str_ignore_case(
        array: *const ::std::os::raw::c_void,
        array_len: usize,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn aws_byte_buf_init(
        buf: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes an aws_byte_buf structure base on another valid one.\n Requires: *src and *allocator are valid objects.\n Ensures: *dest is a valid aws_byte_buf with a new backing array dest->buffer\n which is a copy of the elements from src->buffer."]
    pub fn aws_byte_buf_init_copy(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        src: *const aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads 'filename' into 'out_buf'. If successful, 'out_buf' is allocated and filled with the data;\n It is your responsibility to call 'aws_byte_buf_clean_up()' on it. Otherwise, 'out_buf' remains\n unused. In the very unfortunate case where some API needs to treat out_buf as a c_string, a null terminator\n is appended, but is not included as part of the length field."]
    pub fn aws_byte_buf_init_from_file(
        out_buf: *mut aws_byte_buf,
        alloc: *mut aws_allocator,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as aws_byte_buf_init_from_file(), but for reading \"special files\" like /proc/cpuinfo.\n These files don't accurately report their size, so size_hint is used as initial buffer size,\n and the buffer grows until the while file is read."]
    pub fn aws_byte_buf_init_from_file_with_size_hint(
        out_buf: *mut aws_byte_buf,
        alloc: *mut aws_allocator,
        filename: *const ::std::os::raw::c_char,
        size_hint: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Evaluates the set of properties that define the shape of all valid aws_byte_buf structures.\n It is also a cheap check, in the sense it run in constant time (i.e., no loops or recursion)."]
    pub fn aws_byte_buf_is_valid(buf: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Evaluates the set of properties that define the shape of all valid aws_byte_cursor structures.\n It is also a cheap check, in the sense it runs in constant time (i.e., no loops or recursion)."]
    pub fn aws_byte_cursor_is_valid(cursor: *const aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Copies src buffer into dest and sets the correct len and capacity.\n A new memory zone is allocated for dest->buffer. When dest is no longer needed it will have to be cleaned-up using\n aws_byte_buf_clean_up(dest).\n Dest capacity and len will be equal to the src len. Allocator of the dest will be identical with parameter allocator.\n If src buffer is null the dest will have a null buffer with a len and a capacity of 0\n Returns AWS_OP_SUCCESS in case of success or AWS_OP_ERR when memory can't be allocated."]
    pub fn aws_byte_buf_init_copy_from_cursor(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        src: aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Init buffer with contents of multiple cursors, and update cursors to reference the memory stored in the buffer.\n Each cursor arg must be an `struct aws_byte_cursor *`. NULL must be passed as the final arg.\n NOTE: Do not append/grow/resize buffers initialized this way, or the cursors will end up referencing invalid memory.\n Returns AWS_OP_SUCCESS in case of success.\n AWS_OP_ERR is returned if memory can't be allocated or the total cursor length exceeds SIZE_MAX."]
    pub fn aws_byte_buf_init_cache_and_update_cursors(
        dest: *mut aws_byte_buf,
        allocator: *mut aws_allocator,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_byte_buf_clean_up(buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Equivalent to calling aws_byte_buf_secure_zero and then aws_byte_buf_clean_up\n on the buffer."]
    pub fn aws_byte_buf_clean_up_secure(buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Resets the len of the buffer to 0, but does not free the memory. The buffer can then be reused.\n Optionally zeroes the contents, if the \"zero_contents\" flag is true."]
    pub fn aws_byte_buf_reset(buf: *mut aws_byte_buf, zero_contents: bool);
}
extern "C" {
    #[doc = " Sets all bytes of buffer to zero and resets len to zero."]
    pub fn aws_byte_buf_secure_zero(buf: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Compare two aws_byte_buf structures.\n Return whether their contents are equivalent."]
    pub fn aws_byte_buf_eq(a: *const aws_byte_buf, b: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of two aws_byte_buf structures.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_buf_eq_ignore_case(a: *const aws_byte_buf, b: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Compare an aws_byte_buf and a null-terminated string.\n Returns true if their contents are equivalent.\n The buffer should NOT contain a null-terminator, or the comparison will always return false."]
    pub fn aws_byte_buf_eq_c_str(
        buf: *const aws_byte_buf,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_buf and a null-terminated string.\n Return whether their contents are equivalent.\n The buffer should NOT contain a null-terminator, or the comparison will always return false.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_buf_eq_c_str_ignore_case(
        buf: *const aws_byte_buf,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " No copies, no buffer allocations. Iterates over input_str, and returns the\n next substring between split_on instances relative to previous substr.\n Behaves similar to strtok with substr being used as state for next split.\n\n Returns true each time substr is set and false when there is no more splits\n (substr is set to empty in that case).\n\n Example usage.\n struct aws_byte_cursor substr = {0};\n while (aws_byte_cursor_next_split(&input_str, ';', &substr)) {\n   // ...use substr...\n }\n\n Note: It is the user's responsibility zero-initialize substr before the first call.\n\n Edge case rules are as follows:\n empty input will have single empty split. ex. \"\" splits into \"\"\n if input starts with split_on then first split is empty. ex \";A\" splits into \"\", \"A\"\n adjacent split tokens result in empty split. ex \"A;;B\" splits into \"A\", \"\", \"B\"\n If the input ends with split_on, last split is empty. ex. \"A;\" splits into \"A\", \"\"\n\n It is the user's responsibility to make sure the input buffer stays in memory\n long enough to use the results."]
    pub fn aws_byte_cursor_next_split(
        input_str: *const aws_byte_cursor,
        split_on: ::std::os::raw::c_char,
        substr: *mut aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " No copies, no buffer allocations. Fills in output with a list of\n aws_byte_cursor instances where buffer is an offset into the input_str and\n len is the length of that string in the original buffer.\n\n Edge case rules are as follows:\n if the input begins with split_on, an empty cursor will be the first entry in\n output. if the input has two adjacent split_on tokens, an empty cursor will\n be inserted into the output. if the input ends with split_on, an empty cursor\n will be appended to the output.\n\n It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from\n output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\n The type that will be stored in output is struct aws_byte_cursor (you'll need\n this for the item size param).\n\n It is the user's responsibility to make sure the input buffer stays in memory\n long enough to use the results."]
    pub fn aws_byte_cursor_split_on_char(
        input_str: *const aws_byte_cursor,
        split_on: ::std::os::raw::c_char,
        output: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " No copies, no buffer allocations. Fills in output with a list of aws_byte_cursor instances where buffer is\n an offset into the input_str and len is the length of that string in the original buffer. N is the max number of\n splits, if this value is zero, it will add all splits to the output.\n\n Edge case rules are as follows:\n if the input begins with split_on, an empty cursor will be the first entry in output\n if the input has two adjacent split_on tokens, an empty cursor will be inserted into the output.\n if the input ends with split_on, an empty cursor will be appended to the output.\n\n It is the user's responsibility to properly initialize output. Recommended number of preallocated elements from\n output is your most likely guess for the upper bound of the number of elements resulting from the split.\n\n If the output array is not large enough, input_str will be updated to point to the first character after the last\n processed split_on instance.\n\n The type that will be stored in output is struct aws_byte_cursor (you'll need this for the item size param).\n\n It is the user's responsibility to make sure the input buffer stays in memory long enough to use the results."]
    pub fn aws_byte_cursor_split_on_char_n(
        input_str: *const aws_byte_cursor,
        split_on: ::std::os::raw::c_char,
        n: usize,
        output: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Search for an exact byte match inside a cursor. The first match will be returned. Returns AWS_OP_SUCCESS\n on successful match and first_find will be set to the offset in input_str, and length will be the remaining length\n from input_str past the returned offset. If the match was not found, AWS_OP_ERR will be returned and\n AWS_ERROR_STRING_MATCH_NOT_FOUND will be raised."]
    pub fn aws_byte_cursor_find_exact(
        input_str: *const aws_byte_cursor,
        to_find: *const aws_byte_cursor,
        first_find: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shrinks a byte cursor from the right for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_right_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Shrinks a byte cursor from the left for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_left_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Shrinks a byte cursor from both sides for as long as the supplied predicate is true"]
    pub fn aws_byte_cursor_trim_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns true if the byte cursor's range of bytes all satisfy the predicate"]
    pub fn aws_byte_cursor_satisfies_pred(
        source: *const aws_byte_cursor,
        predicate: aws_byte_predicate_fn,
    ) -> bool;
}
extern "C" {
    #[doc = " Copies from to to. If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be\n returned. dest->len will contain the amount of data actually copied to dest.\n\n from and to may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies from to to while converting bytes via the passed in lookup table.\n If to is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be\n returned. to->len will contain its original size plus the amount of data actually copied to to.\n\n from and to should not be the same buffer (overlap is not handled)\n lookup_table must be at least 256 bytes"]
    pub fn aws_byte_buf_append_with_lookup(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
        lookup_table: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies from to to. If to is too small, the buffer will be grown appropriately and\n the old contents copied to, before the new contents are appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n from and to may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append_dynamic(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies `from` to `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the new contents are appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n If the buffer is grown, the old buffer will be securely cleared before getting freed.\n\n `from` and `to` may be the same buffer, permitting copying a buffer into itself."]
    pub fn aws_byte_buf_append_dynamic_secure(
        to: *mut aws_byte_buf,
        from: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the byte is appended.\n\n If the grow fails (overflow or OOM), then an error will be returned."]
    pub fn aws_byte_buf_append_byte_dynamic(
        buffer: *mut aws_byte_buf,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies a single byte into `to`. If `to` is too small, the buffer will be grown appropriately and\n the old contents copied over, before the byte is appended.\n\n If the grow fails (overflow or OOM), then an error will be returned.\n\n If the buffer is grown, the old buffer will be securely cleared before getting freed."]
    pub fn aws_byte_buf_append_byte_dynamic_secure(
        buffer: *mut aws_byte_buf,
        value: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy contents of cursor to buffer, then update cursor to reference the memory stored in the buffer.\n If buffer is too small, AWS_ERROR_DEST_COPY_TOO_SMALL will be returned.\n\n The cursor is permitted to reference memory from earlier in the buffer."]
    pub fn aws_byte_buf_append_and_update(
        to: *mut aws_byte_buf,
        from_and_update: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Appends '\\0' at the end of the buffer."]
    pub fn aws_byte_buf_append_null_terminator(buf: *mut aws_byte_buf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to increase the capacity of a buffer to the requested capacity\n\n If the the buffer's capacity is currently larger than the request capacity, the\n function does nothing (no shrink is performed)."]
    pub fn aws_byte_buf_reserve(
        buffer: *mut aws_byte_buf,
        requested_capacity: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function that attempts to increase the capacity of a buffer relative to the current\n length.\n\n  aws_byte_buf_reserve_relative(buf, x) ~~ aws_byte_buf_reserve(buf, buf->len + x)\n"]
    pub fn aws_byte_buf_reserve_relative(
        buffer: *mut aws_byte_buf,
        additional_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Concatenates a variable number of struct aws_byte_buf * into destination.\n Number of args must be greater than 1. If dest is too small,\n AWS_ERROR_DEST_COPY_TOO_SMALL will be returned. dest->len will contain the\n amount of data actually copied to dest."]
    pub fn aws_byte_buf_cat(
        dest: *mut aws_byte_buf,
        number_of_args: usize,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two aws_byte_cursor structures.\n Return whether their contents are equivalent."]
    pub fn aws_byte_cursor_eq(a: *const aws_byte_cursor, b: *const aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of two aws_byte_cursor structures.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_ignore_case(
        a: *const aws_byte_cursor,
        b: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Compare an aws_byte_cursor and an aws_byte_buf.\n Return whether their contents are equivalent."]
    pub fn aws_byte_cursor_eq_byte_buf(a: *const aws_byte_cursor, b: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_cursor and an aws_byte_buf.\n Return whether their contents are equivalent.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_byte_buf_ignore_case(
        a: *const aws_byte_cursor,
        b: *const aws_byte_buf,
    ) -> bool;
}
extern "C" {
    #[doc = " Compare an aws_byte_cursor and a null-terminated string.\n Returns true if their contents are equivalent.\n The cursor should NOT contain a null-terminator, or the comparison will always return false."]
    pub fn aws_byte_cursor_eq_c_str(
        cursor: *const aws_byte_cursor,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Perform a case-insensitive string comparison of an aws_byte_cursor and a null-terminated string.\n Return whether their contents are equivalent.\n The cursor should NOT contain a null-terminator, or the comparison will always return false.\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_eq_c_str_ignore_case(
        cursor: *const aws_byte_cursor,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the input starts with the prefix (exact byte comparison)."]
    pub fn aws_byte_cursor_starts_with(
        input: *const aws_byte_cursor,
        prefix: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the input starts with the prefix (case-insensitive).\n The \"C\" locale is used for comparing upper and lowercase letters.\n Data is assumed to be ASCII text, UTF-8 will work fine too."]
    pub fn aws_byte_cursor_starts_with_ignore_case(
        input: *const aws_byte_cursor,
        prefix: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Case-insensitive hash function for array containing ASCII or UTF-8 text."]
    pub fn aws_hash_array_ignore_case(array: *const ::std::os::raw::c_void, len: usize) -> u64;
}
extern "C" {
    #[doc = " Case-insensitive hash function for aws_byte_cursors stored in an aws_hash_table.\n For case-sensitive hashing, use aws_hash_byte_cursor_ptr()."]
    pub fn aws_hash_byte_cursor_ptr_ignore_case(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Returns a lookup table for bytes that is the identity transformation with the exception\n of uppercase ascii characters getting replaced with lowercase characters.  Used in\n caseless comparisons."]
    pub fn aws_lookup_table_to_lower_get() -> *const u8;
}
extern "C" {
    #[doc = " Returns lookup table to go from ASCII/UTF-8 hex character to a number (0-15).\n Non-hex characters map to 255.\n Valid examples:\n '0' -> 0\n 'F' -> 15\n 'f' -> 15\n Invalid examples:\n ' ' -> 255\n 'Z' -> 255\n '\\0' -> 255"]
    pub fn aws_lookup_table_hex_to_num_get() -> *const u8;
}
extern "C" {
    #[doc = " Lexical (byte value) comparison of two byte cursors"]
    pub fn aws_byte_cursor_compare_lexical(
        lhs: *const aws_byte_cursor,
        rhs: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Lexical (byte value) comparison of two byte cursors where the raw values are sent through a lookup table first"]
    pub fn aws_byte_cursor_compare_lookup(
        lhs: *const aws_byte_cursor,
        rhs: *const aws_byte_cursor,
        lookup_table: *const u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For creating a byte buffer from a null-terminated string literal."]
    pub fn aws_byte_buf_from_c_str(c_str: *const ::std::os::raw::c_char) -> aws_byte_buf;
}
extern "C" {
    pub fn aws_byte_buf_from_array(
        bytes: *const ::std::os::raw::c_void,
        len: usize,
    ) -> aws_byte_buf;
}
extern "C" {
    pub fn aws_byte_buf_from_empty_array(
        bytes: *const ::std::os::raw::c_void,
        capacity: usize,
    ) -> aws_byte_buf;
}
extern "C" {
    pub fn aws_byte_cursor_from_buf(buf: *const aws_byte_buf) -> aws_byte_cursor;
}
extern "C" {
    pub fn aws_byte_cursor_from_c_str(c_str: *const ::std::os::raw::c_char) -> aws_byte_cursor;
}
extern "C" {
    pub fn aws_byte_cursor_from_array(
        bytes: *const ::std::os::raw::c_void,
        len: usize,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Tests if the given aws_byte_cursor has at least len bytes remaining. If so,\n *buf is advanced by len bytes (incrementing ->ptr and decrementing ->len),\n and an aws_byte_cursor referring to the first len bytes of the original *buf\n is returned. Otherwise, an aws_byte_cursor with ->ptr = NULL, ->len = 0 is\n returned.\n\n Note that if len is above (SIZE_MAX / 2), this function will also treat it as\n a buffer overflow, and return NULL without changing *buf."]
    pub fn aws_byte_cursor_advance(cursor: *mut aws_byte_cursor, len: usize) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Behaves identically to aws_byte_cursor_advance, but avoids speculative\n execution potentially reading out-of-bounds pointers (by returning an\n empty ptr in such speculated paths).\n\n This should generally be done when using an untrusted or\n data-dependent value for 'len', to avoid speculating into a path where\n cursor->ptr points outside the true ptr length."]
    pub fn aws_byte_cursor_advance_nospec(
        cursor: *mut aws_byte_cursor,
        len: usize,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Reads specified length of data from byte cursor and copies it to the\n destination array.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read(
        cur: *mut aws_byte_cursor,
        dest: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Reads as many bytes from cursor as size of buffer, and copies them to buffer.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_and_fill_buffer(
        cur: *mut aws_byte_cursor,
        dest: *mut aws_byte_buf,
    ) -> bool;
}
extern "C" {
    #[doc = " Reads a single byte from cursor, placing it in *var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_u8(cur: *mut aws_byte_cursor, var: *mut u8) -> bool;
}
extern "C" {
    #[doc = " Reads a 16-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be16(cur: *mut aws_byte_cursor, var: *mut u16) -> bool;
}
extern "C" {
    #[doc = " Reads an unsigned 24-bit value (3 bytes) in network byte order from cur,\n and places it in host byte order into 32-bit var.\n Ex: if cur's next 3 bytes are {0xAA, 0xBB, 0xCC}, then var becomes 0x00AABBCC.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be24(cur: *mut aws_byte_cursor, var: *mut u32) -> bool;
}
extern "C" {
    #[doc = " Reads a 32-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be32(cur: *mut aws_byte_cursor, var: *mut u32) -> bool;
}
extern "C" {
    #[doc = " Reads a 64-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_be64(cur: *mut aws_byte_cursor, var: *mut u64) -> bool;
}
extern "C" {
    #[doc = " Reads a 32-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_float_be32(cur: *mut aws_byte_cursor, var: *mut f32) -> bool;
}
extern "C" {
    #[doc = " Reads a 64-bit value in network byte order from cur, and places it in host\n byte order into var.\n\n On success, returns true and updates the cursor pointer/length accordingly.\n If there is insufficient space in the cursor, returns false, leaving the\n cursor unchanged."]
    pub fn aws_byte_cursor_read_float_be64(cur: *mut aws_byte_cursor, var: *mut f64) -> bool;
}
extern "C" {
    #[doc = " Reads 2 hex characters from ASCII/UTF-8 text to produce an 8-bit number.\n Accepts both lowercase 'a'-'f' and uppercase 'A'-'F'.\n For example: \"0F\" produces 15.\n\n On success, returns true and advances the cursor by 2.\n If there is insufficient space in the cursor or an invalid character\n is encountered, returns false, leaving the cursor unchanged."]
    pub fn aws_byte_cursor_read_hex_u8(cur: *mut aws_byte_cursor, var: *mut u8) -> bool;
}
extern "C" {
    #[doc = " Appends a sub-buffer to the specified buffer.\n\n If the buffer has at least `len' bytes remaining (buffer->capacity - buffer->len >= len),\n then buffer->len is incremented by len, and an aws_byte_buf is assigned to *output corresponding\n to the last len bytes of the input buffer. The aws_byte_buf at *output will have a null\n allocator, a zero initial length, and a capacity of 'len'. The function then returns true.\n\n If there is insufficient space, then this function nulls all fields in *output and returns\n false."]
    pub fn aws_byte_buf_advance(
        buffer: *mut aws_byte_buf,
        output: *mut aws_byte_buf,
        len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Write specified number of bytes from array to byte buffer.\n\n On success, returns true and updates the buffer length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write(buf: *mut aws_byte_buf, src: *const u8, len: usize) -> bool;
}
extern "C" {
    #[doc = " Copies all bytes from buffer to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_from_whole_buffer(buf: *mut aws_byte_buf, src: aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Copies all bytes from buffer to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_from_whole_cursor(
        buf: *mut aws_byte_buf,
        src: aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Without increasing buf's capacity, write as much as possible from advancing_cursor into buf.\n\n buf's len is updated accordingly.\n advancing_cursor is advanced so it contains the remaining unwritten parts.\n Returns the section of advancing_cursor which was written.\n\n This function cannot fail. If buf is full (len == capacity) or advancing_len has 0 length,\n then buf and advancing_cursor are not altered and a cursor with 0 length is returned.\n\n Example: Given a buf with 2 bytes of space available and advancing_cursor with contents \"abc\".\n \"ab\" will be written to buf and buf->len will increase 2 and become equal to buf->capacity.\n advancing_cursor will advance so its contents become the unwritten \"c\".\n The returned cursor's contents will be the \"ab\" from the original advancing_cursor."]
    pub fn aws_byte_buf_write_to_capacity(
        buf: *mut aws_byte_buf,
        advancing_cursor: *mut aws_byte_cursor,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Copies one byte to buffer.\n\n On success, returns true and updates the cursor /length\naccordingly.\n\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_u8(buf: *mut aws_byte_buf, c: u8) -> bool;
}
extern "C" {
    #[doc = " Writes one byte repeatedly to buffer (like memset)\n\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_u8_n(buf: *mut aws_byte_buf, c: u8, count: usize) -> bool;
}
extern "C" {
    #[doc = " Writes a 16-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be16(buf: *mut aws_byte_buf, x: u16) -> bool;
}
extern "C" {
    #[doc = " Writes low 24-bits (3 bytes) of an unsigned integer in network byte order (big endian) to buffer.\n Ex: If x is 0x00AABBCC then {0xAA, 0xBB, 0xCC} is written to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, or x's value cannot fit in 3 bytes,\n returns false, leaving the buffer unchanged."]
    pub fn aws_byte_buf_write_be24(buf: *mut aws_byte_buf, x: u32) -> bool;
}
extern "C" {
    #[doc = " Writes a 32-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be32(buf: *mut aws_byte_buf, x: u32) -> bool;
}
extern "C" {
    #[doc = " Writes a 32-bit float in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_float_be32(buf: *mut aws_byte_buf, x: f32) -> bool;
}
extern "C" {
    #[doc = " Writes a 64-bit integer in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_be64(buf: *mut aws_byte_buf, x: u64) -> bool;
}
extern "C" {
    #[doc = " Writes a 64-bit float in network byte order (big endian) to buffer.\n\n On success, returns true and updates the buffer /length accordingly.\n If there is insufficient space in the buffer, returns false, leaving the\n buffer unchanged."]
    pub fn aws_byte_buf_write_float_be64(buf: *mut aws_byte_buf, x: f64) -> bool;
}
extern "C" {
    #[doc = " Like isalnum(), but ignores C locale.\n Returns true if ch has the value of ASCII/UTF-8: 'a'-'z', 'A'-'Z', or '0'-'9'."]
    pub fn aws_isalnum(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isalpha(), but ignores C locale.\n Returns true if ch has the value of ASCII/UTF-8: 'a'-'z' or 'A'-'Z'."]
    pub fn aws_isalpha(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isdigit().\n Returns true if ch has the value of ASCII/UTF-8: '0'-'9'.\n\n Note: C's built-in isdigit() is also supposed to ignore the C locale,\n but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage)\n may classify additional single-byte characters as digits\""]
    pub fn aws_isdigit(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isxdigit().\n Returns true if ch has the value of ASCII/UTF-8: '0'-'9', 'a'-'f', or 'A'-'F'.\n\n Note: C's built-in isxdigit() is also supposed to ignore the C locale,\n but cppreference.com claims \"some implementations (e.g. Microsoft in 1252 codepage)\n may classify additional single-byte characters as digits\""]
    pub fn aws_isxdigit(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Like isspace(), but ignores C locale.\n Return true if ch has the value of ASCII/UTF-8: space (0x20), form feed (0x0C),\n line feed (0x0A), carriage return (0x0D), horizontal tab (0x09), or vertical tab (0x0B)."]
    pub fn aws_isspace(ch: u8) -> bool;
}
extern "C" {
    #[doc = " Read entire cursor as ASCII/UTF-8 unsigned base-10 number.\n Stricter than strtoull(), which allows whitespace and inputs that start with \"0x\"\n\n Examples:\n \"0\" -> 0\n \"123\" -> 123\n \"00004\" -> 4 // leading zeros ok\n\n Rejects things like:\n \"-1\" // negative numbers not allowed\n \"1,000\" // only characters 0-9 allowed\n \"\" // blank string not allowed\n \" 0 \" // whitespace not allowed\n \"0x0\" // hex not allowed\n \"FF\" // hex not allowed\n \"999999999999999999999999999999999999999999\" // larger than max u64"]
    pub fn aws_byte_cursor_utf8_parse_u64(
        cursor: aws_byte_cursor,
        dst: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read entire cursor as ASCII/UTF-8 unsigned base-16 number with NO \"0x\" prefix.\n\n Examples:\n \"F\" -> 15\n \"000000ff\" -> 255 // leading zeros ok\n \"Ff\" -> 255 // mixed case ok\n \"123\" -> 291\n \"FFFFFFFFFFFFFFFF\" -> 18446744073709551616 // max u64\n\n Rejects things like:\n \"0x0\" // 0x prefix not allowed\n \"\" // blank string not allowed\n \" F \" // whitespace not allowed\n \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" // larger than max u64"]
    pub fn aws_byte_cursor_utf8_parse_u64_hex(
        cursor: aws_byte_cursor,
        dst: *mut u64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_list_node {
    pub next: *mut aws_linked_list_node,
    pub prev: *mut aws_linked_list_node,
}
#[test]
fn bindgen_test_layout_aws_linked_list_node() {
    const UNINIT: ::std::mem::MaybeUninit<aws_linked_list_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_linked_list_node>(),
        16usize,
        concat!("Size of: ", stringify!(aws_linked_list_node))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_linked_list_node>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_linked_list_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list_node),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_linked_list {
    pub head: aws_linked_list_node,
    pub tail: aws_linked_list_node,
}
#[test]
fn bindgen_test_layout_aws_linked_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_linked_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_linked_list>(),
        32usize,
        concat!("Size of: ", stringify!(aws_linked_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_linked_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_linked_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_linked_list),
            "::",
            stringify!(tail)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_io_handle {
    pub data: aws_io_handle__bindgen_ty_1,
    pub additional_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_io_handle__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_io_handle__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aws_io_handle__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_io_handle__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(aws_io_handle__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_io_handle__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_io_handle__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_handle__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_handle__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout_aws_io_handle() {
    const UNINIT: ::std::mem::MaybeUninit<aws_io_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_io_handle>(),
        16usize,
        concat!("Size of: ", stringify!(aws_io_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_io_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_io_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_handle),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).additional_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_handle),
            "::",
            stringify!(additional_data)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_io_message_type {
    AWS_IO_MESSAGE_APPLICATION_DATA = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel {
    _unused: [u8; 0],
}
pub type aws_channel_on_message_write_completed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_channel,
        message: *mut aws_io_message,
        err_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_io_message {
    #[doc = " Allocator used for the message and message data. If this is null, the message belongs to a pool or some other\n message manager."]
    pub allocator: *mut aws_allocator,
    #[doc = " Buffer containing the data for message"]
    pub message_data: aws_byte_buf,
    #[doc = " type of the message. This is used for framework control messages. Currently the only type is\n AWS_IO_MESSAGE_APPLICATION_DATA"]
    pub message_type: aws_io_message_type,
    #[doc = " Conveys information about the contents of message_data (e.g. cast the ptr to some type). If 0, it's just opaque\n data."]
    pub message_tag: ::std::os::raw::c_int,
    #[doc = " In order to avoid excess allocations/copies, on a partial read or write, the copy mark is set to indicate how\n much of this message has already been processed or copied."]
    pub copy_mark: usize,
    #[doc = " The channel that the message is bound to."]
    pub owning_channel: *mut aws_channel,
    #[doc = " Invoked by the channel once the entire message has been written to the data sink."]
    pub on_completion: aws_channel_on_message_write_completed_fn,
    #[doc = " arbitrary user data for the on_completion callback"]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " it's incredibly likely something is going to need to queue this,\n go ahead and make sure the list info is part of the original allocation."]
    pub queueing_handle: aws_linked_list_node,
}
#[test]
fn bindgen_test_layout_aws_io_message() {
    const UNINIT: ::std::mem::MaybeUninit<aws_io_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_io_message>(),
        96usize,
        concat!("Size of: ", stringify!(aws_io_message))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_io_message>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_io_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(message_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_tag) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(message_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_mark) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(copy_mark)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owning_channel) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(owning_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_completion) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(on_completion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queueing_handle) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_io_message),
            "::",
            stringify!(queueing_handle)
        )
    );
}
pub type aws_io_clock_fn =
    ::std::option::Option<unsafe extern "C" fn(timestamp: *mut u64) -> ::std::os::raw::c_int>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_io_errors {
    AWS_IO_CHANNEL_ERROR_ERROR_CANT_ACCEPT_INPUT = 1024,
    AWS_IO_CHANNEL_UNKNOWN_MESSAGE_TYPE = 1025,
    AWS_IO_CHANNEL_READ_WOULD_EXCEED_WINDOW = 1026,
    AWS_IO_EVENT_LOOP_ALREADY_ASSIGNED = 1027,
    AWS_IO_EVENT_LOOP_SHUTDOWN = 1028,
    AWS_IO_TLS_ERROR_NEGOTIATION_FAILURE = 1029,
    AWS_IO_TLS_ERROR_NOT_NEGOTIATED = 1030,
    AWS_IO_TLS_ERROR_WRITE_FAILURE = 1031,
    AWS_IO_TLS_ERROR_ALERT_RECEIVED = 1032,
    AWS_IO_TLS_CTX_ERROR = 1033,
    AWS_IO_TLS_VERSION_UNSUPPORTED = 1034,
    AWS_IO_TLS_CIPHER_PREF_UNSUPPORTED = 1035,
    AWS_IO_MISSING_ALPN_MESSAGE = 1036,
    AWS_IO_UNHANDLED_ALPN_PROTOCOL_MESSAGE = 1037,
    AWS_IO_FILE_VALIDATION_FAILURE = 1038,
    AWS_ERROR_IO_EVENT_LOOP_THREAD_ONLY = 1039,
    AWS_ERROR_IO_ALREADY_SUBSCRIBED = 1040,
    AWS_ERROR_IO_NOT_SUBSCRIBED = 1041,
    AWS_ERROR_IO_OPERATION_CANCELLED = 1042,
    AWS_IO_READ_WOULD_BLOCK = 1043,
    AWS_IO_BROKEN_PIPE = 1044,
    AWS_IO_SOCKET_UNSUPPORTED_ADDRESS_FAMILY = 1045,
    AWS_IO_SOCKET_INVALID_OPERATION_FOR_TYPE = 1046,
    AWS_IO_SOCKET_CONNECTION_REFUSED = 1047,
    AWS_IO_SOCKET_TIMEOUT = 1048,
    AWS_IO_SOCKET_NO_ROUTE_TO_HOST = 1049,
    AWS_IO_SOCKET_NETWORK_DOWN = 1050,
    AWS_IO_SOCKET_CLOSED = 1051,
    AWS_IO_SOCKET_NOT_CONNECTED = 1052,
    AWS_IO_SOCKET_INVALID_OPTIONS = 1053,
    AWS_IO_SOCKET_ADDRESS_IN_USE = 1054,
    AWS_IO_SOCKET_INVALID_ADDRESS = 1055,
    AWS_IO_SOCKET_ILLEGAL_OPERATION_FOR_STATE = 1056,
    AWS_IO_SOCKET_CONNECT_ABORTED = 1057,
    AWS_IO_DNS_QUERY_FAILED = 1058,
    AWS_IO_DNS_INVALID_NAME = 1059,
    AWS_IO_DNS_NO_ADDRESS_FOR_HOST = 1060,
    AWS_IO_DNS_HOST_REMOVED_FROM_CACHE = 1061,
    AWS_IO_STREAM_INVALID_SEEK_POSITION = 1062,
    AWS_IO_STREAM_READ_FAILED = 1063,
    DEPRECATED_AWS_IO_INVALID_FILE_HANDLE = 1064,
    AWS_IO_SHARED_LIBRARY_LOAD_FAILURE = 1065,
    AWS_IO_SHARED_LIBRARY_FIND_SYMBOL_FAILURE = 1066,
    AWS_IO_TLS_NEGOTIATION_TIMEOUT = 1067,
    AWS_IO_TLS_ALERT_NOT_GRACEFUL = 1068,
    AWS_IO_MAX_RETRIES_EXCEEDED = 1069,
    AWS_IO_RETRY_PERMISSION_DENIED = 1070,
    AWS_IO_TLS_DIGEST_ALGORITHM_UNSUPPORTED = 1071,
    AWS_IO_TLS_SIGNATURE_ALGORITHM_UNSUPPORTED = 1072,
    AWS_ERROR_PKCS11_VERSION_UNSUPPORTED = 1073,
    AWS_ERROR_PKCS11_TOKEN_NOT_FOUND = 1074,
    AWS_ERROR_PKCS11_KEY_NOT_FOUND = 1075,
    AWS_ERROR_PKCS11_KEY_TYPE_UNSUPPORTED = 1076,
    AWS_ERROR_PKCS11_UNKNOWN_CRYPTOKI_RETURN_VALUE = 1077,
    AWS_ERROR_PKCS11_CKR_CANCEL = 1078,
    AWS_ERROR_PKCS11_CKR_HOST_MEMORY = 1079,
    AWS_ERROR_PKCS11_CKR_SLOT_ID_INVALID = 1080,
    AWS_ERROR_PKCS11_CKR_GENERAL_ERROR = 1081,
    AWS_ERROR_PKCS11_CKR_FUNCTION_FAILED = 1082,
    AWS_ERROR_PKCS11_CKR_ARGUMENTS_BAD = 1083,
    AWS_ERROR_PKCS11_CKR_NO_EVENT = 1084,
    AWS_ERROR_PKCS11_CKR_NEED_TO_CREATE_THREADS = 1085,
    AWS_ERROR_PKCS11_CKR_CANT_LOCK = 1086,
    AWS_ERROR_PKCS11_CKR_ATTRIBUTE_READ_ONLY = 1087,
    AWS_ERROR_PKCS11_CKR_ATTRIBUTE_SENSITIVE = 1088,
    AWS_ERROR_PKCS11_CKR_ATTRIBUTE_TYPE_INVALID = 1089,
    AWS_ERROR_PKCS11_CKR_ATTRIBUTE_VALUE_INVALID = 1090,
    AWS_ERROR_PKCS11_CKR_ACTION_PROHIBITED = 1091,
    AWS_ERROR_PKCS11_CKR_DATA_INVALID = 1092,
    AWS_ERROR_PKCS11_CKR_DATA_LEN_RANGE = 1093,
    AWS_ERROR_PKCS11_CKR_DEVICE_ERROR = 1094,
    AWS_ERROR_PKCS11_CKR_DEVICE_MEMORY = 1095,
    AWS_ERROR_PKCS11_CKR_DEVICE_REMOVED = 1096,
    AWS_ERROR_PKCS11_CKR_ENCRYPTED_DATA_INVALID = 1097,
    AWS_ERROR_PKCS11_CKR_ENCRYPTED_DATA_LEN_RANGE = 1098,
    AWS_ERROR_PKCS11_CKR_FUNCTION_CANCELED = 1099,
    AWS_ERROR_PKCS11_CKR_FUNCTION_NOT_PARALLEL = 1100,
    AWS_ERROR_PKCS11_CKR_FUNCTION_NOT_SUPPORTED = 1101,
    AWS_ERROR_PKCS11_CKR_KEY_HANDLE_INVALID = 1102,
    AWS_ERROR_PKCS11_CKR_KEY_SIZE_RANGE = 1103,
    AWS_ERROR_PKCS11_CKR_KEY_TYPE_INCONSISTENT = 1104,
    AWS_ERROR_PKCS11_CKR_KEY_NOT_NEEDED = 1105,
    AWS_ERROR_PKCS11_CKR_KEY_CHANGED = 1106,
    AWS_ERROR_PKCS11_CKR_KEY_NEEDED = 1107,
    AWS_ERROR_PKCS11_CKR_KEY_INDIGESTIBLE = 1108,
    AWS_ERROR_PKCS11_CKR_KEY_FUNCTION_NOT_PERMITTED = 1109,
    AWS_ERROR_PKCS11_CKR_KEY_NOT_WRAPPABLE = 1110,
    AWS_ERROR_PKCS11_CKR_KEY_UNEXTRACTABLE = 1111,
    AWS_ERROR_PKCS11_CKR_MECHANISM_INVALID = 1112,
    AWS_ERROR_PKCS11_CKR_MECHANISM_PARAM_INVALID = 1113,
    AWS_ERROR_PKCS11_CKR_OBJECT_HANDLE_INVALID = 1114,
    AWS_ERROR_PKCS11_CKR_OPERATION_ACTIVE = 1115,
    AWS_ERROR_PKCS11_CKR_OPERATION_NOT_INITIALIZED = 1116,
    AWS_ERROR_PKCS11_CKR_PIN_INCORRECT = 1117,
    AWS_ERROR_PKCS11_CKR_PIN_INVALID = 1118,
    AWS_ERROR_PKCS11_CKR_PIN_LEN_RANGE = 1119,
    AWS_ERROR_PKCS11_CKR_PIN_EXPIRED = 1120,
    AWS_ERROR_PKCS11_CKR_PIN_LOCKED = 1121,
    AWS_ERROR_PKCS11_CKR_SESSION_CLOSED = 1122,
    AWS_ERROR_PKCS11_CKR_SESSION_COUNT = 1123,
    AWS_ERROR_PKCS11_CKR_SESSION_HANDLE_INVALID = 1124,
    AWS_ERROR_PKCS11_CKR_SESSION_PARALLEL_NOT_SUPPORTED = 1125,
    AWS_ERROR_PKCS11_CKR_SESSION_READ_ONLY = 1126,
    AWS_ERROR_PKCS11_CKR_SESSION_EXISTS = 1127,
    AWS_ERROR_PKCS11_CKR_SESSION_READ_ONLY_EXISTS = 1128,
    AWS_ERROR_PKCS11_CKR_SESSION_READ_WRITE_SO_EXISTS = 1129,
    AWS_ERROR_PKCS11_CKR_SIGNATURE_INVALID = 1130,
    AWS_ERROR_PKCS11_CKR_SIGNATURE_LEN_RANGE = 1131,
    AWS_ERROR_PKCS11_CKR_TEMPLATE_INCOMPLETE = 1132,
    AWS_ERROR_PKCS11_CKR_TEMPLATE_INCONSISTENT = 1133,
    AWS_ERROR_PKCS11_CKR_TOKEN_NOT_PRESENT = 1134,
    AWS_ERROR_PKCS11_CKR_TOKEN_NOT_RECOGNIZED = 1135,
    AWS_ERROR_PKCS11_CKR_TOKEN_WRITE_PROTECTED = 1136,
    AWS_ERROR_PKCS11_CKR_UNWRAPPING_KEY_HANDLE_INVALID = 1137,
    AWS_ERROR_PKCS11_CKR_UNWRAPPING_KEY_SIZE_RANGE = 1138,
    AWS_ERROR_PKCS11_CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT = 1139,
    AWS_ERROR_PKCS11_CKR_USER_ALREADY_LOGGED_IN = 1140,
    AWS_ERROR_PKCS11_CKR_USER_NOT_LOGGED_IN = 1141,
    AWS_ERROR_PKCS11_CKR_USER_PIN_NOT_INITIALIZED = 1142,
    AWS_ERROR_PKCS11_CKR_USER_TYPE_INVALID = 1143,
    AWS_ERROR_PKCS11_CKR_USER_ANOTHER_ALREADY_LOGGED_IN = 1144,
    AWS_ERROR_PKCS11_CKR_USER_TOO_MANY_TYPES = 1145,
    AWS_ERROR_PKCS11_CKR_WRAPPED_KEY_INVALID = 1146,
    AWS_ERROR_PKCS11_CKR_WRAPPED_KEY_LEN_RANGE = 1147,
    AWS_ERROR_PKCS11_CKR_WRAPPING_KEY_HANDLE_INVALID = 1148,
    AWS_ERROR_PKCS11_CKR_WRAPPING_KEY_SIZE_RANGE = 1149,
    AWS_ERROR_PKCS11_CKR_WRAPPING_KEY_TYPE_INCONSISTENT = 1150,
    AWS_ERROR_PKCS11_CKR_RANDOM_SEED_NOT_SUPPORTED = 1151,
    AWS_ERROR_PKCS11_CKR_RANDOM_NO_RNG = 1152,
    AWS_ERROR_PKCS11_CKR_DOMAIN_PARAMS_INVALID = 1153,
    AWS_ERROR_PKCS11_CKR_CURVE_NOT_SUPPORTED = 1154,
    AWS_ERROR_PKCS11_CKR_BUFFER_TOO_SMALL = 1155,
    AWS_ERROR_PKCS11_CKR_SAVED_STATE_INVALID = 1156,
    AWS_ERROR_PKCS11_CKR_INFORMATION_SENSITIVE = 1157,
    AWS_ERROR_PKCS11_CKR_STATE_UNSAVEABLE = 1158,
    AWS_ERROR_PKCS11_CKR_CRYPTOKI_NOT_INITIALIZED = 1159,
    AWS_ERROR_PKCS11_CKR_CRYPTOKI_ALREADY_INITIALIZED = 1160,
    AWS_ERROR_PKCS11_CKR_MUTEX_BAD = 1161,
    AWS_ERROR_PKCS11_CKR_MUTEX_NOT_LOCKED = 1162,
    AWS_ERROR_PKCS11_CKR_NEW_PIN_MODE = 1163,
    AWS_ERROR_PKCS11_CKR_NEXT_OTP = 1164,
    AWS_ERROR_PKCS11_CKR_EXCEEDED_MAX_ITERATIONS = 1165,
    AWS_ERROR_PKCS11_CKR_FIPS_SELF_TEST_FAILED = 1166,
    AWS_ERROR_PKCS11_CKR_LIBRARY_LOAD_FAILED = 1167,
    AWS_ERROR_PKCS11_CKR_PIN_TOO_WEAK = 1168,
    AWS_ERROR_PKCS11_CKR_PUBLIC_KEY_INVALID = 1169,
    AWS_ERROR_PKCS11_CKR_FUNCTION_REJECTED = 1170,
    AWS_ERROR_IO_PINNED_EVENT_LOOP_MISMATCH = 1171,
    AWS_ERROR_PKCS11_ENCODING_ERROR = 1172,
    AWS_IO_TLS_ERROR_DEFAULT_TRUST_STORE_NOT_FOUND = 1173,
    AWS_IO_STREAM_SEEK_FAILED = 1174,
    AWS_IO_STREAM_GET_LENGTH_FAILED = 1175,
    AWS_IO_STREAM_SEEK_UNSUPPORTED = 1176,
    AWS_IO_STREAM_GET_LENGTH_UNSUPPORTED = 1177,
    AWS_IO_TLS_ERROR_READ_FAILURE = 1178,
    AWS_ERROR_PEM_MALFORMED = 1179,
    AWS_IO_ERROR_END_RANGE = 2047,
    AWS_IO_INVALID_FILE_HANDLE = 50,
}
extern "C" {
    #[doc = " Initializes internal datastructures used by aws-c-io.\n Must be called before using any functionality in aws-c-io."]
    pub fn aws_io_library_init(allocator: *mut aws_allocator);
}
extern "C" {
    #[doc = " Shuts down the internal datastructures used by aws-c-io."]
    pub fn aws_io_library_clean_up();
}
extern "C" {
    pub fn aws_io_fatal_assert_library_initialized();
}
#[doc = " struct aws_atomic_var represents an atomic variable - a value which can hold an integer or pointer\n that can be manipulated atomically. struct aws_atomic_vars should normally only be manipulated\n with atomics methods defined in this header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_atomic_var {
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_atomic_var() {
    const UNINIT: ::std::mem::MaybeUninit<aws_atomic_var> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_atomic_var>(),
        8usize,
        concat!("Size of: ", stringify!(aws_atomic_var))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_atomic_var>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_atomic_var))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_atomic_var),
            "::",
            stringify!(value)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_memory_order {
    #[doc = " No particular ordering constraints are guaranteed relative to other\n operations at all; we merely ensure that the operation itself is atomic."]
    aws_memory_order_relaxed = 0,
    #[doc = " Specifies acquire ordering. No reads or writes on the current thread can be\n reordered to happen before this operation. This is typically paired with a release\n ordering; any writes that happened on the releasing operation will be visible\n after the paired acquire operation.\n\n Acquire ordering is only meaningful on load or load-store operations."]
    aws_memory_order_acquire = 2,
    #[doc = " Specifies release order. No reads or writes can be reordered to come after this\n operation. Typically paired with an acquire operation.\n\n Release ordering is only meaningful on store or load-store operations."]
    aws_memory_order_release = 3,
    #[doc = " Specifies acquire-release order; if this operation acts as a load, it acts as an\n acquire operation; if it acts as a store, it acts as a release operation; if it's\n a load-store, it does both."]
    aws_memory_order_acq_rel = 4,
    #[doc = " Specifies acquire-release order; if this operation acts as a load, it acts as an\n acquire operation; if it acts as a store, it acts as a release operation; if it's\n a load-store, it does both."]
    aws_memory_order_seq_cst = 5,
}
pub type aws_atomic_impl_int_t = usize;
pub type aws_simple_completion_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_ref_count {
    pub ref_count: aws_atomic_var,
    pub object: *mut ::std::os::raw::c_void,
    pub on_zero_fn: aws_simple_completion_callback,
}
#[test]
fn bindgen_test_layout_aws_ref_count() {
    const UNINIT: ::std::mem::MaybeUninit<aws_ref_count> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_ref_count>(),
        24usize,
        concat!("Size of: ", stringify!(aws_ref_count))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_ref_count>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_ref_count))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ref_count),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ref_count),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_zero_fn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_ref_count),
            "::",
            stringify!(on_zero_fn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_shutdown_callback_options {
    pub shutdown_callback_fn: aws_simple_completion_callback,
    pub shutdown_callback_user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_shutdown_callback_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_shutdown_callback_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_shutdown_callback_options>(),
        16usize,
        concat!("Size of: ", stringify!(aws_shutdown_callback_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_shutdown_callback_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_shutdown_callback_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_callback_fn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_shutdown_callback_options),
            "::",
            stringify!(shutdown_callback_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_callback_user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_shutdown_callback_options),
            "::",
            stringify!(shutdown_callback_user_data)
        )
    );
}
extern "C" {
    #[doc = " Initializes a ref-counter structure.  After initialization, the ref count will be 1.\n\n @param ref_count ref-counter to initialize\n @param object object being ref counted\n @param on_zero_fn function to invoke when the ref count reaches zero"]
    pub fn aws_ref_count_init(
        ref_count: *mut aws_ref_count,
        object: *mut ::std::os::raw::c_void,
        on_zero_fn: aws_simple_completion_callback,
    );
}
extern "C" {
    #[doc = " Increments a ref-counter's ref count\n\n @param ref_count ref-counter to increment the count for\n @return the object being ref-counted"]
    pub fn aws_ref_count_acquire(ref_count: *mut aws_ref_count) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Decrements a ref-counter's ref count.  Invokes the on_zero callback if the ref count drops to zero\n @param ref_count ref-counter to decrement the count for\n @return the value of the decremented ref count"]
    pub fn aws_ref_count_release(ref_count: *mut aws_ref_count) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_bool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_async_input_stream {
    pub vtable: *const aws_async_input_stream_vtable,
    pub alloc: *mut aws_allocator,
    pub ref_count: aws_ref_count,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_async_input_stream() {
    const UNINIT: ::std::mem::MaybeUninit<aws_async_input_stream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_async_input_stream>(),
        48usize,
        concat!("Size of: ", stringify!(aws_async_input_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_async_input_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_async_input_stream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_async_input_stream),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_async_input_stream),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_async_input_stream),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_async_input_stream),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_async_input_stream_vtable {
    #[doc = " Destroy the stream, its refcount has reached 0."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(stream: *mut aws_async_input_stream)>,
    #[doc = " Read once into the buffer.\n Complete the read when at least 1 byte is read, the buffer is full, or EOF is reached.\n Do not resize the buffer (do not use \"aws_byte_buf_xyz_dynamic()\" functions)\n Do not assume that buffer len starts at 0.\n You may assume that read() won't be called again until the current one completes.\n You may assume that the buffer has some space available.\n Return a future, which will contain an error code if something went wrong,\n or a result bool indicating whether EOF has been reached."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_async_input_stream,
            dest: *mut aws_byte_buf,
        ) -> *mut aws_future_bool,
    >,
}
#[test]
fn bindgen_test_layout_aws_async_input_stream_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_async_input_stream_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_async_input_stream_vtable>(),
        16usize,
        concat!("Size of: ", stringify!(aws_async_input_stream_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_async_input_stream_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_async_input_stream_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_async_input_stream_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_async_input_stream_vtable),
            "::",
            stringify!(read)
        )
    );
}
extern "C" {
    #[doc = " Initialize aws_async_input_stream \"base class\""]
    pub fn aws_async_input_stream_init_base(
        stream: *mut aws_async_input_stream,
        alloc: *mut aws_allocator,
        vtable: *const aws_async_input_stream_vtable,
        impl_: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Increment reference count.\n You may pass in NULL (has no effect).\n Returns whatever pointer was passed in."]
    pub fn aws_async_input_stream_acquire(
        stream: *mut aws_async_input_stream,
    ) -> *mut aws_async_input_stream;
}
extern "C" {
    #[doc = " Decrement reference count.\n You may pass in NULL (has no effect).\n Always returns NULL."]
    pub fn aws_async_input_stream_release(
        stream: *mut aws_async_input_stream,
    ) -> *mut aws_async_input_stream;
}
extern "C" {
    #[doc = " Read once from the async stream into the buffer.\n The read completes when at least 1 byte is read, the buffer is full, or EOF is reached.\n Depending on implementation, the read could complete at any time.\n It may complete synchronously. It may complete on another thread.\n Returns a future, which will contain an error code if something went wrong,\n or a result bool indicating whether EOF has been reached.\n\n WARNING: The buffer must have space available.\n WARNING: Do not read again until the previous read is complete."]
    pub fn aws_async_input_stream_read(
        stream: *mut aws_async_input_stream,
        dest: *mut aws_byte_buf,
    ) -> *mut aws_future_bool;
}
extern "C" {
    #[doc = " Read repeatedly from the async stream until the buffer is full, or EOF is reached.\n Depending on implementation, this could complete at any time.\n It may complete synchronously. It may complete on another thread.\n Returns a future, which will contain an error code if something went wrong,\n or a result bool indicating whether EOF has been reached.\n\n WARNING: The buffer must have space available.\n WARNING: Do not read again until the previous read is complete."]
    pub fn aws_async_input_stream_read_to_fill(
        stream: *mut aws_async_input_stream,
        dest: *mut aws_byte_buf,
    ) -> *mut aws_future_bool;
}
pub type aws_crt_statistics_category_t = u32;
pub const AWS_CRT_STATISTICS_CATEGORY_STRIDE_BITS: _bindgen_ty_3 =
    _bindgen_ty_3::AWS_CRT_STATISTICS_CATEGORY_STRIDE_BITS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    AWS_CRT_STATISTICS_CATEGORY_STRIDE_BITS = 8,
}
#[repr(u32)]
#[doc = " The common-specific range of the aws_crt_statistics_category cross-library enum.\n\n This enum functions as an RTTI value that lets statistics handler's interpret (via cast) a\n specific statistics structure if the RTTI value is understood.\n\n Common doesn't have any statistics structures presently, so its range is essentially empty.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_crt_common_statistics_category {
    AWSCRT_STAT_CAT_INVALID = 0,
}
#[doc = " Pattern-struct that functions as a base \"class\" for all statistics structures.  To conform\n to the pattern, a statistics structure must have its first member be the category.  In that\n case it becomes \"safe\" to cast from aws_crt_statistics_base to the specific statistics structure\n based on the category value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_base {
    pub category: aws_crt_statistics_category_t,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_base() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_base> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_base>(),
        4usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_base))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_base>(),
        4usize,
        concat!("Alignment of ", stringify!(aws_crt_statistics_base))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_base),
            "::",
            stringify!(category)
        )
    );
}
#[doc = " The start and end time, in milliseconds-since-epoch, that a set of statistics was gathered over."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_sample_interval {
    pub begin_time_ms: u64,
    pub end_time_ms: u64,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_sample_interval() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_sample_interval> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_sample_interval>(),
        16usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_sample_interval))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_sample_interval>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_crt_statistics_sample_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin_time_ms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_sample_interval),
            "::",
            stringify!(begin_time_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_time_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_sample_interval),
            "::",
            stringify!(end_time_ms)
        )
    );
}
pub type aws_crt_statistics_handler_process_statistics_fn = ::std::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_crt_statistics_handler,
        interval: *mut aws_crt_statistics_sample_interval,
        stats: *mut aws_array_list,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type aws_crt_statistics_handler_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_crt_statistics_handler)>;
pub type aws_crt_statistics_handler_get_report_interval_ms_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut aws_crt_statistics_handler) -> u64>;
#[doc = " Vtable for functions that all statistics handlers must implement"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_handler_vtable {
    pub process_statistics: aws_crt_statistics_handler_process_statistics_fn,
    pub destroy: aws_crt_statistics_handler_destroy_fn,
    pub get_report_interval_ms: aws_crt_statistics_handler_get_report_interval_ms_fn,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_handler_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_handler_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_handler_vtable>(),
        24usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_handler_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_handler_vtable>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_crt_statistics_handler_vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_statistics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler_vtable),
            "::",
            stringify!(process_statistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_report_interval_ms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler_vtable),
            "::",
            stringify!(get_report_interval_ms)
        )
    );
}
#[doc = " Base structure for all statistics handler implementations.\n\n A statistics handler is an object that listens to a stream of polymorphic (via the category RTTI enum) statistics\n structures emitted from some arbitrary source.  In the initial implementation, statistics handlers are primarily\n attached to channels, where they monitor IO throughput and state data (from channel handlers) to determine a\n connection's health.\n\n Statistics handlers are a generalization of the timeout and bandwidth filters that are often associated with\n SDK network connections.  Configurable, default implementations are defined at the protocol level (http, etc...)\n where they can be attached at connection (channel) creation time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_handler {
    pub vtable: *mut aws_crt_statistics_handler_vtable,
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_handler() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_handler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_handler>(),
        24usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_crt_statistics_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_handler),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Submits a list of statistics objects to a statistics handler for processing\n\n handler - the statistics handler that will process the statistics objects\n interval - time period over which the statistics were gathered\n stats - list of pointers to structures that can be case to aws_crt_statistics_base (i.e. have category as a first\n   member)\n context - (optional) additional context specific to where the statistics handler has been attached"]
    pub fn aws_crt_statistics_handler_process_statistics(
        handler: *mut aws_crt_statistics_handler,
        interval: *mut aws_crt_statistics_sample_interval,
        stats: *mut aws_array_list,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Queries the frequency (via an interval in milliseconds) which a statistics handler would like to be informed\n of statistics."]
    pub fn aws_crt_statistics_handler_get_report_interval_ms(
        handler: *mut aws_crt_statistics_handler,
    ) -> u64;
}
extern "C" {
    #[doc = " completely destroys a statistics handler.  The handler's cleanup function must clean up the impl portion completely\n (including its allocation, if done separately)."]
    pub fn aws_crt_statistics_handler_destroy(handler: *mut aws_crt_statistics_handler);
}
pub type aws_priority_queue_compare_fn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_priority_queue {
    #[doc = " predicate that determines the priority of the elements in the queue."]
    pub pred: aws_priority_queue_compare_fn,
    #[doc = " The underlying container storing the queue elements."]
    pub container: aws_array_list,
    #[doc = " An array of pointers to backpointer elements. This array is initialized when\n the first call to aws_priority_queue_push_bp is made, and is subsequently maintained\n through any heap node manipulations.\n\n Each element is a struct aws_priority_queue_node *, pointing to a backpointer field\n owned by the calling code, or a NULL. The backpointer field is continually updated\n with information needed to locate and remove a specific node later on."]
    pub backpointers: aws_array_list,
}
#[test]
fn bindgen_test_layout_aws_priority_queue() {
    const UNINIT: ::std::mem::MaybeUninit<aws_priority_queue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_priority_queue>(),
        88usize,
        concat!("Size of: ", stringify!(aws_priority_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_priority_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_priority_queue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pred) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue),
            "::",
            stringify!(pred)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).container) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backpointers) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue),
            "::",
            stringify!(backpointers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_priority_queue_node {
    #[doc = " The current index of the node in question, or SIZE_MAX if the node has been removed."]
    pub current_index: usize,
}
#[test]
fn bindgen_test_layout_aws_priority_queue_node() {
    const UNINIT: ::std::mem::MaybeUninit<aws_priority_queue_node> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_priority_queue_node>(),
        8usize,
        concat!("Size of: ", stringify!(aws_priority_queue_node))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_priority_queue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_priority_queue_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_priority_queue_node),
            "::",
            stringify!(current_index)
        )
    );
}
extern "C" {
    #[doc = " Initializes a priority queue struct for use. This mode will grow memory automatically (exponential model)\n Default size is the inital size of the queue\n item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n pred is the function that will be used to determine priority."]
    pub fn aws_priority_queue_init_dynamic(
        queue: *mut aws_priority_queue,
        alloc: *mut aws_allocator,
        default_size: usize,
        item_size: usize,
        pred: aws_priority_queue_compare_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes a priority queue struct for use. This mode will not allocate any additional memory. When the heap fills\n new enqueue operations will fail with AWS_ERROR_PRIORITY_QUEUE_FULL.\n\n Heaps initialized using this call do not support the aws_priority_queue_push_ref call with a non-NULL backpointer\n parameter.\n\n heap is the raw memory allocated for this priority_queue\n item_count is the maximum number of elements the raw heap can contain\n item_size is the size of each element in bytes. Mixing items types is not supported by this API.\n pred is the function that will be used to determine priority."]
    pub fn aws_priority_queue_init_static(
        queue: *mut aws_priority_queue,
        heap: *mut ::std::os::raw::c_void,
        item_count: usize,
        item_size: usize,
        pred: aws_priority_queue_compare_fn,
    );
}
extern "C" {
    #[doc = " Checks that the backpointer at a specific index of the queue is\n NULL or points to a correctly allocated aws_priority_queue_node."]
    pub fn aws_priority_queue_backpointer_index_valid(
        queue: *const aws_priority_queue,
        index: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks that the backpointers of the priority queue are either NULL\n or correctly allocated to point at aws_priority_queue_nodes. This\n check is O(n), as it accesses every backpointer in a loop, and thus\n shouldn't be used carelessly."]
    pub fn aws_priority_queue_backpointers_valid_deep(queue: *const aws_priority_queue) -> bool;
}
extern "C" {
    #[doc = " Checks that the backpointers of the priority queue satisfy validity\n constraints."]
    pub fn aws_priority_queue_backpointers_valid(queue: *const aws_priority_queue) -> bool;
}
extern "C" {
    #[doc = " Set of properties of a valid aws_priority_queue."]
    pub fn aws_priority_queue_is_valid(queue: *const aws_priority_queue) -> bool;
}
extern "C" {
    #[doc = " Cleans up any internally allocated memory and resets the struct for reuse or deletion."]
    pub fn aws_priority_queue_clean_up(queue: *mut aws_priority_queue);
}
extern "C" {
    #[doc = " Copies item into the queue and places it in the proper priority order. Complexity: O(log(n))."]
    pub fn aws_priority_queue_push(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies item into the queue and places it in the proper priority order. Complexity: O(log(n)).\n\n If the backpointer parameter is non-null, the heap will continually update the pointed-to field\n with information needed to remove the node later on. *backpointer must remain valid until the node\n is removed from the heap, and may be updated on any mutating operation on the priority queue.\n\n If the node is removed, the backpointer will be set to a sentinel value that indicates that the\n node has already been removed. It is safe (and a no-op) to call aws_priority_queue_remove with\n such a sentinel value."]
    pub fn aws_priority_queue_push_ref(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
        backpointer: *mut aws_priority_queue_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies the element of the highest priority, and removes it from the queue.. Complexity: O(log(n)).\n If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised."]
    pub fn aws_priority_queue_pop(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes a specific node from the priority queue. Complexity: O(log(n))\n After removing a node (using either _remove or _pop), the backpointer set at push_ref time is set\n to a sentinel value. If this sentinel value is passed to aws_priority_queue_remove,\n AWS_ERROR_PRIORITY_QUEUE_BAD_NODE will be raised. Note, however, that passing uninitialized\n aws_priority_queue_nodes, or ones from different priority queues, results in undefined behavior."]
    pub fn aws_priority_queue_remove(
        queue: *mut aws_priority_queue,
        item: *mut ::std::os::raw::c_void,
        node: *const aws_priority_queue_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtains a pointer to the element of the highest priority. Complexity: constant time.\n If queue is empty, AWS_ERROR_PRIORITY_QUEUE_EMPTY will be raised."]
    pub fn aws_priority_queue_top(
        queue: *const aws_priority_queue,
        item: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes all elements from the queue, but does not free internal memory."]
    pub fn aws_priority_queue_clear(queue: *mut aws_priority_queue);
}
extern "C" {
    #[doc = " Current number of elements in the queue"]
    pub fn aws_priority_queue_size(queue: *const aws_priority_queue) -> usize;
}
extern "C" {
    #[doc = " Current allocated capacity for the queue, in dynamic mode this grows over time, in static mode, this will never\n change."]
    pub fn aws_priority_queue_capacity(queue: *const aws_priority_queue) -> usize;
}
extern "C" {
    #[doc = " Initializes a queue node to a default value that indicates the node is not in the queue.\n\n @param node priority queue node to initialize with a default value"]
    pub fn aws_priority_queue_node_init(node: *mut aws_priority_queue_node);
}
extern "C" {
    #[doc = " Checks if a priority queue node is currently in a priority queue.\n\n @param node priority queue node to check usage for\n\n @return true if the node is in a queue, false otherwise"]
    pub fn aws_priority_queue_node_is_in_queue(node: *const aws_priority_queue_node) -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_task_status {
    AWS_TASK_STATUS_RUN_READY = 0,
    AWS_TASK_STATUS_CANCELED = 1,
}
#[doc = " A scheduled function."]
pub type aws_task_fn = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut aws_task,
        arg: *mut ::std::os::raw::c_void,
        arg1: aws_task_status,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_task {
    pub fn_: aws_task_fn,
    pub arg: *mut ::std::os::raw::c_void,
    pub timestamp: u64,
    pub node: aws_linked_list_node,
    pub priority_queue_node: aws_priority_queue_node,
    pub type_tag: *const ::std::os::raw::c_char,
    pub abi_extension: aws_task__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aws_task__bindgen_ty_1 {
    pub scheduled: bool,
    pub reserved: usize,
}
#[test]
fn bindgen_test_layout_aws_task__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<aws_task__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_task__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(aws_task__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_task__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheduled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task__bindgen_ty_1),
            "::",
            stringify!(scheduled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_aws_task() {
    const UNINIT: ::std::mem::MaybeUninit<aws_task> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_task>(),
        64usize,
        concat!("Size of: ", stringify!(aws_task))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_task>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_queue_node) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(priority_queue_node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_tag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(type_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abi_extension) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task),
            "::",
            stringify!(abi_extension)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_task_scheduler {
    pub alloc: *mut aws_allocator,
    pub timed_queue: aws_priority_queue,
    pub timed_list: aws_linked_list,
    pub asap_list: aws_linked_list,
}
#[test]
fn bindgen_test_layout_aws_task_scheduler() {
    const UNINIT: ::std::mem::MaybeUninit<aws_task_scheduler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_task_scheduler>(),
        160usize,
        concat!("Size of: ", stringify!(aws_task_scheduler))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_task_scheduler>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_task_scheduler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timed_queue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(timed_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timed_list) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(timed_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asap_list) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_task_scheduler),
            "::",
            stringify!(asap_list)
        )
    );
}
extern "C" {
    #[doc = " Init an aws_task"]
    pub fn aws_task_init(
        task: *mut aws_task,
        fn_: aws_task_fn,
        arg: *mut ::std::os::raw::c_void,
        type_tag: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn aws_task_run(task: *mut aws_task, status: aws_task_status);
}
extern "C" {
    #[doc = " Initializes a task scheduler instance."]
    pub fn aws_task_scheduler_init(
        scheduler: *mut aws_task_scheduler,
        alloc: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Empties and executes all queued tasks, passing the AWS_TASK_STATUS_CANCELED status to the task function.\n Cleans up any memory allocated, and prepares the instance for reuse or deletion."]
    pub fn aws_task_scheduler_clean_up(scheduler: *mut aws_task_scheduler);
}
extern "C" {
    pub fn aws_task_scheduler_is_valid(scheduler: *const aws_task_scheduler) -> bool;
}
extern "C" {
    #[doc = " Returns whether the scheduler has any scheduled tasks.\n next_task_time (optional) will be set to time of the next task, note that 0 will be set if tasks were\n added via aws_task_scheduler_schedule_now() and UINT64_MAX will be set if no tasks are scheduled at all."]
    pub fn aws_task_scheduler_has_tasks(
        scheduler: *const aws_task_scheduler,
        next_task_time: *mut u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Schedules a task to run immediately.\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_task_scheduler_schedule_now(scheduler: *mut aws_task_scheduler, task: *mut aws_task);
}
extern "C" {
    #[doc = " Schedules a task to run at time_to_run.\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_task_scheduler_schedule_future(
        scheduler: *mut aws_task_scheduler,
        task: *mut aws_task,
        time_to_run: u64,
    );
}
extern "C" {
    #[doc = " Removes task from the scheduler and invokes the task with the AWS_TASK_STATUS_CANCELED status."]
    pub fn aws_task_scheduler_cancel_task(scheduler: *mut aws_task_scheduler, task: *mut aws_task);
}
extern "C" {
    #[doc = " Sequentially execute all tasks scheduled to run at, or before current_time.\n AWS_TASK_STATUS_RUN_READY will be passed to the task function as the task status.\n\n If a task schedules another task, the new task will not be executed until the next call to this function."]
    pub fn aws_task_scheduler_run_all(scheduler: *mut aws_task_scheduler, current_time: u64);
}
extern "C" {
    #[doc = " Convert a status value to a c-string suitable for logging"]
    pub fn aws_task_status_to_c_str(status: aws_task_status) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_channel_direction {
    AWS_CHANNEL_DIR_READ = 0,
    AWS_CHANNEL_DIR_WRITE = 1,
}
pub type aws_channel_on_setup_completed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_channel,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type aws_channel_on_shutdown_completed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        channel: *mut aws_channel,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_slot {
    pub alloc: *mut aws_allocator,
    pub channel: *mut aws_channel,
    pub adj_left: *mut aws_channel_slot,
    pub adj_right: *mut aws_channel_slot,
    pub handler: *mut aws_channel_handler,
    pub window_size: usize,
    pub upstream_message_overhead: usize,
    pub current_window_update_batch_size: usize,
}
#[test]
fn bindgen_test_layout_aws_channel_slot() {
    const UNINIT: ::std::mem::MaybeUninit<aws_channel_slot> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_channel_slot>(),
        64usize,
        concat!("Size of: ", stringify!(aws_channel_slot))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_channel_slot>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_channel_slot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adj_left) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(adj_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adj_right) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(adj_right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(window_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upstream_message_overhead) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(upstream_message_overhead)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).current_window_update_batch_size) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_slot),
            "::",
            stringify!(current_window_update_batch_size)
        )
    );
}
pub type aws_channel_task_fn = ::std::option::Option<
    unsafe extern "C" fn(
        channel_task: *mut aws_channel_task,
        arg: *mut ::std::os::raw::c_void,
        status: aws_task_status,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_channel_task {
    pub wrapper_task: aws_task,
    pub task_fn: aws_channel_task_fn,
    pub arg: *mut ::std::os::raw::c_void,
    pub type_tag: *const ::std::os::raw::c_char,
    pub node: aws_linked_list_node,
}
#[test]
fn bindgen_test_layout_aws_channel_task() {
    const UNINIT: ::std::mem::MaybeUninit<aws_channel_task> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_channel_task>(),
        104usize,
        concat!("Size of: ", stringify!(aws_channel_task))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_channel_task>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_channel_task))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrapper_task) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_task),
            "::",
            stringify!(wrapper_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).task_fn) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_task),
            "::",
            stringify!(task_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_task),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_tag) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_task),
            "::",
            stringify!(type_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_task),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_handler_vtable {
    #[doc = " Called by the channel when a message is available for processing in the read direction. It is your\n responsibility to call aws_mem_release(message->allocator, message); on message when you are finished with it.\n You must only call `aws_mem_release(message->allocator, message);` if the `process_read_message`\n returns AWS_OP_SUCCESS. In case of an error, you must not clean up the message and should just raise the error.\n\n Also keep in mind that your slot's internal window has been decremented. You'll want to call\n aws_channel_slot_increment_read_window() at some point in the future if you want to keep receiving data."]
    pub process_read_message: ::std::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            message: *mut aws_io_message,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called by the channel when a message is available for processing in the write direction. It is your\n responsibility to call aws_mem_release(message->allocator, message); on message when you are finished with it.\n You must only call `aws_mem_release(message->allocator, message);` if the `process_read_message`\n returns AWS_OP_SUCCESS. In case of an error, you must not clean up the message and should just raise the error."]
    pub process_write_message: ::std::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            message: *mut aws_io_message,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called by the channel when a downstream handler has issued a window increment. You'll want to update your\n internal state and likely propagate a window increment message of your own by calling\n 'aws_channel_slot_increment_read_window()'"]
    pub increment_read_window: ::std::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " The channel calls shutdown on all handlers twice, once to shut down reading, and once to shut down writing.\n Shutdown always begins with the left-most handler, and proceeds to the right with dir set to\n AWS_CHANNEL_DIR_READ. Then shutdown is called on handlers from right to left with dir set to\n AWS_CHANNEL_DIR_WRITE.\n\n The shutdown process does not need to complete immediately and may rely on scheduled tasks.\n The handler must call aws_channel_slot_on_handler_shutdown_complete() when it is finished,\n which propagates shutdown to the next handler.  If 'free_scarce_resources_immediately' is true,\n then resources vulnerable to denial-of-service attacks (such as sockets and file handles)\n must be closed immediately before the shutdown() call returns."]
    pub shutdown: ::std::option::Option<
        unsafe extern "C" fn(
            handler: *mut aws_channel_handler,
            slot: *mut aws_channel_slot,
            dir: aws_channel_direction,
            error_code: ::std::os::raw::c_int,
            free_scarce_resources_immediately: bool,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Called by the channel when the handler is added to a slot, to get the initial window size."]
    pub initial_window_size:
        ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler) -> usize>,
    #[doc = " Called by the channel anytime a handler is added or removed, provides a hint for downstream\n handlers to avoid message fragmentation due to message overhead."]
    pub message_overhead:
        ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler) -> usize>,
    #[doc = " Clean up any resources and deallocate yourself. The shutdown process will already be completed before this\n function is called."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler)>,
    #[doc = " Directs the channel handler to reset all of the internal statistics it tracks about itself."]
    pub reset_statistics:
        ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler)>,
    #[doc = " Adds a pointer to the handler's internal statistics (if they exist) to a list of statistics structures\n associated with the channel's handler chain."]
    pub gather_statistics: ::std::option::Option<
        unsafe extern "C" fn(handler: *mut aws_channel_handler, stats_list: *mut aws_array_list),
    >,
    pub trigger_read:
        ::std::option::Option<unsafe extern "C" fn(handler: *mut aws_channel_handler)>,
}
#[test]
fn bindgen_test_layout_aws_channel_handler_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_channel_handler_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_channel_handler_vtable>(),
        80usize,
        concat!("Size of: ", stringify!(aws_channel_handler_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_channel_handler_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_channel_handler_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_read_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(process_read_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_write_message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(process_write_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).increment_read_window) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(increment_read_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_window_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(initial_window_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_overhead) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(message_overhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset_statistics) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(reset_statistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gather_statistics) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(gather_statistics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger_read) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler_vtable),
            "::",
            stringify!(trigger_read)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_handler {
    pub vtable: *mut aws_channel_handler_vtable,
    pub alloc: *mut aws_allocator,
    pub slot: *mut aws_channel_slot,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_channel_handler() {
    const UNINIT: ::std::mem::MaybeUninit<aws_channel_handler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_channel_handler>(),
        32usize,
        concat!("Size of: ", stringify!(aws_channel_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_channel_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_channel_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_handler),
            "::",
            stringify!(impl_)
        )
    );
}
#[doc = " Args for creating a new channel.\n  event_loop to use for IO and tasks. on_setup_completed will be invoked when\n  the setup process is finished It will be executed in the event loop's thread.\n  on_shutdown_completed will be executed upon channel shutdown.\n\n  enable_read_back_pressure toggles whether or not back pressure will be applied in the channel.\n  Leave this option off unless you're using something like reactive-streams, since it is a slight throughput\n  penalty.\n\n  Unless otherwise\n  specified all functions for channels and channel slots must be executed within that channel's event-loop's thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_channel_options {
    pub event_loop: *mut aws_event_loop,
    pub on_setup_completed: aws_channel_on_setup_completed_fn,
    pub on_shutdown_completed: aws_channel_on_shutdown_completed_fn,
    pub setup_user_data: *mut ::std::os::raw::c_void,
    pub shutdown_user_data: *mut ::std::os::raw::c_void,
    pub enable_read_back_pressure: bool,
}
#[test]
fn bindgen_test_layout_aws_channel_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_channel_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_channel_options>(),
        48usize,
        concat!("Size of: ", stringify!(aws_channel_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_channel_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_channel_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_loop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_options),
            "::",
            stringify!(event_loop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_setup_completed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_options),
            "::",
            stringify!(on_setup_completed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_shutdown_completed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_options),
            "::",
            stringify!(on_shutdown_completed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup_user_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_options),
            "::",
            stringify!(setup_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_options),
            "::",
            stringify!(shutdown_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_read_back_pressure) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_channel_options),
            "::",
            stringify!(enable_read_back_pressure)
        )
    );
}
extern "C" {
    pub static mut g_aws_channel_max_fragment_size: usize;
}
extern "C" {
    #[doc = " Initializes channel_task for use."]
    pub fn aws_channel_task_init(
        channel_task: *mut aws_channel_task,
        task_fn: aws_channel_task_fn,
        arg: *mut ::std::os::raw::c_void,
        type_tag: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Allocates new channel, Unless otherwise specified all functions for channels and channel slots must be executed\n within that channel's event-loop's thread. channel_options are copied."]
    pub fn aws_channel_new(
        allocator: *mut aws_allocator,
        creation_args: *const aws_channel_options,
    ) -> *mut aws_channel;
}
extern "C" {
    #[doc = " Mark the channel, along with all slots and handlers, for destruction.\n Must be called after shutdown has completed.\n Can be called from any thread assuming 'aws_channel_shutdown()' has completed.\n Note that memory will not be freed until all users which acquired holds on the channel via\n aws_channel_acquire_hold(), release them via aws_channel_release_hold()."]
    pub fn aws_channel_destroy(channel: *mut aws_channel);
}
extern "C" {
    #[doc = " Initiates shutdown of the channel. Shutdown will begin with the left-most slot. Each handler will invoke\n 'aws_channel_slot_on_handler_shutdown_complete' once they've finished their shutdown process for the read direction.\n Once the right-most slot has shutdown in the read direction, the process will start shutting down starting on the\n right-most slot. Once the left-most slot has shutdown in the write direction, 'callbacks->shutdown_completed' will be\n invoked in the event loop's thread.\n\n This function can be called from any thread."]
    pub fn aws_channel_shutdown(
        channel: *mut aws_channel,
        error_code: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Prevent a channel's memory from being freed.\n Any number of users may acquire a hold to prevent a channel and its handlers from being unexpectedly freed.\n Any user which acquires a hold must release it via aws_channel_release_hold().\n Memory will be freed once all holds are released and aws_channel_destroy() has been called."]
    pub fn aws_channel_acquire_hold(channel: *mut aws_channel);
}
extern "C" {
    #[doc = " Release a hold on the channel's memory, allowing it to be freed.\n This may be called before or after aws_channel_destroy()."]
    pub fn aws_channel_release_hold(channel: *mut aws_channel);
}
extern "C" {
    #[doc = " Allocates and initializes a new slot for use with the channel. If this is the first slot in the channel, it will\n automatically be added to the channel as the first slot. For all subsequent calls on a given channel, the slot will\n need to be added to the channel via. the aws_channel_slot_insert_right(), aws_channel_slot_insert_end(), and\n aws_channel_slot_insert_left() APIs."]
    pub fn aws_channel_slot_new(channel: *mut aws_channel) -> *mut aws_channel_slot;
}
extern "C" {
    #[doc = " Fetches the event loop the channel is a part of."]
    pub fn aws_channel_get_event_loop(channel: *mut aws_channel) -> *mut aws_event_loop;
}
extern "C" {
    #[doc = " Fetches the current timestamp from the event-loop's clock, in nanoseconds."]
    pub fn aws_channel_current_clock_time(
        channel: *mut aws_channel,
        time_nanos: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves an object by key from the event loop's local storage."]
    pub fn aws_channel_fetch_local_object(
        channel: *mut aws_channel,
        key: *const ::std::os::raw::c_void,
        obj: *mut aws_event_loop_local_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stores an object by key in the event loop's local storage."]
    pub fn aws_channel_put_local_object(
        channel: *mut aws_channel,
        key: *const ::std::os::raw::c_void,
        obj: *const aws_event_loop_local_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes an object by key from the event loop's local storage."]
    pub fn aws_channel_remove_local_object(
        channel: *mut aws_channel,
        key: *const ::std::os::raw::c_void,
        removed_obj: *mut aws_event_loop_local_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Acquires a message from the event loop's message pool. size_hint is merely a hint, it may be smaller than you\n requested and you are responsible for checking the bounds of it. If the returned message is not large enough, you\n must send multiple messages. This cannot fail, it never returns NULL."]
    pub fn aws_channel_acquire_message_from_pool(
        channel: *mut aws_channel,
        message_type: aws_io_message_type,
        size_hint: usize,
    ) -> *mut aws_io_message;
}
extern "C" {
    #[doc = " Schedules a task to run on the event loop as soon as possible.\n This is the ideal way to move a task into the correct thread. It's also handy for context switches.\n This function is safe to call from any thread.\n\n If called from the channel's event loop, the task will get directly added to the run-now list.\n If called from outside the channel's event loop, the task will go into a cross-thread task queue.\n\n If tasks must be serialized relative to some source synchronization, you may not want to use this API\n because tasks submitted from the event loop thread can \"jump ahead\" of tasks submitted from external threads\n due to this optimization.  If this is a problem, you can either refactor your submission logic or use\n the aws_channel_schedule_task_now_serialized variant which does not perform this optimization.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_channel_schedule_task_now(channel: *mut aws_channel, task: *mut aws_channel_task);
}
extern "C" {
    #[doc = " Schedules a task to run on the event loop as soon as possible.\n\n This variant always uses the cross thread queue rather than conditionally skipping it when already in\n the destination event loop.  While not \"optimal\", this allows us to serialize task execution no matter where\n the task was submitted from: if you are submitting tasks from a critical section, the serialized order that you\n submit is guaranteed to be the order that they execute on the event loop.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_channel_schedule_task_now_serialized(
        channel: *mut aws_channel,
        task: *mut aws_channel_task,
    );
}
extern "C" {
    #[doc = " Schedules a task to run on the event loop at the specified time.\n This is the ideal way to move a task into the correct thread. It's also handy for context switches.\n Use aws_channel_current_clock_time() to get the current time in nanoseconds.\n This function is safe to call from any thread.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_channel_schedule_task_future(
        channel: *mut aws_channel,
        task: *mut aws_channel_task,
        run_at_nanos: u64,
    );
}
extern "C" {
    #[doc = " Instrument a channel with a statistics handler.  While instrumented with a statistics handler, the channel\n will periodically report per-channel-handler-specific statistics about handler performance and state.\n\n Assigning a statistics handler to a channel is a transfer of ownership -- the channel will clean up\n the handler appropriately.  Statistics handlers may be changed dynamically (for example, the upgrade\n from a vanilla http channel to a websocket channel), but this function may only be called from the\n event loop thread that the channel is a part of.\n\n The first possible hook to set a statistics handler is the channel's creation callback."]
    pub fn aws_channel_set_statistics_handler(
        channel: *mut aws_channel,
        handler: *mut aws_crt_statistics_handler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the caller is on the event loop's thread. If false, you likely need to use\n aws_channel_schedule_task(). This function is safe to call from any thread."]
    pub fn aws_channel_thread_is_callers_thread(channel: *mut aws_channel) -> bool;
}
extern "C" {
    #[doc = " Sets the handler for a slot, the slot will also call get_current_window_size() and propagate a window update\n upstream."]
    pub fn aws_channel_slot_set_handler(
        slot: *mut aws_channel_slot,
        handler: *mut aws_channel_handler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes slot from the channel and deallocates the slot and its handler."]
    pub fn aws_channel_slot_remove(slot: *mut aws_channel_slot) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replaces remove with new_slot. Deallocates remove and its handler."]
    pub fn aws_channel_slot_replace(
        remove: *mut aws_channel_slot,
        new_slot: *mut aws_channel_slot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " inserts 'to_add' to the position immediately to the right of slot. Note that the first call to\n aws_channel_slot_new() adds it to the channel implicitly."]
    pub fn aws_channel_slot_insert_right(
        slot: *mut aws_channel_slot,
        to_add: *mut aws_channel_slot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts to 'to_add' the end of the channel. Note that the first call to\n aws_channel_slot_new() adds it to the channel implicitly."]
    pub fn aws_channel_slot_insert_end(
        channel: *mut aws_channel,
        to_add: *mut aws_channel_slot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " inserts 'to_add' to the position immediately to the left of slot. Note that the first call to\n aws_channel_slot_new() adds it to the channel implicitly."]
    pub fn aws_channel_slot_insert_left(
        slot: *mut aws_channel_slot,
        to_add: *mut aws_channel_slot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends a message to the adjacent slot in the channel based on dir. Also does window size checking.\n\n NOTE: if this function returns an error code, it is the caller's responsibility to release message\n back to the pool. If this function returns AWS_OP_SUCCESS, the recipient of the message has taken\n ownership of the message. So, for example, don't release a message to the pool and then return an error.\n If you encounter an error condition in this case, shutdown the channel with the appropriate error code."]
    pub fn aws_channel_slot_send_message(
        slot: *mut aws_channel_slot,
        message: *mut aws_io_message,
        dir: aws_channel_direction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function that invokes aws_channel_acquire_message_from_pool(),\n asking for the largest reasonable DATA message that can be sent in the write direction,\n with upstream overhead accounted for. This cannot fail, it never returns NULL."]
    pub fn aws_channel_slot_acquire_max_message_for_write(
        slot: *mut aws_channel_slot,
    ) -> *mut aws_io_message;
}
extern "C" {
    #[doc = " Issues a window update notification upstream (to the left.)"]
    pub fn aws_channel_slot_increment_read_window(
        slot: *mut aws_channel_slot,
        window: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Called by handlers once they have finished their shutdown in the 'dir' direction. Propagates the shutdown process\n to the next handler in the channel."]
    pub fn aws_channel_slot_on_handler_shutdown_complete(
        slot: *mut aws_channel_slot,
        dir: aws_channel_direction,
        err_code: ::std::os::raw::c_int,
        free_scarce_resources_immediately: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates shutdown on slot. callbacks->on_shutdown_completed will be called\n once the shutdown process is completed."]
    pub fn aws_channel_slot_shutdown(
        slot: *mut aws_channel_slot,
        dir: aws_channel_direction,
        err_code: ::std::os::raw::c_int,
        free_scarce_resources_immediately: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fetches the downstream read window. This gives you the information necessary to honor the read window. If you call\n send_message() and it exceeds this window, the message will be rejected."]
    pub fn aws_channel_slot_downstream_read_window(slot: *mut aws_channel_slot) -> usize;
}
extern "C" {
    #[doc = " Fetches the current overhead of upstream handlers. This provides a hint to avoid fragmentation if you care."]
    pub fn aws_channel_slot_upstream_message_overhead(slot: *mut aws_channel_slot) -> usize;
}
extern "C" {
    #[doc = " Calls destroy on handler's vtable"]
    pub fn aws_channel_handler_destroy(handler: *mut aws_channel_handler);
}
extern "C" {
    #[doc = " Calls process_read_message on handler's vtable"]
    pub fn aws_channel_handler_process_read_message(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        message: *mut aws_io_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls process_write_message on handler's vtable."]
    pub fn aws_channel_handler_process_write_message(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        message: *mut aws_io_message,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls on_window_update on handler's vtable."]
    pub fn aws_channel_handler_increment_read_window(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " calls shutdown_direction on handler's vtable."]
    pub fn aws_channel_handler_shutdown(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        dir: aws_channel_direction,
        error_code: ::std::os::raw::c_int,
        free_scarce_resources_immediately: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls initial_window_size on handler's vtable."]
    pub fn aws_channel_handler_initial_window_size(handler: *mut aws_channel_handler) -> usize;
}
extern "C" {
    pub fn aws_channel_get_first_slot(channel: *mut aws_channel) -> *mut aws_channel_slot;
}
extern "C" {
    #[doc = " A way for external processes to force a read by the data-source channel handler.  Necessary in certain cases, like\n when a server channel finishes setting up its initial handlers, a read may have already been triggered on the\n socket (the client's CLIENT_HELLO tls payload, for example) and absent further data/notifications, this data\n would never get processed."]
    pub fn aws_channel_trigger_read(channel: *mut aws_channel) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_address_record_type {
    AWS_ADDRESS_RECORD_TYPE_A = 0,
    AWS_ADDRESS_RECORD_TYPE_AAAA = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_get_host_address_flags {
    AWS_GET_HOST_ADDRESS_COUNT_RECORD_TYPE_A = 1,
    AWS_GET_HOST_ADDRESS_COUNT_RECORD_TYPE_AAAA = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_address {
    pub allocator: *mut aws_allocator,
    pub host: *const aws_string,
    pub address: *const aws_string,
    pub record_type: aws_address_record_type,
    pub expiry: u64,
    pub use_count: usize,
    pub connection_failure_count: usize,
    pub weight: u8,
}
#[test]
fn bindgen_test_layout_aws_host_address() {
    const UNINIT: ::std::mem::MaybeUninit<aws_host_address> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_host_address>(),
        64usize,
        concat!("Size of: ", stringify!(aws_host_address))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_host_address>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_host_address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(record_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(expiry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(use_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_failure_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(connection_failure_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weight) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_address),
            "::",
            stringify!(weight)
        )
    );
}
#[doc = " Invoked once an address has been resolved for host. The type in host_addresses is struct aws_host_address (by-value).\n The caller does not own this memory and you must copy the host address before returning from this function if you\n plan to use it later. For convenience, we've provided the aws_host_address_copy() and aws_host_address_clean_up()\n functions."]
pub type aws_on_host_resolved_result_fn = ::std::option::Option<
    unsafe extern "C" fn(
        resolver: *mut aws_host_resolver,
        host_name: *const aws_string,
        err_code: ::std::os::raw::c_int,
        host_addresses: *const aws_array_list,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Function signature for configuring your own resolver (the default just uses getaddrinfo()). The type in\n output_addresses is struct aws_host_address (by-value). We assume this function blocks, hence this absurdly\n complicated design."]
pub type aws_resolve_host_implementation_fn = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: *mut aws_allocator,
        host_name: *const aws_string,
        output_addresses: *mut aws_array_list,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolution_config {
    pub impl_: aws_resolve_host_implementation_fn,
    pub max_ttl: usize,
    pub impl_data: *mut ::std::os::raw::c_void,
    pub resolve_frequency_ns: u64,
}
#[test]
fn bindgen_test_layout_aws_host_resolution_config() {
    const UNINIT: ::std::mem::MaybeUninit<aws_host_resolution_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_host_resolution_config>(),
        32usize,
        concat!("Size of: ", stringify!(aws_host_resolution_config))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_host_resolution_config>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_host_resolution_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolution_config),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_ttl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolution_config),
            "::",
            stringify!(max_ttl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolution_config),
            "::",
            stringify!(impl_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve_frequency_ns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolution_config),
            "::",
            stringify!(resolve_frequency_ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_listener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_listener_options {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver_purge_host_options {
    pub host: *const aws_string,
    pub on_host_purge_complete_callback: aws_simple_completion_callback,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_host_resolver_purge_host_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_host_resolver_purge_host_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_host_resolver_purge_host_options>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(aws_host_resolver_purge_host_options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aws_host_resolver_purge_host_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_host_resolver_purge_host_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_purge_host_options),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).on_host_purge_complete_callback) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_purge_host_options),
            "::",
            stringify!(on_host_purge_complete_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_purge_host_options),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " should you absolutely disdain the default implementation, feel free to implement your own."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver_vtable {
    #[doc = " clean up everything you allocated, but not resolver itself."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(resolver: *mut aws_host_resolver)>,
    #[doc = " resolve the host by host_name, the user owns host_name, so it needs to be copied if you persist it,\n invoke res with the result. This function should never block."]
    pub resolve_host: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            host_name: *const aws_string,
            res: aws_on_host_resolved_result_fn,
            config: *const aws_host_resolution_config,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " gives your implementation a hint that an address has some failed connections occuring. Do whatever you want (or\n nothing) about it."]
    pub record_connection_failure: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            address: *const aws_host_address,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @Deprecated Use purge_cache_with_callback instead\n wipe out anything you have cached."]
    pub purge_cache: ::std::option::Option<
        unsafe extern "C" fn(resolver: *mut aws_host_resolver) -> ::std::os::raw::c_int,
    >,
    #[doc = " wipe out anything you have cached."]
    pub purge_cache_with_callback: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            on_purge_cache_complete_callback: aws_simple_completion_callback,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " wipe out anything cached for a specific host"]
    pub purge_host_cache: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            options: *const aws_host_resolver_purge_host_options,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get number of addresses for a given host."]
    pub get_host_address_count: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut aws_host_resolver,
            host_name: *const aws_string,
            flags: u32,
        ) -> usize,
    >,
}
#[test]
fn bindgen_test_layout_aws_host_resolver_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_host_resolver_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_host_resolver_vtable>(),
        56usize,
        concat!("Size of: ", stringify!(aws_host_resolver_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_host_resolver_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_host_resolver_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve_host) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(resolve_host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_connection_failure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(record_connection_failure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).purge_cache) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(purge_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).purge_cache_with_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(purge_cache_with_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).purge_host_cache) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(purge_host_cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_host_address_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_vtable),
            "::",
            stringify!(get_host_address_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver {
    pub allocator: *mut aws_allocator,
    pub impl_: *mut ::std::os::raw::c_void,
    pub vtable: *mut aws_host_resolver_vtable,
    pub ref_count: aws_ref_count,
    pub shutdown_options: aws_shutdown_callback_options,
}
#[test]
fn bindgen_test_layout_aws_host_resolver() {
    const UNINIT: ::std::mem::MaybeUninit<aws_host_resolver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_host_resolver>(),
        64usize,
        concat!("Size of: ", stringify!(aws_host_resolver))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_host_resolver>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_host_resolver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_options) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver),
            "::",
            stringify!(shutdown_options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_host_resolver_default_options {
    pub max_entries: usize,
    pub el_group: *mut aws_event_loop_group,
    pub shutdown_options: *const aws_shutdown_callback_options,
    pub system_clock_override_fn: aws_io_clock_fn,
}
#[test]
fn bindgen_test_layout_aws_host_resolver_default_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_host_resolver_default_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_host_resolver_default_options>(),
        32usize,
        concat!("Size of: ", stringify!(aws_host_resolver_default_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_host_resolver_default_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_host_resolver_default_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_default_options),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_default_options),
            "::",
            stringify!(el_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_default_options),
            "::",
            stringify!(shutdown_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).system_clock_override_fn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_host_resolver_default_options),
            "::",
            stringify!(system_clock_override_fn)
        )
    );
}
extern "C" {
    #[doc = " Copies `from` to `to`."]
    pub fn aws_host_address_copy(
        from: *const aws_host_address,
        to: *mut aws_host_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Moves `from` to `to`. After this call, from is no longer usable. Though, it could be resused for another\n move or copy operation."]
    pub fn aws_host_address_move(from: *mut aws_host_address, to: *mut aws_host_address);
}
extern "C" {
    #[doc = " Cleans up the memory for `address`"]
    pub fn aws_host_address_clean_up(address: *mut aws_host_address);
}
extern "C" {
    #[doc = " WARNING! do not call this function directly (getaddrinfo()): it blocks. Provide a pointer to this function for other\n resolution functions."]
    pub fn aws_default_dns_resolve(
        allocator: *mut aws_allocator,
        host_name: *const aws_string,
        output_addresses: *mut aws_array_list,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a host resolver with the default behavior. Here's the behavior:\n\n Since there's not a reliable way to do non-blocking DNS without a ton of risky work that would need years of testing\n on every Unix system in existence, we work around it by doing a threaded implementation.\n\n When you request an address, it checks the cache. If the entry isn't in the cache it creates a new one.\n Each entry has a potentially short lived back-ground thread based on ttl for the records. Once we've populated the\n cache and you keep the resolver active, the resolution callback will be invoked immediately. When it's idle, it will\n take a little while in the background thread to fetch more, evaluate TTLs etc... In that case your callback will be\n invoked from the background thread.\n\n --------------------------------------------------------------------------------------------------------------------\n\n A few things to note about TTLs and connection failures.\n\n We attempt to honor your max ttl but will not honor it if dns queries are failing or all of your connections are\n marked as failed. Once we are able to query dns again, we will re-evaluate the TTLs.\n\n Upon notification connection failures, we move them to a separate list. Eventually we retry them when it's likely\n that the endpoint is healthy again or we don't really have another choice, but we try to keep them out of your\n hot path.\n\n ---------------------------------------------------------------------------------------------------------------------\n\n Finally, this entire design attempts to prevent problems where developers have to choose between large TTLs and thus\n sticky hosts or short TTLs and good fleet utilization but now higher latencies. In this design, we resolve every\n second in the background (only while you're actually using the record), but we do not expire the earlier resolved\n addresses until max ttl has passed.\n\n This for example, should enable you to hit thousands of hosts in the Amazon S3 fleet instead of just one or two."]
    pub fn aws_host_resolver_new_default(
        allocator: *mut aws_allocator,
        options: *const aws_host_resolver_default_options,
    ) -> *mut aws_host_resolver;
}
extern "C" {
    #[doc = " Increments the reference count on the host resolver, allowing the caller to take a reference to it.\n\n Returns the same host resolver passed in."]
    pub fn aws_host_resolver_acquire(resolver: *mut aws_host_resolver) -> *mut aws_host_resolver;
}
extern "C" {
    #[doc = " Decrements a host resolver's ref count.  When the ref count drops to zero, the resolver will be destroyed."]
    pub fn aws_host_resolver_release(resolver: *mut aws_host_resolver);
}
extern "C" {
    #[doc = " calls resolve_host on the vtable. config will be copied."]
    pub fn aws_host_resolver_resolve_host(
        resolver: *mut aws_host_resolver,
        host_name: *const aws_string,
        res: aws_on_host_resolved_result_fn,
        config: *const aws_host_resolution_config,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " calls record_connection_failure on the vtable."]
    pub fn aws_host_resolver_record_connection_failure(
        resolver: *mut aws_host_resolver,
        address: *const aws_host_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @Deprecated Use purge_cache_with_callback instead\n calls purge_cache on the vtable."]
    pub fn aws_host_resolver_purge_cache(resolver: *mut aws_host_resolver)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls aws_host_resolver_purge_cache_with_callback on the vtable which will wipe out everything host resolver has\n cached."]
    pub fn aws_host_resolver_purge_cache_with_callback(
        resolver: *mut aws_host_resolver,
        on_purge_cache_complete_callback: aws_simple_completion_callback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes the cache for a host asynchronously."]
    pub fn aws_host_resolver_purge_host_cache(
        resolver: *mut aws_host_resolver,
        options: *const aws_host_resolver_purge_host_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get number of addresses for a given host."]
    pub fn aws_host_resolver_get_host_address_count(
        resolver: *mut aws_host_resolver,
        host_name: *const aws_string,
        flags: u32,
    ) -> usize;
}
extern "C" {
    #[doc = " Returns the default host resolution config used internally if none specified.\n\n @return default host resolution config"]
    pub fn aws_host_resolver_init_default_resolution_config() -> aws_host_resolution_config;
}
#[doc = " Generic event function for channel lifecycle events.\n\n Callbacks are provided for:\n   (1) Channel creation\n   (2) Channel setup - If TLS is being used, this function is called once the socket has connected, the channel has\n been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If\n TLS negotiation fails, this function will be called with the corresponding error code. If TLS is not being used, this\n function is called once the socket has connected and the channel has been initialized.\n   (3) Channel shutdown\n\n These callbacks are always invoked within the thread of the event-loop that the channel is assigned to.\n\n This function does NOT always imply \"success\" -- if error_code is AWS_OP_SUCCESS then everything was successful,\n otherwise an error condition occurred."]
pub type aws_client_bootstrap_on_channel_event_fn = ::std::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_client_bootstrap,
        error_code: ::std::os::raw::c_int,
        channel: *mut aws_channel,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " If ALPN is being used this function will be invoked by the channel once an ALPN message is received. The returned\n channel_handler will be added to, and managed by, the channel."]
pub type aws_channel_on_protocol_negotiated_fn = ::std::option::Option<
    unsafe extern "C" fn(
        new_slot: *mut aws_channel_slot,
        protocol: *mut aws_byte_buf,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut aws_channel_handler,
>;
#[doc = " Called after client bootstrap has been completely cleaned up, after its last refcount is released."]
pub type aws_client_bootstrap_shutdown_complete_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = " aws_client_bootstrap handles creation and setup of channels that communicate via socket with a specific endpoint."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_client_bootstrap {
    pub allocator: *mut aws_allocator,
    pub event_loop_group: *mut aws_event_loop_group,
    pub host_resolver: *mut aws_host_resolver,
    pub host_resolver_config: aws_host_resolution_config,
    pub on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    pub ref_count: aws_ref_count,
    pub on_shutdown_complete: aws_client_bootstrap_shutdown_complete_fn,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_client_bootstrap() {
    const UNINIT: ::std::mem::MaybeUninit<aws_client_bootstrap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_client_bootstrap>(),
        104usize,
        concat!("Size of: ", stringify!(aws_client_bootstrap))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_client_bootstrap>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_client_bootstrap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_loop_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(event_loop_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_resolver) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(host_resolver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_resolver_config) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(host_resolver_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_protocol_negotiated) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(on_protocol_negotiated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_shutdown_complete) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(on_shutdown_complete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " aws_client_bootstrap creation options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_client_bootstrap_options {
    pub event_loop_group: *mut aws_event_loop_group,
    pub host_resolver: *mut aws_host_resolver,
    pub host_resolution_config: *const aws_host_resolution_config,
    pub on_shutdown_complete: aws_client_bootstrap_shutdown_complete_fn,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_client_bootstrap_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_client_bootstrap_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_client_bootstrap_options>(),
        40usize,
        concat!("Size of: ", stringify!(aws_client_bootstrap_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_client_bootstrap_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_client_bootstrap_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_loop_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap_options),
            "::",
            stringify!(event_loop_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_resolver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap_options),
            "::",
            stringify!(host_resolver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_resolution_config) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap_options),
            "::",
            stringify!(host_resolution_config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_shutdown_complete) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap_options),
            "::",
            stringify!(on_shutdown_complete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_client_bootstrap_options),
            "::",
            stringify!(user_data)
        )
    );
}
#[doc = " If TLS is being used, this function is called once the socket has received an incoming connection, the channel has\n been initialized, and TLS has been successfully negotiated. A TLS handler has already been added to the channel. If\n TLS negotiation fails, this function will be called with the corresponding error code.\n\n If TLS is not being used, this function is called once the socket has received an incoming connection and the channel\n has been initialized.\n\n This function is always called within the thread of the event-loop that the new channel is assigned to upon success.\n\n On failure, the channel might not be assigned to an event loop yet, and will thus be invoked on the listener's\n event-loop thread.\n\n This function does NOT mean \"success\", if error_code is AWS_OP_SUCCESS then everything was successful, otherwise an\n error condition occurred.\n\n If an error occurred, you do not need to shutdown the channel. The `aws_channel_client_shutdown_callback` will be\n invoked once the channel has finished shutting down."]
pub type aws_server_bootstrap_on_accept_channel_setup_fn = ::std::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_server_bootstrap,
        error_code: ::std::os::raw::c_int,
        channel: *mut aws_channel,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Once the channel shuts down, this function will be invoked within the thread of\n the event-loop that the channel is assigned to.\n\n Note: this function is only invoked if the channel was successfully setup,\n e.g. aws_server_bootstrap_on_accept_channel_setup_fn() was invoked without an error code."]
pub type aws_server_bootstrap_on_accept_channel_shutdown_fn = ::std::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_server_bootstrap,
        error_code: ::std::os::raw::c_int,
        channel: *mut aws_channel,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Once the server listener socket is finished destroying, and all the existing connections are closed, this fuction\n will be invoked."]
pub type aws_server_bootstrap_on_server_listener_destroy_fn = ::std::option::Option<
    unsafe extern "C" fn(
        bootstrap: *mut aws_server_bootstrap,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " aws_server_bootstrap manages listening sockets, creating and setting up channels to handle each incoming connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_server_bootstrap {
    pub allocator: *mut aws_allocator,
    pub event_loop_group: *mut aws_event_loop_group,
    pub on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    pub ref_count: aws_ref_count,
}
#[test]
fn bindgen_test_layout_aws_server_bootstrap() {
    const UNINIT: ::std::mem::MaybeUninit<aws_server_bootstrap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_server_bootstrap>(),
        48usize,
        concat!("Size of: ", stringify!(aws_server_bootstrap))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_server_bootstrap>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_server_bootstrap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_bootstrap),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_loop_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_bootstrap),
            "::",
            stringify!(event_loop_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_protocol_negotiated) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_bootstrap),
            "::",
            stringify!(on_protocol_negotiated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_bootstrap),
            "::",
            stringify!(ref_count)
        )
    );
}
#[doc = " Socket-based channel creation options.\n\n bootstrap - configs name resolution and which event loop group the connection will be seated into\n host_name - host to connect to; if a dns address, will be resolved prior to connecting\n port - port to connect to\n socket_options - socket properties, including type (tcp vs. udp vs. unix domain) and connect timeout.  TLS\n   connections are currently restricted to tcp (AWS_SOCKET_STREAM) only.\n tls_options - (optional) tls context to apply after connection establishment.  If NULL, the connection will\n   not be protected by TLS.\n creation_callback - (optional) callback invoked when the channel is first created.  This is always right after\n   the connection was successfully established.  *Does NOT* get called if the initial connect failed.\n setup_callback - callback invoked once the channel is ready for use and TLS has been negotiated or if an error\n   is encountered\n shutdown_callback - callback invoked once the channel has shutdown.\n enable_read_back_pressure - controls whether or not back pressure will be applied in the channel\n user_data - arbitrary data to pass back to the various callbacks\n requested_event_loop - if set, the connection will be placed on the requested event loop rather than one\n  chosen internally from the bootstrap's associated event loop group.  It is an error to pass in an event loop\n  that is not associated with the bootstrap's event loop group.\n\n Immediately after the `shutdown_callback` returns, the channel is cleaned up automatically. All callbacks are invoked\n in the thread of the event-loop that the new channel is assigned to.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_socket_channel_bootstrap_options {
    pub bootstrap: *mut aws_client_bootstrap,
    pub host_name: *const ::std::os::raw::c_char,
    pub port: u32,
    pub socket_options: *const aws_socket_options,
    pub tls_options: *const aws_tls_connection_options,
    pub creation_callback: aws_client_bootstrap_on_channel_event_fn,
    pub setup_callback: aws_client_bootstrap_on_channel_event_fn,
    pub shutdown_callback: aws_client_bootstrap_on_channel_event_fn,
    pub enable_read_back_pressure: bool,
    pub user_data: *mut ::std::os::raw::c_void,
    pub requested_event_loop: *mut aws_event_loop,
    pub host_resolution_override_config: *const aws_host_resolution_config,
}
#[test]
fn bindgen_test_layout_aws_socket_channel_bootstrap_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_socket_channel_bootstrap_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_socket_channel_bootstrap_options>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(aws_socket_channel_bootstrap_options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aws_socket_channel_bootstrap_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_socket_channel_bootstrap_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bootstrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(bootstrap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(socket_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tls_options) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(tls_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creation_callback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(creation_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setup_callback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(setup_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_callback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(shutdown_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_read_back_pressure) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(enable_read_back_pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requested_event_loop) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(requested_event_loop)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).host_resolution_override_config) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_channel_bootstrap_options),
            "::",
            stringify!(host_resolution_override_config)
        )
    );
}
#[doc = " Arguments to setup a server socket listener which will also negotiate and configure TLS.\n This creates a socket listener bound to `host` and 'port' using socket options `options`, and TLS options\n `tls_options`. `incoming_callback` will be invoked once an incoming channel is ready for use and TLS is\n finished negotiating, or if an error is encountered. `shutdown_callback` will be invoked once the channel has\n shutdown. `destroy_callback` will be invoked after the server socket listener is destroyed, and all associated\n connections and channels have finished shutting down. Immediately after the `shutdown_callback` returns, the channel\n is cleaned up automatically. All callbacks are invoked in the thread of the event-loop that listener is assigned to.\n\n Upon shutdown of your application, you'll want to call `aws_server_bootstrap_destroy_socket_listener` with the return\n value from this function.\n\n The socket type in `options` must be AWS_SOCKET_STREAM if tls_options is set.\n DTLS is not currently supported for tls."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_server_socket_channel_bootstrap_options {
    pub bootstrap: *mut aws_server_bootstrap,
    pub host_name: *const ::std::os::raw::c_char,
    pub port: u32,
    pub socket_options: *const aws_socket_options,
    pub tls_options: *const aws_tls_connection_options,
    pub incoming_callback: aws_server_bootstrap_on_accept_channel_setup_fn,
    pub shutdown_callback: aws_server_bootstrap_on_accept_channel_shutdown_fn,
    pub destroy_callback: aws_server_bootstrap_on_server_listener_destroy_fn,
    pub enable_read_back_pressure: bool,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_server_socket_channel_bootstrap_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_server_socket_channel_bootstrap_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_server_socket_channel_bootstrap_options>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(aws_server_socket_channel_bootstrap_options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aws_server_socket_channel_bootstrap_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_server_socket_channel_bootstrap_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bootstrap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(bootstrap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).socket_options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(socket_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tls_options) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(tls_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming_callback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(incoming_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_callback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(shutdown_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy_callback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(destroy_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_read_back_pressure) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(enable_read_back_pressure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_server_socket_channel_bootstrap_options),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    #[doc = " Create the client bootstrap."]
    pub fn aws_client_bootstrap_new(
        allocator: *mut aws_allocator,
        options: *const aws_client_bootstrap_options,
    ) -> *mut aws_client_bootstrap;
}
extern "C" {
    #[doc = " Increments a client bootstrap's ref count, allowing the caller to take a reference to it.\n\n Returns the same client bootstrap passed in."]
    pub fn aws_client_bootstrap_acquire(
        bootstrap: *mut aws_client_bootstrap,
    ) -> *mut aws_client_bootstrap;
}
extern "C" {
    #[doc = " Decrements a client bootstrap's ref count.  When the ref count drops to zero, the bootstrap will be destroyed."]
    pub fn aws_client_bootstrap_release(bootstrap: *mut aws_client_bootstrap);
}
extern "C" {
    #[doc = " When using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added\n to the channel."]
    pub fn aws_client_bootstrap_set_alpn_callback(
        bootstrap: *mut aws_client_bootstrap,
        on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets up a client socket channel."]
    pub fn aws_client_bootstrap_new_socket_channel(
        options: *mut aws_socket_channel_bootstrap_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes the server bootstrap with `allocator` and `el_group`. This object manages listeners, server connections,\n and channels."]
    pub fn aws_server_bootstrap_new(
        allocator: *mut aws_allocator,
        el_group: *mut aws_event_loop_group,
    ) -> *mut aws_server_bootstrap;
}
extern "C" {
    #[doc = " Increments a server bootstrap's ref count, allowing the caller to take a reference to it.\n\n Returns the same server bootstrap passed in."]
    pub fn aws_server_bootstrap_acquire(
        bootstrap: *mut aws_server_bootstrap,
    ) -> *mut aws_server_bootstrap;
}
extern "C" {
    #[doc = " Decrements a server bootstrap's ref count.  When the ref count drops to zero, the bootstrap will be destroyed."]
    pub fn aws_server_bootstrap_release(bootstrap: *mut aws_server_bootstrap);
}
extern "C" {
    #[doc = " When using TLS, if ALPN is used, this callback will be invoked from the channel. The returned handler will be added\n to the channel."]
    pub fn aws_server_bootstrap_set_alpn_callback(
        bootstrap: *mut aws_server_bootstrap,
        on_protocol_negotiated: aws_channel_on_protocol_negotiated_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets up a server socket listener. If you are planning on using TLS, use\n `aws_server_bootstrap_new_tls_socket_listener` instead. This creates a socket listener bound to `local_endpoint`\n using socket options `options`. `incoming_callback` will be invoked once an incoming channel is ready for use or if\n an error is encountered. `shutdown_callback` will be invoked once the channel has shutdown. `destroy_callback` will\n be invoked after the server socket listener is destroyed, and all associated connections and channels have finished\n shutting down. Immediately after the `shutdown_callback` returns, the channel is cleaned up automatically. All\n callbacks are invoked the thread of the event-loop that the listening socket is assigned to\n\n Upon shutdown of your application, you'll want to call `aws_server_bootstrap_destroy_socket_listener` with the return\n value from this function.\n\n bootstrap_options is copied."]
    pub fn aws_server_bootstrap_new_socket_listener(
        bootstrap_options: *const aws_server_socket_channel_bootstrap_options,
    ) -> *mut aws_socket;
}
extern "C" {
    #[doc = " Shuts down 'listener' and cleans up any resources associated with it. Any incoming channels on `listener` will still\n be active. `destroy_callback` will be invoked after the server socket listener is destroyed, and all associated\n connections and channels have finished shutting down."]
    pub fn aws_server_bootstrap_destroy_socket_listener(
        bootstrap: *mut aws_server_bootstrap,
        listener: *mut aws_socket,
    );
}
pub const AWS_COMMON_HASH_TABLE_ITER_CONTINUE: _bindgen_ty_4 =
    _bindgen_ty_4::AWS_COMMON_HASH_TABLE_ITER_CONTINUE;
pub const AWS_COMMON_HASH_TABLE_ITER_DELETE: _bindgen_ty_4 =
    _bindgen_ty_4::AWS_COMMON_HASH_TABLE_ITER_DELETE;
pub const AWS_COMMON_HASH_TABLE_ITER_ERROR: _bindgen_ty_4 =
    _bindgen_ty_4::AWS_COMMON_HASH_TABLE_ITER_ERROR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    AWS_COMMON_HASH_TABLE_ITER_CONTINUE = 1,
    AWS_COMMON_HASH_TABLE_ITER_DELETE = 2,
    AWS_COMMON_HASH_TABLE_ITER_ERROR = 4,
}
#[doc = " Hash table data structure. This module provides an automatically resizing\n hash table implementation for general purpose use. The hash table stores a\n mapping between void * keys and values; it is expected that in most cases,\n these will point to a structure elsewhere in the heap, instead of inlining a\n key or value into the hash table element itself.\n\n Currently, this hash table implements a variant of robin hood hashing, but\n we do not guarantee that this won't change in the future.\n\n Associated with each hash function are four callbacks:\n\n   hash_fn - A hash function from the keys to a uint64_t. It is critical that\n      the hash function for a key does not change while the key is in the hash\n      table; violating this results in undefined behavior. Collisions are\n      tolerated, though naturally with reduced performance.\n\n   equals_fn - An equality comparison function. This function must be\n      reflexive and consistent with hash_fn.\n\n   destroy_key_fn, destroy_value_fn - Optional callbacks invoked when the\n      table is cleared or cleaned up and at the caller's option when an element\n      is removed from the table. Either or both may be set to NULL, which\n      has the same effect as a no-op destroy function.\n\n This datastructure can be safely moved between threads, subject to the\n requirements of the underlying allocator. It is also safe to invoke\n non-mutating operations on the hash table from multiple threads. A suitable\n memory barrier must be used when transitioning from single-threaded mutating\n usage to multithreaded usage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_table_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_table {
    pub p_impl: *mut hash_table_state,
}
#[test]
fn bindgen_test_layout_aws_hash_table() {
    const UNINIT: ::std::mem::MaybeUninit<aws_hash_table> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_hash_table>(),
        8usize,
        concat!("Size of: ", stringify!(aws_hash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_hash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_hash_table))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_impl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_table),
            "::",
            stringify!(p_impl)
        )
    );
}
#[doc = " Represents an element in the hash table. Various operations on the hash\n table may provide pointers to elements stored within the hash table;\n generally, calling code may alter value, but must not alter key (or any\n information used to compute key's hash code).\n\n Pointers to elements within the hash are invalidated whenever an operation\n which may change the number of elements in the hash is invoked (i.e. put,\n delete, clear, and clean_up), regardless of whether the number of elements\n actually changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_element {
    pub key: *const ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_hash_element() {
    const UNINIT: ::std::mem::MaybeUninit<aws_hash_element> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_hash_element>(),
        16usize,
        concat!("Size of: ", stringify!(aws_hash_element))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_hash_element>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_hash_element))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_element),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_element),
            "::",
            stringify!(value)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_hash_iter_status {
    AWS_HASH_ITER_STATUS_DONE = 0,
    AWS_HASH_ITER_STATUS_DELETE_CALLED = 1,
    AWS_HASH_ITER_STATUS_READY_FOR_USE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_hash_iter {
    pub map: *const aws_hash_table,
    pub element: aws_hash_element,
    pub slot: usize,
    pub limit: usize,
    pub status: aws_hash_iter_status,
    pub unused_0: ::std::os::raw::c_int,
    pub unused_1: *mut ::std::os::raw::c_void,
    pub unused_2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_hash_iter() {
    const UNINIT: ::std::mem::MaybeUninit<aws_hash_iter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_hash_iter>(),
        64usize,
        concat!("Size of: ", stringify!(aws_hash_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_hash_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_hash_iter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused_0) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(unused_0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused_1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(unused_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused_2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_hash_iter),
            "::",
            stringify!(unused_2)
        )
    );
}
#[doc = " Prototype for a key hashing function pointer."]
pub type aws_hash_fn =
    ::std::option::Option<unsafe extern "C" fn(key: *const ::std::os::raw::c_void) -> u64>;
#[doc = " Prototype for a hash table equality check function pointer.\n\n This type is usually used for a function that compares two hash table\n keys, but note that the same type is used for a function that compares\n two hash table values in aws_hash_table_eq.\n\n Equality functions used in a hash table must be be reflexive (a == a),\n symmetric (a == b => b == a), transitive (a == b, b == c => a == c)\n and consistent (result does not change with time)."]
pub type aws_hash_callback_eq_fn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Prototype for a hash table key or value destructor function pointer.\n\n This function is used to destroy elements in the hash table when the\n table is cleared or cleaned up.\n\n Note that functions which remove individual elements from the hash\n table provide options of whether or not to invoke the destructors\n on the key and value of a removed element."]
pub type aws_hash_callback_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(key_or_value: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Initializes a hash map with initial capacity for 'size' elements\n without resizing. Uses hash_fn to compute the hash of each element.\n equals_fn to compute equality of two keys.  Whenever an element is\n removed without being returned, destroy_key_fn is run on the pointer\n to the key and destroy_value_fn is run on the pointer to the value.\n Either or both may be NULL if a callback is not desired in this case."]
    pub fn aws_hash_table_init(
        map: *mut aws_hash_table,
        alloc: *mut aws_allocator,
        size: usize,
        hash_fn: aws_hash_fn,
        equals_fn: aws_hash_callback_eq_fn,
        destroy_key_fn: aws_hash_callback_destroy_fn,
        destroy_value_fn: aws_hash_callback_destroy_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deletes every element from map and frees all associated memory.\n destroy_fn will be called for each element.  aws_hash_table_init\n must be called before reusing the hash table.\n\n This method is idempotent."]
    pub fn aws_hash_table_clean_up(map: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Safely swaps two hash tables. Note that we swap the entirety of the hash\n table, including which allocator is associated.\n\n Neither hash table is required to be initialized; if one or both is\n uninitialized, then the uninitialized state is also swapped."]
    pub fn aws_hash_table_swap(a: *mut aws_hash_table, b: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Moves the hash table in 'from' to 'to'. After this move, 'from' will\n be identical to the state of the original 'to' hash table, and 'to'\n will be in the same state as if it had been passed to aws_hash_table_clean_up\n (that is, it will have no memory allocated, and it will be safe to\n either discard it or call aws_hash_table_clean_up again).\n\n Note that 'to' will not be cleaned up. You should make sure that 'to'\n is either uninitialized or cleaned up before moving a hashtable into\n it."]
    pub fn aws_hash_table_move(to: *mut aws_hash_table, from: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Returns the current number of entries in the table."]
    pub fn aws_hash_table_get_entry_count(map: *const aws_hash_table) -> usize;
}
extern "C" {
    #[doc = " Returns an iterator to be used for iterating through a hash table.\n Iterator will already point to the first element of the table it finds,\n which can be accessed as iter.element.\n\n This function cannot fail, but if there are no elements in the table,\n the returned iterator will return true for aws_hash_iter_done(&iter)."]
    pub fn aws_hash_iter_begin(map: *const aws_hash_table) -> aws_hash_iter;
}
extern "C" {
    #[doc = " Returns true if iterator is done iterating through table, false otherwise.\n If this is true, the iterator will not include an element of the table."]
    pub fn aws_hash_iter_done(iter: *const aws_hash_iter) -> bool;
}
extern "C" {
    #[doc = " Updates iterator so that it points to next element of hash table.\n\n This and the two previous functions are designed to be used together with\n the following idiom:\n\n for (struct aws_hash_iter iter = aws_hash_iter_begin(&map);\n      !aws_hash_iter_done(&iter); aws_hash_iter_next(&iter)) {\n     const key_type key = *(const key_type *)iter.element.key;\n     value_type value = *(value_type *)iter.element.value;\n     // etc.\n }\n\n Note that calling this on an iter which is \"done\" is idempotent:\n i.e. it will return another iter which is \"done\"."]
    pub fn aws_hash_iter_next(iter: *mut aws_hash_iter);
}
extern "C" {
    #[doc = " Deletes the element currently pointed-to by the hash iterator.\n After calling this method, the element member of the iterator\n should not be accessed until the next call to aws_hash_iter_next.\n\n @param destroy_contents If true, the destructors for the key and value\n  will be called."]
    pub fn aws_hash_iter_delete(iter: *mut aws_hash_iter, destroy_contents: bool);
}
extern "C" {
    #[doc = " Attempts to locate an element at key.  If the element is found, a\n pointer to the value is placed in *p_elem; if it is not found,\n *pElem is set to NULL. Either way, AWS_OP_SUCCESS is returned.\n\n This method does not change the state of the hash table. Therefore, it\n is safe to call _find from multiple threads on the same hash table,\n provided no mutating operations happen in parallel.\n\n Calling code may update the value in the hash table by modifying **pElem\n after a successful find. However, this pointer is not guaranteed to\n remain usable after a subsequent call to _put, _delete, _clear, or\n _clean_up."]
    pub fn aws_hash_table_find(
        map: *const aws_hash_table,
        key: *const ::std::os::raw::c_void,
        p_elem: *mut *mut aws_hash_element,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to locate an element at key. If no such element was found,\n creates a new element, with value initialized to NULL. In either case, a\n pointer to the element is placed in *p_elem.\n\n If was_created is non-NULL, *was_created is set to 0 if an existing\n element was found, or 1 is a new element was created.\n\n Returns AWS_OP_SUCCESS if an item was found or created.\n Raises AWS_ERROR_OOM if hash table expansion was required and memory\n allocation failed."]
    pub fn aws_hash_table_create(
        map: *mut aws_hash_table,
        key: *const ::std::os::raw::c_void,
        p_elem: *mut *mut aws_hash_element,
        was_created: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts a new element at key, with the given value. If another element\n exists at that key, the old element will be overwritten; both old key and\n value objects will be destroyed.\n\n If was_created is non-NULL, *was_created is set to 0 if an existing\n element was found, or 1 is a new element was created.\n\n Returns AWS_OP_SUCCESS if an item was found or created.\n Raises AWS_ERROR_OOM if hash table expansion was required and memory\n allocation failed."]
    pub fn aws_hash_table_put(
        map: *mut aws_hash_table,
        key: *const ::std::os::raw::c_void,
        value: *mut ::std::os::raw::c_void,
        was_created: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes element at key. Always returns AWS_OP_SUCCESS.\n\n If pValue is non-NULL, the existing value (if any) is moved into\n (*value) before removing from the table, and destroy_fn is _not_\n invoked. If pValue is NULL, then (if the element existed) destroy_fn\n will be invoked on the element being removed.\n\n If was_present is non-NULL, it is set to 0 if the element was\n not present, or 1 if it was present (and is now removed)."]
    pub fn aws_hash_table_remove(
        map: *mut aws_hash_table,
        key: *const ::std::os::raw::c_void,
        p_value: *mut aws_hash_element,
        was_present: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes element already known (typically by find()).\n\n p_value should point to a valid element returned by create() or find().\n\n NOTE: DO NOT call this method from inside of a aws_hash_table_foreach callback, return\n AWS_COMMON_HASH_TABLE_ITER_DELETE instead."]
    pub fn aws_hash_table_remove_element(
        map: *mut aws_hash_table,
        p_value: *mut aws_hash_element,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterates through every element in the map and invokes the callback on\n that item. Iteration is performed in an arbitrary, implementation-defined\n order, and is not guaranteed to be consistent across invocations.\n\n The callback may change the value associated with the key by overwriting\n the value pointed-to by value. In this case, the on_element_removed\n callback will not be invoked, unless the callback invokes\n AWS_COMMON_HASH_TABLE_ITER_DELETE (in which case the on_element_removed\n is given the updated value).\n\n The callback must return a bitmask of zero or more of the following values\n ORed together:\n\n # AWS_COMMON_HASH_TABLE_ITER_CONTINUE - Continues iteration to the next\n     element (if not set, iteration stops)\n # AWS_COMMON_HASH_TABLE_ITER_DELETE   - Deletes the current value and\n     continues iteration.  destroy_fn will NOT be invoked.\n # AWS_COMMON_HASH_TABLE_ITER_ERROR   - Stop iteration with error.\n     No action will be taken for the current value and the value before this.\n     No rolling back. The deleted value before will NOT be back.\n     aws_hash_table_foreach returns AWS_OP_ERR after stropping the iteration.\n\n Invoking any method which may change the contents of the hashtable\n during iteration results in undefined behavior. However, you may safely\n invoke non-mutating operations during an iteration.\n\n This operation is mutating only if AWS_COMMON_HASH_TABLE_ITER_DELETE\n is returned at some point during iteration. Otherwise, it is non-mutating\n and is safe to invoke in parallel with other non-mutating operations."]
    pub fn aws_hash_table_foreach(
        map: *mut aws_hash_table,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                context: *mut ::std::os::raw::c_void,
                p_element: *mut aws_hash_element,
            ) -> ::std::os::raw::c_int,
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares two hash tables for equality. Both hash tables must have equivalent\n key comparators; values will be compared using the comparator passed into this\n function. The key hash function does not need to be equivalent between the\n two hash tables."]
    pub fn aws_hash_table_eq(
        a: *const aws_hash_table,
        b: *const aws_hash_table,
        value_eq: aws_hash_callback_eq_fn,
    ) -> bool;
}
extern "C" {
    #[doc = " Removes every element from the hash map. destroy_fn will be called for\n each element."]
    pub fn aws_hash_table_clear(map: *mut aws_hash_table);
}
extern "C" {
    #[doc = " Convenience hash function for NULL-terminated C-strings"]
    pub fn aws_hash_c_string(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Convenience hash function for struct aws_strings.\n Hash is same as used on the string bytes by aws_hash_c_string."]
    pub fn aws_hash_string(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Convenience hash function for struct aws_byte_cursor.\n Hash is same as used on the string bytes by aws_hash_c_string."]
    pub fn aws_hash_byte_cursor_ptr(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Convenience hash function which hashes the pointer value directly,\n without dereferencing.  This can be used in cases where pointer identity\n is desired, or where a uintptr_t is encoded into a const void *."]
    pub fn aws_hash_ptr(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    pub fn aws_hash_combine(item1: u64, item2: u64) -> u64;
}
extern "C" {
    #[doc = " Convenience eq callback for NULL-terminated C-strings"]
    pub fn aws_hash_callback_c_str_eq(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience eq callback for AWS strings"]
    pub fn aws_hash_callback_string_eq(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience destroy callback for AWS strings"]
    pub fn aws_hash_callback_string_destroy(a: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Equality function which compares pointer equality."]
    pub fn aws_ptr_eq(a: *const ::std::os::raw::c_void, b: *const ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Best-effort check of hash_table_state data-structure invariants"]
    pub fn aws_hash_table_is_valid(map: *const aws_hash_table) -> bool;
}
extern "C" {
    #[doc = " Given a pointer to a hash_iter, checks that it is well-formed, with all data-structure invariants."]
    pub fn aws_hash_iter_is_valid(iter: *const aws_hash_iter) -> bool;
}
extern "C" {
    #[doc = " Helper function to hash keys that are uint64_t values.\n\n The function is not a strong hash function in any sense; it merely reflects\n the uint64 value back.  Do not use this function as a hash if you need\n the properties of a strong hash function."]
    pub fn aws_hash_uint64_t_by_identity(item: *const ::std::os::raw::c_void) -> u64;
}
extern "C" {
    #[doc = " Helper function to compare hash keys that are uint64_t values."]
    pub fn aws_hash_compare_uint64_t_eq(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_io_event_type {
    AWS_IO_EVENT_TYPE_READABLE = 1,
    AWS_IO_EVENT_TYPE_WRITABLE = 2,
    AWS_IO_EVENT_TYPE_REMOTE_HANG_UP = 4,
    AWS_IO_EVENT_TYPE_CLOSED = 8,
    AWS_IO_EVENT_TYPE_ERROR = 16,
}
pub type aws_event_loop_on_event_fn = ::std::option::Option<
    unsafe extern "C" fn(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
        events: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_vtable {
    pub destroy: ::std::option::Option<unsafe extern "C" fn(event_loop: *mut aws_event_loop)>,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> ::std::os::raw::c_int,
    >,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> ::std::os::raw::c_int,
    >,
    pub wait_for_stop_completion: ::std::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> ::std::os::raw::c_int,
    >,
    pub schedule_task_now: ::std::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop, task: *mut aws_task),
    >,
    pub schedule_task_future: ::std::option::Option<
        unsafe extern "C" fn(
            event_loop: *mut aws_event_loop,
            task: *mut aws_task,
            run_at_nanos: u64,
        ),
    >,
    pub cancel_task: ::std::option::Option<
        unsafe extern "C" fn(event_loop: *mut aws_event_loop, task: *mut aws_task),
    >,
    pub subscribe_to_io_events: ::std::option::Option<
        unsafe extern "C" fn(
            event_loop: *mut aws_event_loop,
            handle: *mut aws_io_handle,
            events: ::std::os::raw::c_int,
            on_event: aws_event_loop_on_event_fn,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub unsubscribe_from_io_events: ::std::option::Option<
        unsafe extern "C" fn(
            event_loop: *mut aws_event_loop,
            handle: *mut aws_io_handle,
        ) -> ::std::os::raw::c_int,
    >,
    pub free_io_event_resources:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub is_on_callers_thread:
        ::std::option::Option<unsafe extern "C" fn(event_loop: *mut aws_event_loop) -> bool>,
}
#[test]
fn bindgen_test_layout_aws_event_loop_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_event_loop_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_event_loop_vtable>(),
        88usize,
        concat!("Size of: ", stringify!(aws_event_loop_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_event_loop_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_event_loop_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait_for_stop_completion) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(wait_for_stop_completion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schedule_task_now) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(schedule_task_now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schedule_task_future) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(schedule_task_future)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_task) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(cancel_task)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscribe_to_io_events) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(subscribe_to_io_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsubscribe_from_io_events) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(unsubscribe_from_io_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_io_event_resources) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(free_io_event_resources)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_on_callers_thread) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_vtable),
            "::",
            stringify!(is_on_callers_thread)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop {
    pub vtable: *mut aws_event_loop_vtable,
    pub alloc: *mut aws_allocator,
    pub clock: aws_io_clock_fn,
    pub local_data: aws_hash_table,
    pub current_load_factor: aws_atomic_var,
    pub latest_tick_start: u64,
    pub current_tick_latency_sum: usize,
    pub next_flush_time: aws_atomic_var,
    pub impl_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_event_loop() {
    const UNINIT: ::std::mem::MaybeUninit<aws_event_loop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_event_loop>(),
        72usize,
        concat!("Size of: ", stringify!(aws_event_loop))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_event_loop>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_event_loop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(local_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_load_factor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(current_load_factor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latest_tick_start) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(latest_tick_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_tick_latency_sum) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(current_tick_latency_sum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_flush_time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(next_flush_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop),
            "::",
            stringify!(impl_data)
        )
    );
}
pub type aws_event_loop_on_local_object_removed_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut aws_event_loop_local_object)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_local_object {
    pub key: *const ::std::os::raw::c_void,
    pub object: *mut ::std::os::raw::c_void,
    pub on_object_removed: aws_event_loop_on_local_object_removed_fn,
}
#[test]
fn bindgen_test_layout_aws_event_loop_local_object() {
    const UNINIT: ::std::mem::MaybeUninit<aws_event_loop_local_object> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_event_loop_local_object>(),
        24usize,
        concat!("Size of: ", stringify!(aws_event_loop_local_object))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_event_loop_local_object>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_event_loop_local_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_local_object),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_local_object),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_object_removed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_local_object),
            "::",
            stringify!(on_object_removed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_options {
    pub clock: aws_io_clock_fn,
    pub thread_options: *mut aws_thread_options,
}
#[test]
fn bindgen_test_layout_aws_event_loop_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_event_loop_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_event_loop_options>(),
        16usize,
        concat!("Size of: ", stringify!(aws_event_loop_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_event_loop_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_event_loop_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_options),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_options),
            "::",
            stringify!(thread_options)
        )
    );
}
pub type aws_new_event_loop_fn = ::std::option::Option<
    unsafe extern "C" fn(
        alloc: *mut aws_allocator,
        options: *const aws_event_loop_options,
        new_loop_user_data: *mut ::std::os::raw::c_void,
    ) -> *mut aws_event_loop,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_event_loop_group {
    pub allocator: *mut aws_allocator,
    pub event_loops: aws_array_list,
    pub ref_count: aws_ref_count,
    pub shutdown_options: aws_shutdown_callback_options,
}
#[test]
fn bindgen_test_layout_aws_event_loop_group() {
    const UNINIT: ::std::mem::MaybeUninit<aws_event_loop_group> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_event_loop_group>(),
        88usize,
        concat!("Size of: ", stringify!(aws_event_loop_group))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_event_loop_group>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_event_loop_group))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_group),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_loops) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_group),
            "::",
            stringify!(event_loops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_group),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_options) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_event_loop_group),
            "::",
            stringify!(shutdown_options)
        )
    );
}
extern "C" {
    #[doc = " Creates an instance of the default event loop implementation for the current architecture and operating system."]
    pub fn aws_event_loop_new_default(
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
    ) -> *mut aws_event_loop;
}
extern "C" {
    #[doc = " Creates an instance of the default event loop implementation for the current architecture and operating system using\n extendable options."]
    pub fn aws_event_loop_new_default_with_options(
        alloc: *mut aws_allocator,
        options: *const aws_event_loop_options,
    ) -> *mut aws_event_loop;
}
extern "C" {
    #[doc = " Invokes the destroy() fn for the event loop implementation.\n If the event loop is still in a running state, this function will block waiting on the event loop to shutdown.\n If you do not want this function to block, call aws_event_loop_stop() manually first.\n If the event loop is shared by multiple threads then destroy must be called by exactly one thread. All other threads\n must ensure their API calls to the event loop happen-before the call to destroy."]
    pub fn aws_event_loop_destroy(event_loop: *mut aws_event_loop);
}
extern "C" {
    #[doc = " Initializes common event-loop data structures.\n This is only called from the *new() function of event loop implementations."]
    pub fn aws_event_loop_init_base(
        event_loop: *mut aws_event_loop,
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Common cleanup code for all implementations.\n This is only called from the *destroy() function of event loop implementations."]
    pub fn aws_event_loop_clean_up_base(event_loop: *mut aws_event_loop);
}
extern "C" {
    #[doc = " Fetches an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to\n by key. This function is not thread safe and should be called inside the event-loop's thread."]
    pub fn aws_event_loop_fetch_local_object(
        event_loop: *mut aws_event_loop,
        key: *mut ::std::os::raw::c_void,
        obj: *mut aws_event_loop_local_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Puts an item object the event-loop's data store. Key will be taken as the memory address of the memory pointed to by\n key. The lifetime of item must live until remove or a put item overrides it. This function is not thread safe and\n should be called inside the event-loop's thread."]
    pub fn aws_event_loop_put_local_object(
        event_loop: *mut aws_event_loop,
        obj: *mut aws_event_loop_local_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes an object from the event-loop's data store. Key will be taken as the memory address of the memory pointed to\n by key. If removed_item is not null, the removed item will be moved to it if it exists. Otherwise, the default\n deallocation strategy will be used. This function is not thread safe and should be called inside the event-loop's\n thread."]
    pub fn aws_event_loop_remove_local_object(
        event_loop: *mut aws_event_loop,
        key: *mut ::std::os::raw::c_void,
        removed_obj: *mut aws_event_loop_local_object,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Triggers the running of the event loop. This function must not block. The event loop is not active until this\n function is invoked. This function can be called again on an event loop after calling aws_event_loop_stop() and\n aws_event_loop_wait_for_stop_completion()."]
    pub fn aws_event_loop_run(event_loop: *mut aws_event_loop) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Triggers the event loop to stop, but does not wait for the loop to stop completely.\n This function may be called from outside or inside the event loop thread. It is safe to call multiple times.\n This function is called from destroy().\n\n If you do not call destroy(), an event loop can be run again by calling stop(), wait_for_stop_completion(), run()."]
    pub fn aws_event_loop_stop(event_loop: *mut aws_event_loop) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For event-loop implementations to use for providing metrics info to the base event-loop. This enables the\n event-loop load balancer to take into account load when vending another event-loop to a caller.\n\n Call this function at the beginning of your event-loop tick: after wake-up, but before processing any IO or tasks."]
    pub fn aws_event_loop_register_tick_start(event_loop: *mut aws_event_loop);
}
extern "C" {
    #[doc = " For event-loop implementations to use for providing metrics info to the base event-loop. This enables the\n event-loop load balancer to take into account load when vending another event-loop to a caller.\n\n Call this function at the end of your event-loop tick: after processing IO and tasks."]
    pub fn aws_event_loop_register_tick_end(event_loop: *mut aws_event_loop);
}
extern "C" {
    #[doc = " Returns the current load factor (however that may be calculated). If the event-loop is not invoking\n aws_event_loop_register_tick_start() and aws_event_loop_register_tick_end(), this value will always be 0."]
    pub fn aws_event_loop_get_load_factor(event_loop: *mut aws_event_loop) -> usize;
}
extern "C" {
    #[doc = " Blocks until the event loop stops completely.\n If you want to call aws_event_loop_run() again, you must call this after aws_event_loop_stop().\n It is not safe to call this function from inside the event loop thread."]
    pub fn aws_event_loop_wait_for_stop_completion(
        event_loop: *mut aws_event_loop,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The event loop will schedule the task and run it on the event loop thread as soon as possible.\n Note that cancelled tasks may execute outside the event loop thread.\n This function may be called from outside or inside the event loop thread.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_event_loop_schedule_task_now(event_loop: *mut aws_event_loop, task: *mut aws_task);
}
extern "C" {
    #[doc = " The event loop will schedule the task and run it at the specified time.\n Use aws_event_loop_current_clock_time() to query the current time in nanoseconds.\n Note that cancelled tasks may execute outside the event loop thread.\n This function may be called from outside or inside the event loop thread.\n\n The task should not be cleaned up or modified until its function is executed."]
    pub fn aws_event_loop_schedule_task_future(
        event_loop: *mut aws_event_loop,
        task: *mut aws_task,
        run_at_nanos: u64,
    );
}
extern "C" {
    #[doc = " Cancels task.\n This function must be called from the event loop's thread, and is only guaranteed\n to work properly on tasks scheduled from within the event loop's thread.\n The task will be executed with the AWS_TASK_STATUS_CANCELED status inside this call."]
    pub fn aws_event_loop_cancel_task(event_loop: *mut aws_event_loop, task: *mut aws_task);
}
extern "C" {
    #[doc = " Subscribes on_event to events on the event-loop for handle. events is a bitwise concatenation of the events that were\n received. The definition for these values can be found in aws_io_event_type. Currently, only\n AWS_IO_EVENT_TYPE_READABLE and AWS_IO_EVENT_TYPE_WRITABLE are honored. You always are registered for error conditions\n and closure. This function may be called from outside or inside the event loop thread. However, the unsubscribe\n function must be called inside the event-loop's thread."]
    pub fn aws_event_loop_subscribe_to_io_events(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
        events: ::std::os::raw::c_int,
        on_event: aws_event_loop_on_event_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unsubscribes handle from event-loop notifications.\n This function is not thread safe and should be called inside the event-loop's thread.\n\n NOTE: if you are using io completion ports, this is a risky call. We use it in places, but only when we're certain\n there's no pending events. If you want to use it, it's your job to make sure you don't have pending events before\n calling it."]
    pub fn aws_event_loop_unsubscribe_from_io_events(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up resources (user_data) associated with the I/O eventing subsystem for a given handle. This should only\n ever be necessary in the case where you are cleaning up an event loop during shutdown and its thread has already\n been joined."]
    pub fn aws_event_loop_free_io_event_resources(
        event_loop: *mut aws_event_loop,
        handle: *mut aws_io_handle,
    );
}
extern "C" {
    #[doc = " Returns true if the event loop's thread is the same thread that called this function, otherwise false."]
    pub fn aws_event_loop_thread_is_callers_thread(event_loop: *mut aws_event_loop) -> bool;
}
extern "C" {
    #[doc = " Gets the current timestamp for the event loop's clock, in nanoseconds. This function is thread-safe."]
    pub fn aws_event_loop_current_clock_time(
        event_loop: *mut aws_event_loop,
        time_nanos: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates an event loop group, with clock, number of loops to manage, and the function to call for creating a new\n event loop."]
    pub fn aws_event_loop_group_new(
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
        el_count: u16,
        new_loop_fn: aws_new_event_loop_fn,
        new_loop_user_data: *mut ::std::os::raw::c_void,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
}
extern "C" {
    #[doc = " Creates an event loop group, with clock, number of loops to manage, the function to call for creating a new\n event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note:\n If el_count exceeds the number of hw threads in the cpu_group it will be ignored on the assumption that if you\n care about NUMA, you don't want hyper-threads doing your IO and you especially don't want IO on a different node."]
    pub fn aws_event_loop_group_new_pinned_to_cpu_group(
        alloc: *mut aws_allocator,
        clock: aws_io_clock_fn,
        el_count: u16,
        cpu_group: u16,
        new_loop_fn: aws_new_event_loop_fn,
        new_loop_user_data: *mut ::std::os::raw::c_void,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
}
extern "C" {
    #[doc = " Initializes an event loop group with platform defaults. If max_threads == 0, then the\n loop count will be the number of available processors on the machine / 2 (to exclude hyper-threads).\n Otherwise, max_threads will be the number of event loops in the group."]
    pub fn aws_event_loop_group_new_default(
        alloc: *mut aws_allocator,
        max_threads: u16,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
}
extern "C" {
    #[doc = " Creates an event loop group, with clock, number of loops to manage, the function to call for creating a new\n event loop, and also pins all loops to hw threads on the same cpu_group (e.g. NUMA nodes). Note:\n If el_count exceeds the number of hw threads in the cpu_group it will be clamped to the number of hw threads\n on the assumption that if you care about NUMA, you don't want hyper-threads doing your IO and you especially\n don't want IO on a different node.\n\n If max_threads == 0, then the\n loop count will be the number of available processors in the cpu_group / 2 (to exclude hyper-threads)"]
    pub fn aws_event_loop_group_new_default_pinned_to_cpu_group(
        alloc: *mut aws_allocator,
        max_threads: u16,
        cpu_group: u16,
        shutdown_options: *const aws_shutdown_callback_options,
    ) -> *mut aws_event_loop_group;
}
extern "C" {
    #[doc = " Increments the reference count on the event loop group, allowing the caller to take a reference to it.\n\n Returns the same event loop group passed in."]
    pub fn aws_event_loop_group_acquire(
        el_group: *mut aws_event_loop_group,
    ) -> *mut aws_event_loop_group;
}
extern "C" {
    #[doc = " Decrements an event loop group's ref count.  When the ref count drops to zero, the event loop group will be\n destroyed."]
    pub fn aws_event_loop_group_release(el_group: *mut aws_event_loop_group);
}
extern "C" {
    pub fn aws_event_loop_group_get_loop_at(
        el_group: *mut aws_event_loop_group,
        index: usize,
    ) -> *mut aws_event_loop;
}
extern "C" {
    pub fn aws_event_loop_group_get_loop_count(el_group: *mut aws_event_loop_group) -> usize;
}
extern "C" {
    #[doc = " Fetches the next loop for use. The purpose is to enable load balancing across loops. You should not depend on how\n this load balancing is done as it is subject to change in the future. Currently it uses the \"best-of-two\" algorithm\n based on the load factor of each loop."]
    pub fn aws_event_loop_group_get_next_loop(
        el_group: *mut aws_event_loop_group,
    ) -> *mut aws_event_loop;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_directory_iterator {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_file_type {
    AWS_FILE_TYPE_FILE = 1,
    AWS_FILE_TYPE_SYM_LINK = 2,
    AWS_FILE_TYPE_DIRECTORY = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_directory_entry {
    #[doc = " Absolute path to the entry from the current process root."]
    pub path: aws_byte_cursor,
    #[doc = " Path to the entry relative to the current working directory."]
    pub relative_path: aws_byte_cursor,
    #[doc = " Bit-field of enum aws_file_type"]
    pub file_type: ::std::os::raw::c_int,
    #[doc = " Size of the file on disk."]
    pub file_size: i64,
}
#[test]
fn bindgen_test_layout_aws_directory_entry() {
    const UNINIT: ::std::mem::MaybeUninit<aws_directory_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_directory_entry>(),
        48usize,
        concat!("Size of: ", stringify!(aws_directory_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_directory_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_directory_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relative_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(relative_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(file_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_directory_entry),
            "::",
            stringify!(file_size)
        )
    );
}
#[doc = " Invoked during calls to aws_directory_traverse() as an entry is encountered. entry will contain\n the parsed directory entry info.\n\n Return true to continue the traversal, or alternatively, if you have a reason to abort the traversal, return false."]
pub type aws_on_directory_entry = ::std::option::Option<
    unsafe extern "C" fn(
        entry: *const aws_directory_entry,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = " Deprecated - Use aws_fopen_safe() instead, avoid const char * in public APIs.\n Opens file at file_path using mode. Returns the FILE pointer if successful.\n Otherwise, aws_last_error() will contain the error that occurred"]
    pub fn aws_fopen(
        file_path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Opens file at file_path using mode. Returns the FILE pointer if successful.\n Otherwise, aws_last_error() will contain the error that occurred"]
    pub fn aws_fopen_safe(file_path: *const aws_string, mode: *const aws_string) -> *mut FILE;
}
extern "C" {
    #[doc = " Creates a directory if it doesn't currently exist. If the directory already exists, it's ignored and assumed\n successful.\n\n Returns AWS_OP_SUCCESS on success. Otherwise, check aws_last_error()."]
    pub fn aws_directory_create(dir_path: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the directory currently exists. Otherwise, it returns false."]
    pub fn aws_directory_exists(dir_path: *const aws_string) -> bool;
}
extern "C" {
    #[doc = " Deletes a directory. If the directory is not empty, this will fail unless the recursive parameter is set to true.\n If recursive is true then the entire directory and all of its contents will be deleted. If it is set to false,\n the directory will be deleted only if it is empty. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred. If the directory doesn't exist, AWS_OP_SUCCESS is still\n returned."]
    pub fn aws_directory_delete(
        dir_path: *const aws_string,
        recursive: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deletes a file. Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred. If the file doesn't exist, AWS_OP_SUCCESS is still returned."]
    pub fn aws_file_delete(file_path: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Moves directory at from to to.\n Returns AWS_OP_SUCCESS if the operation was successful. Otherwise,\n aws_last_error() will contain the error that occurred."]
    pub fn aws_directory_or_file_move(
        from: *const aws_string,
        to: *const aws_string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Traverse a directory starting at path.\n\n If you want the traversal to recurse the entire directory, pass recursive as true. Passing false for this parameter\n will only iterate the contents of the directory, but will not descend into any directories it encounters.\n\n If recursive is set to true, the traversal is performed post-order, depth-first\n (for practical reasons such as deleting a directory that contains subdirectories or files).\n\n returns AWS_OP_SUCCESS(0) on success."]
    pub fn aws_directory_traverse(
        allocator: *mut aws_allocator,
        path: *const aws_string,
        recursive: bool,
        on_entry: aws_on_directory_entry,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a read-only iterator of a directory starting at path. If path is invalid or there's any other error\n condition, NULL will be returned. Call aws_last_error() for the exact error in that case."]
    pub fn aws_directory_entry_iterator_new(
        allocator: *mut aws_allocator,
        path: *const aws_string,
    ) -> *mut aws_directory_iterator;
}
extern "C" {
    #[doc = " Moves the iterator to the next entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with\n AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available."]
    pub fn aws_directory_entry_iterator_next(
        iterator: *mut aws_directory_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Moves the iterator to the previous entry. Returns AWS_OP_SUCCESS if another entry is available, or AWS_OP_ERR with\n AWS_ERROR_LIST_EMPTY as the value for aws_last_error() if no more entries are available."]
    pub fn aws_directory_entry_iterator_previous(
        iterator: *mut aws_directory_iterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleanup and deallocate iterator"]
    pub fn aws_directory_entry_iterator_destroy(iterator: *mut aws_directory_iterator);
}
extern "C" {
    #[doc = " Gets the aws_directory_entry value for iterator at the current position. Returns NULL if the iterator contains no\n entries."]
    pub fn aws_directory_entry_iterator_get_value(
        iterator: *const aws_directory_iterator,
    ) -> *const aws_directory_entry;
}
extern "C" {
    #[doc = " Returns true iff the character is a directory separator on ANY supported platform."]
    pub fn aws_is_any_directory_separator(value: ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Returns the directory separator used by the local platform"]
    pub fn aws_get_platform_directory_separator() -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Normalizes the path by replacing any directory separator with the local platform's directory separator.\n @param path path to normalize. Must be writeable."]
    pub fn aws_normalize_directory_separator(path: *mut aws_byte_buf);
}
extern "C" {
    #[doc = " Returns the current user's home directory."]
    pub fn aws_get_home_directory(allocator: *mut aws_allocator) -> *mut aws_string;
}
extern "C" {
    #[doc = " Returns true if a file or path exists, otherwise, false."]
    pub fn aws_path_exists(path: *const aws_string) -> bool;
}
extern "C" {
    pub fn aws_fseek(
        file: *mut FILE,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_file_get_length(file: *mut FILE, length: *mut i64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_impl {
    _unused: [u8; 0],
}
#[doc = " Completion callback for aws_future<T>"]
pub type aws_future_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
pub type aws_future_impl_result_clean_up_fn =
    ::std::option::Option<unsafe extern "C" fn(result_addr: *mut ::std::os::raw::c_void)>;
pub type aws_future_impl_result_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(result: *mut ::std::os::raw::c_void)>;
pub type aws_future_impl_result_release_fn = ::std::option::Option<
    unsafe extern "C" fn(result: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn aws_future_impl_new_by_value(
        alloc: *mut aws_allocator,
        sizeof_result: usize,
    ) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_new_by_value_with_clean_up(
        alloc: *mut aws_allocator,
        sizeof_result: usize,
        result_clean_up: aws_future_impl_result_clean_up_fn,
    ) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_new_pointer(alloc: *mut aws_allocator) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_new_pointer_with_destroy(
        alloc: *mut aws_allocator,
        result_destroy: aws_future_impl_result_destroy_fn,
    ) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_new_pointer_with_release(
        alloc: *mut aws_allocator,
        result_release: aws_future_impl_result_release_fn,
    ) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_release(promise: *mut aws_future_impl) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_acquire(promise: *mut aws_future_impl) -> *mut aws_future_impl;
}
extern "C" {
    pub fn aws_future_impl_set_error(
        promise: *mut aws_future_impl,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aws_future_impl_set_result_by_move(
        promise: *mut aws_future_impl,
        src_address: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_impl_is_done(future: *const aws_future_impl) -> bool;
}
extern "C" {
    pub fn aws_future_impl_register_callback(
        future: *mut aws_future_impl,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_impl_register_callback_if_not_done(
        future: *mut aws_future_impl,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn aws_future_impl_register_event_loop_callback(
        future: *mut aws_future_impl,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_impl_register_channel_callback(
        future: *mut aws_future_impl,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_impl_wait(future: *const aws_future_impl, timeout_ns: u64) -> bool;
}
extern "C" {
    pub fn aws_future_impl_get_error(future: *const aws_future_impl) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_future_impl_get_result_address(
        future: *const aws_future_impl,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aws_future_impl_get_result_by_move(
        future: *mut aws_future_impl,
        dst_address: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_size {
    _unused: [u8; 0],
}
extern "C" {
    pub fn aws_future_size_new(alloc: *mut aws_allocator) -> *mut aws_future_size;
}
extern "C" {
    pub fn aws_future_size_set_result(future: *mut aws_future_size, result: usize);
}
extern "C" {
    pub fn aws_future_size_get_result(future: *const aws_future_size) -> usize;
}
extern "C" {
    pub fn aws_future_size_acquire(future: *mut aws_future_size) -> *mut aws_future_size;
}
extern "C" {
    pub fn aws_future_size_release(future: *mut aws_future_size) -> *mut aws_future_size;
}
extern "C" {
    pub fn aws_future_size_set_error(
        future: *mut aws_future_size,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aws_future_size_is_done(future: *const aws_future_size) -> bool;
}
extern "C" {
    pub fn aws_future_size_get_error(future: *const aws_future_size) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_future_size_register_callback(
        future: *mut aws_future_size,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_size_register_callback_if_not_done(
        future: *mut aws_future_size,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn aws_future_size_register_event_loop_callback(
        future: *mut aws_future_size,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_size_register_channel_callback(
        future: *mut aws_future_size,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_size_wait(future: *mut aws_future_size, timeout_ns: u64) -> bool;
}
extern "C" {
    pub fn aws_future_bool_new(alloc: *mut aws_allocator) -> *mut aws_future_bool;
}
extern "C" {
    pub fn aws_future_bool_set_result(future: *mut aws_future_bool, result: bool);
}
extern "C" {
    pub fn aws_future_bool_get_result(future: *const aws_future_bool) -> bool;
}
extern "C" {
    pub fn aws_future_bool_acquire(future: *mut aws_future_bool) -> *mut aws_future_bool;
}
extern "C" {
    pub fn aws_future_bool_release(future: *mut aws_future_bool) -> *mut aws_future_bool;
}
extern "C" {
    pub fn aws_future_bool_set_error(
        future: *mut aws_future_bool,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aws_future_bool_is_done(future: *const aws_future_bool) -> bool;
}
extern "C" {
    pub fn aws_future_bool_get_error(future: *const aws_future_bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_future_bool_register_callback(
        future: *mut aws_future_bool,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_bool_register_callback_if_not_done(
        future: *mut aws_future_bool,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn aws_future_bool_register_event_loop_callback(
        future: *mut aws_future_bool,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_bool_register_channel_callback(
        future: *mut aws_future_bool,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_bool_wait(future: *mut aws_future_bool, timeout_ns: u64) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_future_void {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " aws_future<void>"]
    pub fn aws_future_void_new(alloc: *mut aws_allocator) -> *mut aws_future_void;
}
extern "C" {
    pub fn aws_future_void_set_result(future: *mut aws_future_void);
}
extern "C" {
    pub fn aws_future_void_acquire(future: *mut aws_future_void) -> *mut aws_future_void;
}
extern "C" {
    pub fn aws_future_void_release(future: *mut aws_future_void) -> *mut aws_future_void;
}
extern "C" {
    pub fn aws_future_void_set_error(
        future: *mut aws_future_void,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn aws_future_void_is_done(future: *const aws_future_void) -> bool;
}
extern "C" {
    pub fn aws_future_void_get_error(future: *const aws_future_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_future_void_register_callback(
        future: *mut aws_future_void,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_void_register_callback_if_not_done(
        future: *mut aws_future_void,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn aws_future_void_register_event_loop_callback(
        future: *mut aws_future_void,
        event_loop: *mut aws_event_loop,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_void_register_channel_callback(
        future: *mut aws_future_void,
        channel: *mut aws_channel,
        on_done: aws_future_callback_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn aws_future_void_wait(future: *mut aws_future_void, timeout_ns: u64) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_string {
    pub allocator: *mut aws_allocator,
    pub len: usize,
    pub bytes: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_aws_string() {
    const UNINIT: ::std::mem::MaybeUninit<aws_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_string>(),
        24usize,
        concat!("Size of: ", stringify!(aws_string))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_string>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_string),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_string),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_string),
            "::",
            stringify!(bytes)
        )
    );
}
extern "C" {
    #[doc = " Returns true if bytes of string are the same, false otherwise."]
    pub fn aws_string_eq(a: *const aws_string, b: *const aws_string) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_ignore_case(a: *const aws_string, b: *const aws_string) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and cursor are the same, false otherwise."]
    pub fn aws_string_eq_byte_cursor(str_: *const aws_string, cur: *const aws_byte_cursor) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and cursor are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_byte_cursor_ignore_case(
        str_: *const aws_string,
        cur: *const aws_byte_cursor,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and buffer are the same, false otherwise."]
    pub fn aws_string_eq_byte_buf(str_: *const aws_string, buf: *const aws_byte_buf) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of string and buffer are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_byte_buf_ignore_case(
        str_: *const aws_string,
        buf: *const aws_byte_buf,
    ) -> bool;
}
extern "C" {
    pub fn aws_string_eq_c_str(
        str_: *const aws_string,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns true if bytes of strings are equivalent, using a case-insensitive comparison."]
    pub fn aws_string_eq_c_str_ignore_case(
        str_: *const aws_string,
        c_str: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Constructor functions which copy data from null-terminated C-string or array of bytes."]
    pub fn aws_string_new_from_c_str(
        allocator: *mut aws_allocator,
        c_str: *const ::std::os::raw::c_char,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as array."]
    pub fn aws_string_new_from_array(
        allocator: *mut aws_allocator,
        bytes: *const u8,
        len: usize,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as another string."]
    pub fn aws_string_new_from_string(
        allocator: *mut aws_allocator,
        str_: *const aws_string,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as cursor."]
    pub fn aws_string_new_from_cursor(
        allocator: *mut aws_allocator,
        cursor: *const aws_byte_cursor,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Allocate a new string with the same contents as buf."]
    pub fn aws_string_new_from_buf(
        allocator: *mut aws_allocator,
        buf: *const aws_byte_buf,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Deallocate string."]
    pub fn aws_string_destroy(str_: *mut aws_string);
}
extern "C" {
    #[doc = " Zeroes out the data bytes of string and then deallocates the memory.\n Not safe to run on a string created with AWS_STATIC_STRING_FROM_LITERAL."]
    pub fn aws_string_destroy_secure(str_: *mut aws_string);
}
extern "C" {
    #[doc = " Compares lexicographical ordering of two strings. This is a binary\n byte-by-byte comparison, treating bytes as unsigned integers. It is suitable\n for either textual or binary data and is unaware of unicode or any other byte\n encoding. If both strings are identical in the bytes of the shorter string,\n then the longer string is lexicographically after the shorter.\n\n Returns a positive number if string a > string b. (i.e., string a is\n lexicographically after string b.) Returns zero if string a = string b.\n Returns negative number if string a < string b."]
    pub fn aws_string_compare(a: *const aws_string, b: *const aws_string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A convenience function for sorting lists of (const struct aws_string *) elements. This can be used as a\n comparator for aws_array_list_sort. It is just a simple wrapper around aws_string_compare."]
    pub fn aws_array_list_comparator_string(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copies all bytes from string to buf.\n\n On success, returns true and updates the buf pointer/length\n accordingly. If there is insufficient space in the buf, returns\n false, leaving the buf unchanged."]
    pub fn aws_byte_buf_write_from_whole_string(
        buf: *mut aws_byte_buf,
        src: *const aws_string,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates an aws_byte_cursor from an existing string."]
    pub fn aws_byte_cursor_from_string(src: *const aws_string) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " If the string was dynamically allocated, clones it. If the string was statically allocated (i.e. has no allocator),\n returns the original string."]
    pub fn aws_string_clone_or_reuse(
        allocator: *mut aws_allocator,
        str_: *const aws_string,
    ) -> *mut aws_string;
}
extern "C" {
    #[doc = " Computes the length of a c string in bytes assuming the character set is either ASCII or UTF-8. If no NULL character\n is found within max_read_len of str, AWS_ERROR_C_STRING_BUFFER_NOT_NULL_TERMINATED is raised. Otherwise, str_len\n will contain the string length minus the NULL character, and AWS_OP_SUCCESS will be returned."]
    pub fn aws_secure_strlen(
        str_: *const ::std::os::raw::c_char,
        max_read_len: usize,
        str_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__map) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__types) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneEntry),
            "::",
            stringify!(__types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nranges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__nranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ranges) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneRange),
            "::",
            stringify!(__ranges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneCharClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneCharClass),
            "::",
            stringify!(__mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    const UNINIT: ::std::mem::MaybeUninit<_RuneLocale> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sgetrune) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sgetrune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sputrune) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__sputrune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__invalid_rune) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__invalid_rune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__runetype) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__maplower) as usize - ptr as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mapupper) as usize - ptr as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__runetype_ext) as usize - ptr as usize },
        3136usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__runetype_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__maplower_ext) as usize - ptr as usize },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__maplower_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mapupper_ext) as usize - ptr as usize },
        3168usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__mapupper_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__variable) as usize - ptr as usize },
        3184usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__variable_len) as usize - ptr as usize },
        3192usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__variable_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ncharclasses) as usize - ptr as usize },
        3196usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__ncharclasses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__charclasses) as usize - ptr as usize },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(_RuneLocale),
            "::",
            stringify!(__charclasses)
        )
    );
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_5 = _bindgen_ty_5::QOS_CLASS_USER_INTERACTIVE;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_5 = _bindgen_ty_5::QOS_CLASS_USER_INITIATED;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_5 = _bindgen_ty_5::QOS_CLASS_DEFAULT;
pub const QOS_CLASS_UTILITY: _bindgen_ty_5 = _bindgen_ty_5::QOS_CLASS_UTILITY;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_5 = _bindgen_ty_5::QOS_CLASS_BACKGROUND;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_5 = _bindgen_ty_5::QOS_CLASS_UNSPECIFIED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_5 {
    QOS_CLASS_USER_INTERACTIVE = 33,
    QOS_CLASS_USER_INITIATED = 25,
    QOS_CLASS_DEFAULT = 21,
    QOS_CLASS_UTILITY = 17,
    QOS_CLASS_BACKGROUND = 9,
    QOS_CLASS_UNSPECIFIED = 0,
}
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut usize) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_thread_detach_state {
    AWS_THREAD_NOT_CREATED = 1,
    AWS_THREAD_JOINABLE = 2,
    AWS_THREAD_JOIN_COMPLETED = 3,
    AWS_THREAD_MANAGED = 4,
}
#[repr(u32)]
#[doc = " Specifies the join strategy used on an aws_thread, which in turn controls whether or not a thread participates\n in the managed thread system.  The managed thread system provides logic to guarantee a join on all participating\n threads at the cost of laziness (the user cannot control when joins happen).\n\n Manual - thread does not participate in the managed thread system; any joins must be done by the user.  This\n is the default.  The user must call aws_thread_clean_up(), but only after any desired join operation has completed.\n Not doing so will cause the windows handle to leak.\n\n Managed - the managed thread system will automatically perform a join some time after the thread's run function\n has completed.  It is an error to call aws_thread_join on a thread configured with the managed join strategy.  The\n managed thread system will call aws_thread_clean_up() on the thread after the background join has completed.\n\n Additionally, an API exists, aws_thread_join_all_managed(), which blocks and returns when all outstanding threads\n with the managed strategy have fully joined.  This API is useful for tests (rather than waiting for many individual\n signals) and program shutdown or DLL unload.  This API is automatically invoked by the common library clean up\n function.  If the common library clean up is called from a managed thread, this will cause deadlock.\n\n Lazy thread joining is done only when threads finish their run function or when the user calls\n aws_thread_join_all_managed().  This means it may be a long time between thread function completion and the join\n being applied, but the queue of unjoined threads is always one or fewer so there is no critical resource\n backlog.\n\n Currently, only event loop group async cleanup and host resolver threads participate in the managed thread system.\n Additionally, event loop threads will increment and decrement the pending join count (they are manually joined\n internally) in order to have an accurate view of internal thread usage and also to prevent failure to release\n an event loop group fully from allowing aws_thread_join_all_managed() from running to completion when its\n intent is such that it should block instead."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_thread_join_strategy {
    AWS_TJS_MANUAL = 0,
    AWS_TJS_MANAGED = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread_options {
    pub stack_size: usize,
    pub cpu_id: i32,
    pub join_strategy: aws_thread_join_strategy,
    #[doc = " Thread name, for debugging purpose.\n The length should not exceed AWS_THREAD_NAME_RECOMMENDED_STRLEN(15)\n if you want it to display properly on all platforms."]
    pub name: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_thread_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_thread_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_thread_options>(),
        32usize,
        concat!("Size of: ", stringify!(aws_thread_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_thread_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_thread_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join_strategy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(join_strategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread_options),
            "::",
            stringify!(name)
        )
    );
}
pub type aws_thread_once = pthread_once_t;
pub type aws_thread_id_t = pthread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_thread {
    pub allocator: *mut aws_allocator,
    pub detach_state: aws_thread_detach_state,
    pub thread_id: aws_thread_id_t,
}
#[test]
fn bindgen_test_layout_aws_thread() {
    const UNINIT: ::std::mem::MaybeUninit<aws_thread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_thread>(),
        24usize,
        concat!("Size of: ", stringify!(aws_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_thread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detach_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread),
            "::",
            stringify!(detach_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_thread),
            "::",
            stringify!(thread_id)
        )
    );
}
extern "C" {
    #[doc = " Returns an instance of system default thread options."]
    pub fn aws_default_thread_options() -> *const aws_thread_options;
}
extern "C" {
    pub fn aws_thread_call_once(
        flag: *mut aws_thread_once,
        call_once: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Initializes a new platform specific thread object struct (not the os-level\n thread itself)."]
    pub fn aws_thread_init(
        thread: *mut aws_thread,
        allocator: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates an OS level thread and associates it with func. context will be passed to func when it is executed.\n options will be applied to the thread if they are applicable for the platform.\n\n After launch, you may join on the thread.  A successfully launched thread must have clean_up called on it in order\n to avoid a handle leak.  If you do not join before calling clean_up, the thread will become detached.\n\n Managed threads must not have join or clean_up called on them by external code."]
    pub fn aws_thread_launch(
        thread: *mut aws_thread,
        func: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        options: *const aws_thread_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the id of thread"]
    pub fn aws_thread_get_id(thread: *mut aws_thread) -> aws_thread_id_t;
}
extern "C" {
    #[doc = " Gets the detach state of the thread. For example, is it safe to call join on\n this thread? Has it been detached()?"]
    pub fn aws_thread_get_detach_state(thread: *mut aws_thread) -> aws_thread_detach_state;
}
extern "C" {
    #[doc = " Joins the calling thread to a thread instance. Returns when thread is\n finished.  Calling this from the associated OS thread will cause a deadlock."]
    pub fn aws_thread_join(thread: *mut aws_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Blocking call that waits for all managed threads to complete their join call.  This can only be called\n from the main thread or a non-managed thread.\n\n This gets called automatically from library cleanup.\n\n By default the wait is unbounded, but that default can be overridden via aws_thread_set_managed_join_timeout_ns()"]
    pub fn aws_thread_join_all_managed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overrides how long, in nanoseconds, that aws_thread_join_all_managed will wait for threads to complete.\n A value of zero will result in an unbounded wait."]
    pub fn aws_thread_set_managed_join_timeout_ns(timeout_in_ns: u64);
}
extern "C" {
    #[doc = " Cleans up the thread handle. Don't call this on a managed thread.  If you wish to join the thread, you must join\n before calling this function."]
    pub fn aws_thread_clean_up(thread: *mut aws_thread);
}
extern "C" {
    #[doc = " Returns the thread id of the calling thread."]
    pub fn aws_thread_current_thread_id() -> aws_thread_id_t;
}
extern "C" {
    #[doc = " Compare thread ids."]
    pub fn aws_thread_thread_id_equal(t1: aws_thread_id_t, t2: aws_thread_id_t) -> bool;
}
extern "C" {
    #[doc = " Sleeps the current thread by nanos."]
    pub fn aws_thread_current_sleep(nanos: u64);
}
pub type aws_thread_atexit_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Adds a callback to the chain to be called when the current thread joins.\n Callbacks are called from the current thread, in the reverse order they\n were added, after the thread function returns.\n If not called from within an aws_thread, has no effect."]
    pub fn aws_thread_current_at_exit(
        callback: aws_thread_atexit_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increments the count of unjoined threads in the managed thread system.  Used by managed threads and\n event loop threads.  Additional usage requires the user to join corresponding threads themselves and\n correctly increment/decrement even in the face of launch/join errors.\n\n aws_thread_join_all_managed() will not return until this count has gone to zero."]
    pub fn aws_thread_increment_unjoined_count();
}
extern "C" {
    #[doc = " Decrements the count of unjoined threads in the managed thread system.  Used by managed threads and\n event loop threads.  Additional usage requires the user to join corresponding threads themselves and\n correctly increment/decrement even in the face of launch/join errors.\n\n aws_thread_join_all_managed() will not return until this count has gone to zero."]
    pub fn aws_thread_decrement_unjoined_count();
}
extern "C" {
    #[doc = " Gets name of the current thread.\n Caller is responsible for destroying returned string.\n If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is\n set to NULL.\n If underlying OS call fails,  AWS_ERROR_SYS_CALL_FAILURE will be raised\n If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED\n will be raised"]
    pub fn aws_thread_current_name(
        allocator: *mut aws_allocator,
        out_name: *mut *mut aws_string,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets name of the thread.\n Caller is responsible for destroying returned string.\n If thread does not have a name, AWS_OP_SUCCESS is returned and out_name is\n set to NULL.\n If underlying OS call fails,  AWS_ERROR_SYS_CALL_FAILURE will be raised\n If OS does not support getting thread name, AWS_ERROR_PLATFORM_NOT_SUPPORTED\n will be raised"]
    pub fn aws_thread_name(
        allocator: *mut aws_allocator,
        thread_id: aws_thread_id_t,
        out_name: *mut *mut aws_string,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[doc = " Controls what log calls pass through the logger and what log calls get filtered out.\n If a log level has a value of X, then all log calls using a level <= X will appear, while\n those using a value > X will not occur.\n\n You can filter both dynamically (by setting the log level on the logger object) or statically\n (by defining AWS_STATIC_LOG_LEVEL to be an appropriate integer module-wide).  Statically filtered\n log calls will be completely compiled out but require a rebuild if you want to get more detail\n about what's happening."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_log_level {
    AWS_LL_NONE = 0,
    AWS_LL_FATAL = 1,
    AWS_LL_ERROR = 2,
    AWS_LL_WARN = 3,
    AWS_LL_INFO = 4,
    AWS_LL_DEBUG = 5,
    AWS_LL_TRACE = 6,
    AWS_LL_COUNT = 7,
}
#[doc = " Log subject is a way of designating the topic of logging.\n\n The general idea is to support a finer-grained approach to log level control.  The primary use case\n is for situations that require more detailed logging within a specific domain, where enabling that detail\n globally leads to an untenable flood of information.\n\n For example, enable TRACE logging for tls-related log statements (handshake binary payloads), but\n only WARN logging everywhere else (because http payloads would blow up the log files).\n\n Log subject is an enum similar to aws error: each library has its own value-space and someone is\n responsible for registering the value <-> string connections."]
pub type aws_log_subject_t = u32;
pub const AWS_LOG_SUBJECT_STRIDE_BITS: _bindgen_ty_6 = _bindgen_ty_6::AWS_LOG_SUBJECT_STRIDE_BITS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_6 {
    AWS_LOG_SUBJECT_STRIDE_BITS = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_subject_info {
    pub subject_id: aws_log_subject_t,
    pub subject_name: *const ::std::os::raw::c_char,
    pub subject_description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_aws_log_subject_info() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_subject_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_subject_info>(),
        24usize,
        concat!("Size of: ", stringify!(aws_log_subject_info))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_subject_info>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_subject_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info),
            "::",
            stringify!(subject_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info),
            "::",
            stringify!(subject_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info),
            "::",
            stringify!(subject_description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_subject_info_list {
    pub subject_list: *mut aws_log_subject_info,
    pub count: usize,
}
#[test]
fn bindgen_test_layout_aws_log_subject_info_list() {
    const UNINIT: ::std::mem::MaybeUninit<aws_log_subject_info_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_log_subject_info_list>(),
        16usize,
        concat!("Size of: ", stringify!(aws_log_subject_info_list))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_log_subject_info_list>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_log_subject_info_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subject_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info_list),
            "::",
            stringify!(subject_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_log_subject_info_list),
            "::",
            stringify!(count)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_common_log_subject {
    AWS_LS_COMMON_GENERAL = 0,
    AWS_LS_COMMON_TASK_SCHEDULER = 1,
    AWS_LS_COMMON_THREAD = 2,
    AWS_LS_COMMON_MEMTRACE = 3,
    AWS_LS_COMMON_XML_PARSER = 4,
    AWS_LS_COMMON_IO = 5,
    AWS_LS_COMMON_BUS = 6,
    AWS_LS_COMMON_TEST = 7,
    AWS_LS_COMMON_JSON_PARSER = 8,
    AWS_LS_COMMON_CBOR = 9,
    AWS_LS_COMMON_LAST = 1023,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_formatter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_channel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_log_writer {
    _unused: [u8; 0],
}
#[doc = " We separate the log level function from the log call itself so that we can do the filter check in the macros (see\n below)\n\n By doing so, we make it so that the variadic format arguments are not even evaluated if the filter check does not\n succeed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_vtable {
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            logger: *mut aws_logger,
            log_level: aws_log_level,
            subject: aws_log_subject_t,
            format: *const ::std::os::raw::c_char,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub get_log_level: ::std::option::Option<
        unsafe extern "C" fn(logger: *mut aws_logger, subject: aws_log_subject_t) -> aws_log_level,
    >,
    pub clean_up: ::std::option::Option<unsafe extern "C" fn(logger: *mut aws_logger)>,
    pub set_log_level: ::std::option::Option<
        unsafe extern "C" fn(logger: *mut aws_logger, arg1: aws_log_level) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_aws_logger_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger_vtable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger_vtable>(),
        32usize,
        concat!("Size of: ", stringify!(aws_logger_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_log_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(get_log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clean_up) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(clean_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_log_level) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_vtable),
            "::",
            stringify!(set_log_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger {
    pub vtable: *mut aws_logger_vtable,
    pub allocator: *mut aws_allocator,
    pub p_impl: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_logger() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger>(),
        24usize,
        concat!("Size of: ", stringify!(aws_logger))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_impl) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger),
            "::",
            stringify!(p_impl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_pipeline {
    pub formatter: *mut aws_log_formatter,
    pub channel: *mut aws_log_channel,
    pub writer: *mut aws_log_writer,
    pub allocator: *mut aws_allocator,
    pub level: aws_atomic_var,
}
#[test]
fn bindgen_test_layout_aws_logger_pipeline() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger_pipeline> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger_pipeline>(),
        40usize,
        concat!("Size of: ", stringify!(aws_logger_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger_pipeline))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).formatter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(formatter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_pipeline),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " Options for aws_logger_init_standard().\n Set `filename` to open a file for logging and close it when the logger cleans up.\n Set `file` to use a file that is already open, such as `stderr` or `stdout`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_logger_standard_options {
    pub level: aws_log_level,
    pub filename: *const ::std::os::raw::c_char,
    pub file: *mut FILE,
}
#[test]
fn bindgen_test_layout_aws_logger_standard_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_logger_standard_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_logger_standard_options>(),
        24usize,
        concat!("Size of: ", stringify!(aws_logger_standard_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_logger_standard_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_logger_standard_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_standard_options),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_standard_options),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_logger_standard_options),
            "::",
            stringify!(file)
        )
    );
}
extern "C" {
    #[doc = " Sets the aws logger used globally across the process.  Not thread-safe.  Must only be called once."]
    pub fn aws_logger_set(logger: *mut aws_logger);
}
extern "C" {
    #[doc = " Gets the aws logger used globally across the process."]
    pub fn aws_logger_get() -> *mut aws_logger;
}
extern "C" {
    #[doc = " Gets the aws logger used globally across the process if the logging level is at least the inputted level.\n\n @param subject log subject to perform the level check versus, not currently used\n @param level logging level to check against in order to return the logger\n @return the current logger if the current logging level is at or more detailed then the supplied logging level"]
    pub fn aws_logger_get_conditional(
        subject: aws_log_subject_t,
        level: aws_log_level,
    ) -> *mut aws_logger;
}
extern "C" {
    #[doc = " Cleans up all resources used by the logger; simply invokes the clean_up v-function"]
    pub fn aws_logger_clean_up(logger: *mut aws_logger);
}
extern "C" {
    #[doc = " Sets the current logging level for the logger.  Loggers are not require to support this.\n @param logger logger to set the log level for\n @param level new log level for the logger\n @return AWS_OP_SUCCESS if the level was successfully set, AWS_OP_ERR otherwise"]
    pub fn aws_logger_set_log_level(
        logger: *mut aws_logger,
        level: aws_log_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a log level to a c-string constant.  Intended primarily to support building log lines that\n include the level in them, i.e.\n\n [ERROR] 10:34:54.642 01-31-19 - Json parse error...."]
    pub fn aws_log_level_to_string(
        log_level: aws_log_level,
        level_string: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts a c-string constant to a log level value.  Uses case-insensitive comparison\n and simply iterates all possibilities until a match or nothing remains.  If no match\n is found, AWS_OP_ERR is returned."]
    pub fn aws_string_to_log_level(
        level_string: *const ::std::os::raw::c_char,
        log_level: *mut aws_log_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Converts an aws_thread_id_t to a c-string.  For portability, aws_thread_id_t\n must not be printed directly.  Intended primarily to support building log\n lines that include the thread id in them.  The parameter `buffer` must\n point-to a char buffer of length `bufsz == AWS_THREAD_ID_T_REPR_BUFSZ`.  The\n thread id representation is returned in `buffer`."]
    pub fn aws_thread_id_t_to_string(
        thread_id: aws_thread_id_t,
        buffer: *mut ::std::os::raw::c_char,
        bufsz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get subject name from log subject."]
    pub fn aws_log_subject_name(subject: aws_log_subject_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Connects log subject strings with log subject integer values"]
    pub fn aws_register_log_subject_info_list(log_subject_list: *mut aws_log_subject_info_list);
}
extern "C" {
    #[doc = " Disconnects log subject strings with log subject integer values"]
    pub fn aws_unregister_log_subject_info_list(log_subject_list: *mut aws_log_subject_info_list);
}
extern "C" {
    pub fn aws_logger_init_standard(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        options: *mut aws_logger_standard_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_logger_init_from_external(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        formatter: *mut aws_log_formatter,
        channel: *mut aws_log_channel,
        writer: *mut aws_log_writer,
        level: aws_log_level,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut g_pipeline_logger_owned_vtable: aws_logger_vtable;
}
extern "C" {
    pub fn aws_logger_init_noalloc(
        logger: *mut aws_logger,
        allocator: *mut aws_allocator,
        options: *mut aws_logger_standard_options,
    ) -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_io_log_subject {
    AWS_LS_IO_GENERAL = 1024,
    AWS_LS_IO_EVENT_LOOP = 1025,
    AWS_LS_IO_SOCKET = 1026,
    AWS_LS_IO_SOCKET_HANDLER = 1027,
    AWS_LS_IO_TLS = 1028,
    AWS_LS_IO_ALPN = 1029,
    AWS_LS_IO_DNS = 1030,
    AWS_LS_IO_PKI = 1031,
    AWS_LS_IO_CHANNEL = 1032,
    AWS_LS_IO_CHANNEL_BOOTSTRAP = 1033,
    AWS_LS_IO_FILE_UTILS = 1034,
    AWS_LS_IO_SHARED_LIBRARY = 1035,
    AWS_LS_IO_EXPONENTIAL_BACKOFF_RETRY_STRATEGY = 1036,
    AWS_LS_IO_STANDARD_RETRY_STRATEGY = 1037,
    AWS_LS_IO_PKCS11 = 1038,
    AWS_LS_IO_PEM = 1039,
    AWS_IO_LS_LAST = 2047,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_memory_pool {
    pub alloc: *mut aws_allocator,
    pub stack: aws_array_list,
    pub ideal_segment_count: u16,
    pub segment_size: usize,
    pub data_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_memory_pool() {
    const UNINIT: ::std::mem::MaybeUninit<aws_memory_pool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_memory_pool>(),
        72usize,
        concat!("Size of: ", stringify!(aws_memory_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_memory_pool>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_memory_pool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_pool),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_pool),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ideal_segment_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_pool),
            "::",
            stringify!(ideal_segment_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_pool),
            "::",
            stringify!(segment_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_ptr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_memory_pool),
            "::",
            stringify!(data_ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_message_pool {
    pub alloc: *mut aws_allocator,
    pub application_data_pool: aws_memory_pool,
    pub small_block_pool: aws_memory_pool,
}
#[test]
fn bindgen_test_layout_aws_message_pool() {
    const UNINIT: ::std::mem::MaybeUninit<aws_message_pool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_message_pool>(),
        152usize,
        concat!("Size of: ", stringify!(aws_message_pool))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_message_pool>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_message_pool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data_pool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool),
            "::",
            stringify!(application_data_pool)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).small_block_pool) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool),
            "::",
            stringify!(small_block_pool)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_message_pool_creation_args {
    pub application_data_msg_data_size: usize,
    pub application_data_msg_count: u8,
    pub small_block_msg_data_size: usize,
    pub small_block_msg_count: u8,
}
#[test]
fn bindgen_test_layout_aws_message_pool_creation_args() {
    const UNINIT: ::std::mem::MaybeUninit<aws_message_pool_creation_args> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_message_pool_creation_args>(),
        32usize,
        concat!("Size of: ", stringify!(aws_message_pool_creation_args))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_message_pool_creation_args>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_message_pool_creation_args))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).application_data_msg_data_size) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool_creation_args),
            "::",
            stringify!(application_data_msg_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data_msg_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool_creation_args),
            "::",
            stringify!(application_data_msg_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).small_block_msg_data_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool_creation_args),
            "::",
            stringify!(small_block_msg_data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).small_block_msg_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_message_pool_creation_args),
            "::",
            stringify!(small_block_msg_count)
        )
    );
}
extern "C" {
    pub fn aws_memory_pool_init(
        mempool: *mut aws_memory_pool,
        alloc: *mut aws_allocator,
        ideal_segment_count: u16,
        segment_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_memory_pool_clean_up(mempool: *mut aws_memory_pool);
}
extern "C" {
    #[doc = " Acquires memory from the pool if available, otherwise, it attempts to allocate and returns the result."]
    pub fn aws_memory_pool_acquire(mempool: *mut aws_memory_pool) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Releases memory to the pool if space is available, otherwise frees `to_release`"]
    pub fn aws_memory_pool_release(
        mempool: *mut aws_memory_pool,
        to_release: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Initializes message pool using 'msg_pool' as the backing pool, 'args' is copied."]
    pub fn aws_message_pool_init(
        msg_pool: *mut aws_message_pool,
        alloc: *mut aws_allocator,
        args: *mut aws_message_pool_creation_args,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_message_pool_clean_up(msg_pool: *mut aws_message_pool);
}
extern "C" {
    #[doc = " Acquires a message from the pool if available, otherwise, it attempts to allocate. If a message is acquired,\n note that size_hint is just a hint. the return value's capacity will be set to the actual buffer size."]
    pub fn aws_message_pool_acquire(
        msg_pool: *mut aws_message_pool,
        message_type: aws_io_message_type,
        size_hint: usize,
    ) -> *mut aws_io_message;
}
extern "C" {
    #[doc = " Releases message to the pool if space is available, otherwise frees `message`\n @param message"]
    pub fn aws_message_pool_release(msg_pool: *mut aws_message_pool, message: *mut aws_io_message);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_pem_object_type {
    AWS_PEM_TYPE_UNKNOWN = 0,
    AWS_PEM_TYPE_X509_OLD = 1,
    AWS_PEM_TYPE_X509 = 2,
    AWS_PEM_TYPE_X509_TRUSTED = 3,
    AWS_PEM_TYPE_X509_REQ_OLD = 4,
    AWS_PEM_TYPE_X509_REQ = 5,
    AWS_PEM_TYPE_X509_CRL = 6,
    AWS_PEM_TYPE_EVP_PKEY = 7,
    AWS_PEM_TYPE_PUBLIC_PKCS8 = 8,
    AWS_PEM_TYPE_PRIVATE_RSA_PKCS1 = 9,
    AWS_PEM_TYPE_PUBLIC_RSA_PKCS1 = 10,
    AWS_PEM_TYPE_PRIVATE_DSA_PKCS1 = 11,
    AWS_PEM_TYPE_PUBLIC_DSA_PKCS1 = 12,
    AWS_PEM_TYPE_PKCS7 = 13,
    AWS_PEM_TYPE_PKCS7_SIGNED_DATA = 14,
    AWS_PEM_TYPE_PRIVATE_PKCS8_ENCRYPTED = 15,
    AWS_PEM_TYPE_PRIVATE_PKCS8 = 16,
    AWS_PEM_TYPE_DH_PARAMETERS = 17,
    AWS_PEM_TYPE_DH_PARAMETERS_X942 = 18,
    AWS_PEM_TYPE_SSL_SESSION_PARAMETERS = 19,
    AWS_PEM_TYPE_DSA_PARAMETERS = 20,
    AWS_PEM_TYPE_ECDSA_PUBLIC = 21,
    AWS_PEM_TYPE_EC_PARAMETERS = 22,
    AWS_PEM_TYPE_EC_PRIVATE = 23,
    AWS_PEM_TYPE_PARAMETERS = 24,
    AWS_PEM_TYPE_CMS = 25,
    AWS_PEM_TYPE_SM2_PARAMETERS = 26,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pem_object {
    pub type_: aws_pem_object_type,
    pub type_string: *mut aws_string,
    pub data: aws_byte_buf,
}
#[test]
fn bindgen_test_layout_aws_pem_object() {
    const UNINIT: ::std::mem::MaybeUninit<aws_pem_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_pem_object>(),
        48usize,
        concat!("Size of: ", stringify!(aws_pem_object))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_pem_object>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_pem_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pem_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pem_object),
            "::",
            stringify!(type_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pem_object),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Cleans up elements of pem_objects list 'aws_pem_objects_init_from_file_contents()'\n and 'aws_pem_objects_init_from_file_path()'."]
    pub fn aws_pem_objects_clean_up(pem_objects: *mut aws_array_list);
}
extern "C" {
    #[doc = " Decodes PEM data and reads objects sequentially adding them to pem_objects.\n If it comes across an object it cannot read, list of all object read until\n that point is returned.\n If no objects can be read from PEM or objects could not be base 64 decoded,\n AWS_ERROR_PEM_MALFORMED is raised.\n out_pem_objects stores aws_pem_object struct by value.\n Function will initialize pem_objects list.\n This code is slow, and it allocates, so please try\n not to call this in the middle of something that needs to be fast or resource sensitive."]
    pub fn aws_pem_objects_init_from_file_contents(
        pem_objects: *mut aws_array_list,
        alloc: *mut aws_allocator,
        pem_cursor: aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes PEM data from file and reads objects sequentially adding them to pem_objects.\n If it comes across an object it cannot read, list of all object read until\n that point is returned.\n If no objects can be read from PEM or objects could not be base 64 decoded,\n AWS_ERROR_PEM_MALFORMED is raised.\n out_pem_objects stores aws_pem_object struct by value.\n Function will initialize pem_objects list.\n This code is slow, and it allocates, so please try\n not to call this in the middle of something that needs to be fast or resource sensitive."]
    pub fn aws_pem_objects_init_from_file_path(
        pem_objects: *mut aws_array_list,
        allocator: *mut aws_allocator,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pipe_read_end {
    pub impl_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_pipe_read_end() {
    const UNINIT: ::std::mem::MaybeUninit<aws_pipe_read_end> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_pipe_read_end>(),
        8usize,
        concat!("Size of: ", stringify!(aws_pipe_read_end))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_pipe_read_end>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_pipe_read_end))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pipe_read_end),
            "::",
            stringify!(impl_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pipe_write_end {
    pub impl_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_pipe_write_end() {
    const UNINIT: ::std::mem::MaybeUninit<aws_pipe_write_end> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_pipe_write_end>(),
        8usize,
        concat!("Size of: ", stringify!(aws_pipe_write_end))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_pipe_write_end>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_pipe_write_end))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pipe_write_end),
            "::",
            stringify!(impl_data)
        )
    );
}
#[doc = " Callback for when the pipe is readable (edge-triggered), or an error has occurred.\n Afer subscribing, the callback is invoked when the pipe has data to read, or the pipe has an error.\n The readable callback is invoked again any time the user reads all data, and then more data arrives.\n Note that it will not be invoked again if the pipe still has unread data when more data arrives.\n `error_code` of AWS_ERROR_SUCCESS indicates a readable event, and otherwise contains the value of the error.\n `user_data` corresponds to the `user_data` passed into aws_pipe_subscribe_to_read_events().\n This callback is always invoked on the read-end's event-loop thread."]
pub type aws_pipe_on_readable_fn = ::std::option::Option<
    unsafe extern "C" fn(
        read_end: *mut aws_pipe_read_end,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for when the asynchronous aws_pipe_write() operation has either completed or failed.\n `write_end` will be NULL if this callback is invoked after the the write-end has been cleaned up,\n this does not necessarily mean that the write operation failed.\n `error_code` will be AWS_ERROR_SUCCESS if all data was written, or a code corresponding to the error.\n `src_buffer` corresponds to the buffer passed into aws_pipe_write()\n `user_data` corresponds to the `user_data` passed into aws_pipe_write().\n This callback is always invoked on the write-end's event-loop thread."]
pub type aws_pipe_on_write_completed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        write_end: *mut aws_pipe_write_end,
        error_code: ::std::os::raw::c_int,
        src_buffer: aws_byte_cursor,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Opens an OS specific bidirectional pipe.\n The read direction is stored in read_end. Write direction is stored in write_end.\n Each end must be connected to an event-loop, and further calls to each end must happen on that event-loop's thread."]
    pub fn aws_pipe_init(
        read_end: *mut aws_pipe_read_end,
        read_end_event_loop: *mut aws_event_loop,
        write_end: *mut aws_pipe_write_end,
        write_end_event_loop: *mut aws_event_loop,
        allocator: *mut aws_allocator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up the read-end of the pipe.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_clean_up_read_end(read_end: *mut aws_pipe_read_end) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up the write-end of the pipe.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_clean_up_write_end(write_end: *mut aws_pipe_write_end)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the event-loop connected to the read-end of the pipe.\n This may be called on any thread."]
    pub fn aws_pipe_get_read_end_event_loop(
        read_end: *const aws_pipe_read_end,
    ) -> *mut aws_event_loop;
}
extern "C" {
    #[doc = " Get the event-loop connected to the write-end of the pipe.\n This may be called on any thread."]
    pub fn aws_pipe_get_write_end_event_loop(
        write_end: *const aws_pipe_write_end,
    ) -> *mut aws_event_loop;
}
extern "C" {
    #[doc = " Initiates an asynchrous write from the source buffer to the pipe.\n The data referenced by `src_buffer` must remain in memory until the operation completes.\n `on_complete` is called on the event-loop thread when the operation has either completed or failed.\n The callback's pipe argument will be NULL if the callback is invoked after the pipe has been cleaned up.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_write(
        write_end: *mut aws_pipe_write_end,
        src_buffer: aws_byte_cursor,
        on_completed: aws_pipe_on_write_completed_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data from the pipe into the destination buffer.\n Attempts to read enough to fill all remaining space in the buffer, from `dst_buffer->len` to `dst_buffer->capacity`.\n `dst_buffer->len` is updated to reflect the buffer's new length.\n `num_bytes_read` (optional) is set to the total number of bytes read.\n This function never blocks. If no bytes could be read without blocking, then AWS_OP_ERR is returned and\n aws_last_error() code will be AWS_IO_READ_WOULD_BLOCK.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_read(
        read_end: *mut aws_pipe_read_end,
        dst_buffer: *mut aws_byte_buf,
        num_bytes_read: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Subscribe to be notified when the pipe becomes readable (edge-triggered), or an error occurs.\n `on_readable` is invoked on the event-loop's thread when the pipe has data to read, or the pipe has an error.\n `on_readable` is invoked again any time the user reads all data, and then more data arrives.\n Note that it will not be invoked again if the pipe still has unread data when more data arrives.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_subscribe_to_readable_events(
        read_end: *mut aws_pipe_read_end,
        on_readable: aws_pipe_on_readable_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop receiving notifications about events on the read-end of the pipe.\n This must be called on the thread of the connected event-loop."]
    pub fn aws_pipe_unsubscribe_from_readable_events(
        read_end: *mut aws_pipe_read_end,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Handle to a loaded PKCS#11 library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pkcs11_lib {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " Controls how aws_pkcs11_lib calls C_Initialize() and C_Finalize() on the PKCS#11 library."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_pkcs11_lib_behavior {
    #[doc = " Default behavior that accommodates most use cases.\n C_Initialize() is called on creation, and \"already-initialized\" errors are ignored.\n C_Finalize() is never called, just in case another part of your\n application is still using the PKCS#11 library."]
    AWS_PKCS11_LIB_DEFAULT_BEHAVIOR = 0,
    #[doc = " Skip calling C_Initialize() and C_Finalize().\n Use this if your application has already initialized the PKCS#11 library,\n and you do not want C_Initialize() called again."]
    AWS_PKCS11_LIB_OMIT_INITIALIZE = 1,
    #[doc = " C_Initialize() is called on creation and C_Finalize() is called on cleanup.\n If C_Initialize() reports that's it's already initialized, this is treated as an error.\n Use this if you need perfect cleanup (ex: running valgrind with --leak-check)."]
    AWS_PKCS11_LIB_STRICT_INITIALIZE_FINALIZE = 2,
}
#[doc = " Options for aws_pkcs11_lib_new()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pkcs11_lib_options {
    #[doc = " Name of PKCS#11 library file to load (UTF-8).\n Zero out if your application is compiled with PKCS#11 symbols linked in."]
    pub filename: aws_byte_cursor,
    #[doc = " Behavior for calling C_Initialize() and C_Finalize() on the PKCS#11 library."]
    pub initialize_finalize_behavior: aws_pkcs11_lib_behavior,
}
#[test]
fn bindgen_test_layout_aws_pkcs11_lib_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_pkcs11_lib_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_pkcs11_lib_options>(),
        24usize,
        concat!("Size of: ", stringify!(aws_pkcs11_lib_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_pkcs11_lib_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_pkcs11_lib_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pkcs11_lib_options),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).initialize_finalize_behavior) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_pkcs11_lib_options),
            "::",
            stringify!(initialize_finalize_behavior)
        )
    );
}
extern "C" {
    #[doc = " Load and initialize a PKCS#11 library.\n See `aws_pkcs11_lib_options` for options.\n\n If successful a valid pointer is returned. You must call aws_pkcs11_lib_release() when you are done with it.\n If unsuccessful, NULL is returned and an error is set."]
    pub fn aws_pkcs11_lib_new(
        allocator: *mut aws_allocator,
        options: *const aws_pkcs11_lib_options,
    ) -> *mut aws_pkcs11_lib;
}
extern "C" {
    #[doc = " Acquire a reference to a PKCS#11 library, preventing it from being cleaned up.\n You must call aws_pkcs11_lib_release() when you are done with it.\n This function returns whatever was passed in. It cannot fail."]
    pub fn aws_pkcs11_lib_acquire(pkcs11_lib: *mut aws_pkcs11_lib) -> *mut aws_pkcs11_lib;
}
extern "C" {
    #[doc = " Release a reference to the PKCS#11 library.\n When the last reference is released, the library is cleaned up."]
    pub fn aws_pkcs11_lib_release(pkcs11_lib: *mut aws_pkcs11_lib);
}
#[doc = " Invoked upon the acquisition, or failure to acquire a retry token. This function will always be invoked if and only\n if aws_retry_strategy_acquire_retry_token() returns AWS_OP_SUCCESS. It will never be invoked synchronously from\n aws_retry_strategy_acquire_retry_token(). Token will always be NULL if error_code is non-zero, and vice-versa. If\n token is non-null, it will have a reference count of 1, and you must call aws_retry_token_release() on it later. See\n the comments for aws_retry_strategy_on_retry_ready_fn for more info."]
pub type aws_retry_strategy_on_retry_token_acquired_fn = ::std::option::Option<
    unsafe extern "C" fn(
        retry_strategy: *mut aws_retry_strategy,
        error_code: ::std::os::raw::c_int,
        token: *mut aws_retry_token,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Invoked after a successful call to aws_retry_strategy_schedule_retry(). This function will always be invoked if and\n only if aws_retry_strategy_schedule_retry() returns AWS_OP_SUCCESS. It will never be invoked synchronously from\n aws_retry_strategy_schedule_retry(). After attempting the operation, either call aws_retry_strategy_schedule_retry()\n with an aws_retry_error_type or call aws_retry_token_record_success() and then release the token via.\n aws_retry_token_release()."]
pub type aws_retry_strategy_on_retry_ready_fn = ::std::option::Option<
    unsafe extern "C" fn(
        token: *mut aws_retry_token,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Optional function to supply your own generate random implementation"]
pub type aws_generate_random_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void) -> u64>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_retry_error_type {
    #[doc = " This is a connection level error such as a socket timeout, socket connect error, tls negotiation timeout etc...\n Typically these should never be applied for non-idempotent request types since in this scenario, it's impossible\n to know whether the operation had a side effect on the server."]
    AWS_RETRY_ERROR_TYPE_TRANSIENT = 0,
    #[doc = " This is an error where the server explicitly told the client to back off, such as a 429 or 503 Http error."]
    AWS_RETRY_ERROR_TYPE_THROTTLING = 1,
    #[doc = " This is a server error that isn't explicitly throttling but is considered by the client\n to be something that should be retried."]
    AWS_RETRY_ERROR_TYPE_SERVER_ERROR = 2,
    #[doc = " Doesn't count against any budgets. This could be something like a 401 challenge in Http."]
    AWS_RETRY_ERROR_TYPE_CLIENT_ERROR = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_retry_strategy_vtable {
    pub destroy:
        ::std::option::Option<unsafe extern "C" fn(retry_strategy: *mut aws_retry_strategy)>,
    pub acquire_token: ::std::option::Option<
        unsafe extern "C" fn(
            retry_strategy: *mut aws_retry_strategy,
            partition_id: *const aws_byte_cursor,
            on_acquired: aws_retry_strategy_on_retry_token_acquired_fn,
            user_data: *mut ::std::os::raw::c_void,
            timeout_ms: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub schedule_retry: ::std::option::Option<
        unsafe extern "C" fn(
            token: *mut aws_retry_token,
            error_type: aws_retry_error_type,
            retry_ready: aws_retry_strategy_on_retry_ready_fn,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub record_success: ::std::option::Option<
        unsafe extern "C" fn(token: *mut aws_retry_token) -> ::std::os::raw::c_int,
    >,
    pub release_token: ::std::option::Option<unsafe extern "C" fn(token: *mut aws_retry_token)>,
}
#[test]
fn bindgen_test_layout_aws_retry_strategy_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_retry_strategy_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_retry_strategy_vtable>(),
        40usize,
        concat!("Size of: ", stringify!(aws_retry_strategy_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_retry_strategy_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_retry_strategy_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy_vtable),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire_token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy_vtable),
            "::",
            stringify!(acquire_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schedule_retry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy_vtable),
            "::",
            stringify!(schedule_retry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_success) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy_vtable),
            "::",
            stringify!(record_success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_token) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy_vtable),
            "::",
            stringify!(release_token)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_retry_strategy {
    pub allocator: *mut aws_allocator,
    pub vtable: *mut aws_retry_strategy_vtable,
    pub ref_count: aws_atomic_var,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_retry_strategy() {
    const UNINIT: ::std::mem::MaybeUninit<aws_retry_strategy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_retry_strategy>(),
        32usize,
        concat!("Size of: ", stringify!(aws_retry_strategy))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_retry_strategy>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_retry_strategy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_strategy),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_retry_token {
    pub allocator: *mut aws_allocator,
    pub retry_strategy: *mut aws_retry_strategy,
    pub ref_count: aws_atomic_var,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_retry_token() {
    const UNINIT: ::std::mem::MaybeUninit<aws_retry_token> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_retry_token>(),
        32usize,
        concat!("Size of: ", stringify!(aws_retry_token))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_retry_token>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_retry_token))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_token),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retry_strategy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_token),
            "::",
            stringify!(retry_strategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_token),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_retry_token),
            "::",
            stringify!(impl_)
        )
    );
}
#[repr(u32)]
#[doc = " Jitter mode for exponential backoff.\n\n For a great writeup on these options see:\n https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_exponential_backoff_jitter_mode {
    AWS_EXPONENTIAL_BACKOFF_JITTER_DEFAULT = 0,
    AWS_EXPONENTIAL_BACKOFF_JITTER_NONE = 1,
    AWS_EXPONENTIAL_BACKOFF_JITTER_FULL = 2,
    AWS_EXPONENTIAL_BACKOFF_JITTER_DECORRELATED = 3,
}
#[doc = " Options for exponential backoff retry strategy. el_group must be set, any other option, if set to 0 will signify\n \"use defaults\""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_exponential_backoff_retry_options {
    #[doc = " Event loop group to use for scheduling tasks."]
    pub el_group: *mut aws_event_loop_group,
    #[doc = " Max retries to allow. The default value is 10"]
    pub max_retries: usize,
    #[doc = " Scaling factor to add for the backoff. Default is 500ms"]
    pub backoff_scale_factor_ms: u32,
    #[doc = " Max retry backoff in seconds. Default is 20 seconds"]
    pub max_backoff_secs: u32,
    #[doc = " Jitter mode to use, see comments for aws_exponential_backoff_jitter_mode.\n Default is AWS_EXPONENTIAL_BACKOFF_JITTER_DEFAULT"]
    pub jitter_mode: aws_exponential_backoff_jitter_mode,
    #[doc = " Deprecated. Use generate_random_impl instead\n By default this will be set to use aws_device_random. If you want something else, set it here."]
    pub generate_random: ::std::option::Option<unsafe extern "C" fn() -> u64>,
    pub generate_random_impl: aws_generate_random_fn,
    #[doc = " Optional user data for the generate random generate_random_impl."]
    pub generate_random_user_data: *mut ::std::os::raw::c_void,
    #[doc = " Optional shutdown callback that gets invoked, with appropriate user data,\n when the resources used by the retry_strategy are no longer in use."]
    pub shutdown_options: *const aws_shutdown_callback_options,
}
#[test]
fn bindgen_test_layout_aws_exponential_backoff_retry_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_exponential_backoff_retry_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_exponential_backoff_retry_options>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(aws_exponential_backoff_retry_options)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<aws_exponential_backoff_retry_options>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_exponential_backoff_retry_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).el_group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(el_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_retries) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(max_retries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backoff_scale_factor_ms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(backoff_scale_factor_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_backoff_secs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(max_backoff_secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jitter_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(jitter_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generate_random) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(generate_random)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generate_random_impl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(generate_random_impl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generate_random_user_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(generate_random_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_options) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_exponential_backoff_retry_options),
            "::",
            stringify!(shutdown_options)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_standard_retry_options {
    pub backoff_retry_options: aws_exponential_backoff_retry_options,
    #[doc = " capacity for partitions. Defaults to 500"]
    pub initial_bucket_capacity: usize,
}
#[test]
fn bindgen_test_layout_aws_standard_retry_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_standard_retry_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_standard_retry_options>(),
        72usize,
        concat!("Size of: ", stringify!(aws_standard_retry_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_standard_retry_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_standard_retry_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backoff_retry_options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_standard_retry_options),
            "::",
            stringify!(backoff_retry_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_bucket_capacity) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_standard_retry_options),
            "::",
            stringify!(initial_bucket_capacity)
        )
    );
}
extern "C" {
    #[doc = " Acquire a reference count on retry_strategy."]
    pub fn aws_retry_strategy_acquire(retry_strategy: *mut aws_retry_strategy);
}
extern "C" {
    #[doc = " Releases a reference count on retry_strategy."]
    pub fn aws_retry_strategy_release(retry_strategy: *mut aws_retry_strategy);
}
extern "C" {
    #[doc = " Attempts to acquire a retry token for use with retries. On success, on_acquired will be invoked when a token is\n available, or an error will be returned if the timeout expires. partition_id identifies operations that should be\n grouped together. This allows for more sophisticated strategies such as AIMD and circuit breaker patterns. Pass NULL\n to use the global partition."]
    pub fn aws_retry_strategy_acquire_retry_token(
        retry_strategy: *mut aws_retry_strategy,
        partition_id: *const aws_byte_cursor,
        on_acquired: aws_retry_strategy_on_retry_token_acquired_fn,
        user_data: *mut ::std::os::raw::c_void,
        timeout_ms: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Schedules a retry based on the backoff and token based strategies. retry_ready is invoked when the retry is either\n ready for execution or if it has been canceled due to application shutdown.\n\n This function can return an error to reject the retry attempt if, for example, a circuit breaker has opened. If this\n occurs users should fail their calls back to their callers.\n\n error_type is used for book keeping. See the comments above for aws_retry_error_type."]
    pub fn aws_retry_strategy_schedule_retry(
        token: *mut aws_retry_token,
        error_type: aws_retry_error_type,
        retry_ready: aws_retry_strategy_on_retry_ready_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Records a successful retry. This is used for making future decisions to open up token buckets, AIMD breakers etc...\n some strategies such as exponential backoff will ignore this, but you should always call it after a successful\n operation or your system will never recover during an outage."]
    pub fn aws_retry_token_record_success(token: *mut aws_retry_token) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increments reference count for token. This should be called any time you seat the token to a pointer you own."]
    pub fn aws_retry_token_acquire(token: *mut aws_retry_token);
}
extern "C" {
    #[doc = " Releases the reference count for token. This should always be invoked after either calling\n aws_retry_strategy_schedule_retry() and failing, or after calling aws_retry_token_record_success()."]
    pub fn aws_retry_token_release(token: *mut aws_retry_token);
}
extern "C" {
    #[doc = " Creates a retry strategy using exponential backoff. This strategy does not perform any bookkeeping on error types and\n success. There is no circuit breaker functionality in here. See the comments above for\n aws_exponential_backoff_retry_options."]
    pub fn aws_retry_strategy_new_exponential_backoff(
        allocator: *mut aws_allocator,
        config: *const aws_exponential_backoff_retry_options,
    ) -> *mut aws_retry_strategy;
}
extern "C" {
    #[doc = " This is a retry implementation that cuts off traffic if it's\n detected that an endpoint partition is having availability\n problems. This is necessary to keep from making outages worse\n by scheduling work that's unlikely to succeed yet increases\n load on an already ailing system.\n\n We do this by creating a bucket for each partition. A partition\n is an arbitrary specifier. It can be anything: a region, a service,\n a combination of region and service, a literal dns name.... doesn't matter.\n\n Each bucket has a budget for maximum allowed retries. Different types of events\n carry different weights. Things that indicate an unhealthy partition such as\n transient errors (timeouts, unhealthy connection etc...) cost more.\n A retry for any other reason (service sending a 5xx response code) cost a bit less.\n When a retry is attempted this capacity is leased out to the retry. On success it is\n released back to the capacity pool. On failure, it remains leased.\n Operations that succeed without a retry slowly restore the capacity pool.\n\n If a partition runs out of capacity it is assumed unhealthy and retries will be blocked\n until capacity returns to the pool. To prevent a partition from staying unhealthy after\n an outage has recovered, new requests that succeed without a retry will increase the capacity\n slowly ( a new request gets a payback lease of 1, but the lease is never actually deducted from the capacity pool)."]
    pub fn aws_retry_strategy_new_standard(
        allocator: *mut aws_allocator,
        config: *const aws_standard_retry_options,
    ) -> *mut aws_retry_strategy;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_shared_library {
    pub library_handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_shared_library() {
    const UNINIT: ::std::mem::MaybeUninit<aws_shared_library> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_shared_library>(),
        8usize,
        concat!("Size of: ", stringify!(aws_shared_library))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_shared_library>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_shared_library))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_shared_library),
            "::",
            stringify!(library_handle)
        )
    );
}
pub type aws_generic_function = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn aws_shared_library_init(
        library: *mut aws_shared_library,
        library_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_shared_library_clean_up(library: *mut aws_shared_library);
}
extern "C" {
    pub fn aws_shared_library_find_function(
        library: *mut aws_shared_library,
        symbol_name: *const ::std::os::raw::c_char,
        function_address: *mut aws_generic_function,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Socket handlers should be the first slot/handler in a channel. It interacts directly with the channel's event loop\n for read and write notifications. max_read_size is the maximum amount of data it will read from the socket\n before a context switch (a continuation task will be scheduled)."]
    pub fn aws_socket_handler_new(
        allocator: *mut aws_allocator,
        socket: *mut aws_socket,
        slot: *mut aws_channel_slot,
        max_read_size: usize,
    ) -> *mut aws_channel_handler;
}
extern "C" {
    pub fn aws_socket_handler_get_socket(handler: *const aws_channel_handler) -> *const aws_socket;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_socket_domain {
    AWS_SOCKET_IPV4 = 0,
    AWS_SOCKET_IPV6 = 1,
    AWS_SOCKET_LOCAL = 2,
    AWS_SOCKET_VSOCK = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_socket_type {
    AWS_SOCKET_STREAM = 0,
    AWS_SOCKET_DGRAM = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_socket_options {
    pub type_: aws_socket_type,
    pub domain: aws_socket_domain,
    pub connect_timeout_ms: u32,
    pub keep_alive_interval_sec: u16,
    pub keep_alive_timeout_sec: u16,
    pub keep_alive_max_failed_probes: u16,
    pub keepalive: bool,
    #[doc = " THIS IS AN EXPERIMENTAL AND UNSTABLE API\n (Optional)\n This property is used to bind the socket to a particular network interface by name, such as eth0 and ens32.\n If this is empty, the socket will not be bound to any interface and will use OS defaults. If the provided name\n is invalid, `aws_socket_init()` will error out with AWS_IO_SOCKET_INVALID_OPTIONS. This option is only\n supported on Linux, macOS, and platforms that have either SO_BINDTODEVICE or IP_BOUND_IF. It is not supported on\n Windows. `AWS_ERROR_PLATFORM_NOT_SUPPORTED` will be raised on unsupported platforms."]
    pub network_interface_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_aws_socket_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_socket_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_socket_options>(),
        36usize,
        concat!("Size of: ", stringify!(aws_socket_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_socket_options>(),
        4usize,
        concat!("Alignment of ", stringify!(aws_socket_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_timeout_ms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(connect_timeout_ms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive_interval_sec) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(keep_alive_interval_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_alive_timeout_sec) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(keep_alive_timeout_sec)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).keep_alive_max_failed_probes) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(keep_alive_max_failed_probes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepalive) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(keepalive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_interface_name) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_options),
            "::",
            stringify!(network_interface_name)
        )
    );
}
#[doc = " Called in client mode when an outgoing connection has succeeded or an error has occurred.\n If the connection was successful error_code will be AWS_ERROR_SUCCESS and the socket has already been assigned\n to the event loop specified in aws_socket_connect().\n\n If an error occurred error_code will be non-zero."]
pub type aws_socket_on_connection_result_fn = ::std::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Called by a listening socket when either an incoming connection has been received or an error occurred.\n\n In the normal use-case, this function will be called multiple times over the lifetime of a single listening socket.\n new_socket is already connected and initialized, and is using the same options and allocator as the listening socket.\n A user may want to call aws_socket_set_options() on the new socket if different options are desired.\n\n new_socket is not yet assigned to an event-loop. The user should call aws_socket_assign_to_event_loop() before\n performing IO operations.\n\n When error_code is AWS_ERROR_SUCCESS, new_socket is the recently accepted connection.\n If error_code is non-zero, an error occurred and you should aws_socket_close() the socket.\n\n Do not call aws_socket_clean_up() from this callback."]
pub type aws_socket_on_accept_result_fn = ::std::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::std::os::raw::c_int,
        new_socket: *mut aws_socket,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for when the data passed to a call to aws_socket_write() has either completed or failed.\n On success, error_code will be AWS_ERROR_SUCCESS."]
pub type aws_socket_on_write_completed_fn = ::std::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::std::os::raw::c_int,
        bytes_written: usize,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback for when socket is either readable (edge-triggered) or when an error has occurred. If the socket is\n readable, error_code will be AWS_ERROR_SUCCESS."]
pub type aws_socket_on_readable_fn = ::std::option::Option<
    unsafe extern "C" fn(
        socket: *mut aws_socket,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_len: ::std::os::raw::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 104usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_un> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        106usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sun_path) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_path)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_socket_endpoint {
    pub address: [::std::os::raw::c_char; 104usize],
    pub port: u32,
}
#[test]
fn bindgen_test_layout_aws_socket_endpoint() {
    const UNINIT: ::std::mem::MaybeUninit<aws_socket_endpoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_socket_endpoint>(),
        108usize,
        concat!("Size of: ", stringify!(aws_socket_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_socket_endpoint>(),
        4usize,
        concat!("Alignment of ", stringify!(aws_socket_endpoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_endpoint),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket_endpoint),
            "::",
            stringify!(port)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aws_socket {
    pub allocator: *mut aws_allocator,
    pub local_endpoint: aws_socket_endpoint,
    pub remote_endpoint: aws_socket_endpoint,
    pub options: aws_socket_options,
    pub io_handle: aws_io_handle,
    pub event_loop: *mut aws_event_loop,
    pub handler: *mut aws_channel_handler,
    pub state: ::std::os::raw::c_int,
    pub readable_fn: aws_socket_on_readable_fn,
    pub readable_user_data: *mut ::std::os::raw::c_void,
    pub connection_result_fn: aws_socket_on_connection_result_fn,
    pub accept_result_fn: aws_socket_on_accept_result_fn,
    pub connect_accept_user_data: *mut ::std::os::raw::c_void,
    pub impl_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_aws_socket() {
    const UNINIT: ::std::mem::MaybeUninit<aws_socket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_socket>(),
        352usize,
        concat!("Size of: ", stringify!(aws_socket))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_socket>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_socket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_endpoint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(local_endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_endpoint) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(remote_endpoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_handle) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(io_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_loop) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(event_loop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readable_fn) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(readable_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readable_user_data) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(readable_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_result_fn) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(connection_result_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_result_fn) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(accept_result_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_accept_user_data) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(connect_accept_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_socket),
            "::",
            stringify!(impl_)
        )
    );
}
extern "C" {
    #[doc = " Initializes a socket object with socket options. options will be copied."]
    pub fn aws_socket_init(
        socket: *mut aws_socket,
        alloc: *mut aws_allocator,
        options: *const aws_socket_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shuts down any pending operations on the socket, and cleans up state. The socket object can be re-initialized after\n this operation. This function calls aws_socket_close. If you have not already called aws_socket_close() on the\n socket, all of the rules for aws_socket_close() apply here. In this case it will not fail if you use the function\n improperly, but on some platforms you will certainly leak memory.\n\n If the socket has already been closed, you can safely, call this from any thread."]
    pub fn aws_socket_clean_up(socket: *mut aws_socket);
}
extern "C" {
    #[doc = " Connects to a remote endpoint. In UDP, this simply binds the socket to a remote address for use with\n `aws_socket_write()`, and if the operation is successful, the socket can immediately be used for write operations.\n\n In TCP, LOCAL and VSOCK this function will not block. If the return value is successful, then you must wait on the\n `on_connection_result()` callback to be invoked before using the socket.\n\n If an event_loop is provided for UDP sockets, a notification will be sent on\n on_connection_result in the event-loop's thread. Upon completion, the socket will already be assigned\n an event loop. If NULL is passed for UDP, it will immediately return upon success, but you must call\n aws_socket_assign_to_event_loop before use."]
    pub fn aws_socket_connect(
        socket: *mut aws_socket,
        remote_endpoint: *const aws_socket_endpoint,
        event_loop: *mut aws_event_loop,
        on_connection_result: aws_socket_on_connection_result_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Binds the socket to a local address. In UDP mode, the socket is ready for `aws_socket_read()` operations. In\n connection oriented modes, you still must call `aws_socket_listen()` and `aws_socket_start_accept()` before using the\n socket. local_endpoint is copied."]
    pub fn aws_socket_bind(
        socket: *mut aws_socket,
        local_endpoint: *const aws_socket_endpoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the local address which the socket is bound to.\n Raises an error if no address is bound."]
    pub fn aws_socket_get_bound_address(
        socket: *const aws_socket,
        out_address: *mut aws_socket_endpoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " TCP, LOCAL and VSOCK only. Sets up the socket to listen on the address bound to in `aws_socket_bind()`."]
    pub fn aws_socket_listen(
        socket: *mut aws_socket,
        backlog_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " TCP, LOCAL and VSOCK only. The socket will begin accepting new connections. This is an asynchronous operation. New\n connections or errors will arrive via the `on_accept_result` callback.\n\n aws_socket_bind() and aws_socket_listen() must be called before calling this function."]
    pub fn aws_socket_start_accept(
        socket: *mut aws_socket,
        accept_loop: *mut aws_event_loop,
        on_accept_result: aws_socket_on_accept_result_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " TCP, LOCAL and VSOCK only. The listening socket will stop accepting new connections.\n It is safe to call `aws_socket_start_accept()` again after\n this operation. This can be called from any thread but be aware,\n on some platforms, if you call this from outside of the current event loop's thread, it will block\n until the event loop finishes processing the request for unsubscribe in it's own thread."]
    pub fn aws_socket_stop_accept(socket: *mut aws_socket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls `close()` on the socket and unregisters all io operations from the event loop. This function must be called\n from the event-loop's thread unless this is a listening socket. If it's a listening socket it can be called from any\n non-event-loop thread or the event-loop the socket is currently assigned to. If called from outside the event-loop,\n this function will block waiting on the socket to close. If this is called from an event-loop thread other than\n the one it's assigned to, it presents the possibility of a deadlock, so don't do it."]
    pub fn aws_socket_close(socket: *mut aws_socket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calls `shutdown()` on the socket based on direction."]
    pub fn aws_socket_shutdown_dir(
        socket: *mut aws_socket,
        dir: aws_channel_direction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets new socket options on the underlying socket. This is mainly useful in context of accepting a new connection via:\n `on_incoming_connection()`. options is copied."]
    pub fn aws_socket_set_options(
        socket: *mut aws_socket,
        options: *const aws_socket_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Assigns the socket to the event-loop. The socket will begin receiving read/write/error notifications after this call.\n\n Note: If you called connect for TCP or Unix Domain Sockets and received a connection_success callback, this has\n already happened. You only need to call this function when:\n\n a.) This socket is a server socket (e.g. a result of a call to start_accept())\n b.) This socket is a UDP socket."]
    pub fn aws_socket_assign_to_event_loop(
        socket: *mut aws_socket,
        event_loop: *mut aws_event_loop,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the event-loop the socket is assigned to."]
    pub fn aws_socket_get_event_loop(socket: *mut aws_socket) -> *mut aws_event_loop;
}
extern "C" {
    #[doc = " Subscribes on_readable to notifications when the socket goes readable (edge-triggered). Errors will also be recieved\n in the callback.\n\n Note! This function is technically not thread safe, but we do not enforce which thread you call from.\n It's your responsibility to either call this in safely (e.g. just don't call it in parallel from multiple threads) or\n schedule a task to call it. If you call it before your first call to read, it will be fine."]
    pub fn aws_socket_subscribe_to_readable_events(
        socket: *mut aws_socket,
        on_readable: aws_socket_on_readable_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads from the socket. This call is non-blocking and will return `AWS_IO_SOCKET_READ_WOULD_BLOCK` if no data is\n available. `read` is the amount of data read into `buffer`.\n\n Attempts to read enough to fill all remaining space in the buffer, from `buffer->len` to `buffer->capacity`.\n `buffer->len` is updated to reflect the buffer's new length.\n\n\n Use aws_socket_subscribe_to_readable_events() to receive notifications of when the socket goes readable.\n\n NOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop"]
    pub fn aws_socket_read(
        socket: *mut aws_socket,
        buffer: *mut aws_byte_buf,
        amount_read: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes to the socket. This call is non-blocking and will attempt to write as much as it can, but will queue any\n remaining portion of the data for write when available. written_fn will be invoked once the entire cursor has been\n written, or the write failed or was cancelled.\n\n NOTE! This function must be called from the event-loop used in aws_socket_assign_to_event_loop\n\n For client sockets, connect() and aws_socket_assign_to_event_loop() must be called before calling this.\n\n For incoming sockets from a listener, aws_socket_assign_to_event_loop() must be called first."]
    pub fn aws_socket_write(
        socket: *mut aws_socket,
        cursor: *const aws_byte_cursor,
        written_fn: aws_socket_on_write_completed_fn,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the latest error from the socket. If no error has occurred AWS_OP_SUCCESS will be returned. This function does\n not raise any errors to the installed error handlers."]
    pub fn aws_socket_get_error(socket: *mut aws_socket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if the socket is still open (doesn't mean connected or listening, only that it hasn't had close()\n called."]
    pub fn aws_socket_is_open(socket: *mut aws_socket) -> bool;
}
extern "C" {
    #[doc = " Raises AWS_IO_SOCKET_INVALID_ADDRESS and logs an error if connecting to this port is illegal.\n For example, port must be in range 1-65535 to connect with IPv4.\n These port values would fail eventually in aws_socket_connect(),\n but you can use this function to validate earlier."]
    pub fn aws_socket_validate_port_for_connect(
        port: u32,
        domain: aws_socket_domain,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Raises AWS_IO_SOCKET_INVALID_ADDRESS and logs an error if binding to this port is illegal.\n For example, port must in range 0-65535 to bind with IPv4.\n These port values would fail eventually in aws_socket_bind(),\n but you can use this function to validate earlier."]
    pub fn aws_socket_validate_port_for_bind(
        port: u32,
        domain: aws_socket_domain,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Assigns a random address (UUID) for use with AWS_SOCKET_LOCAL (Unix Domain Sockets).\n For use in internal tests only."]
    pub fn aws_socket_endpoint_init_local_address_for_test(endpoint: *mut aws_socket_endpoint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_pkcs11_session {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_tls_versions {
    AWS_IO_SSLv3 = 0,
    AWS_IO_TLSv1 = 1,
    AWS_IO_TLSv1_1 = 2,
    AWS_IO_TLSv1_2 = 3,
    AWS_IO_TLSv1_3 = 4,
    AWS_IO_TLS_VER_SYS_DEFAULTS = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_tls_cipher_pref {
    AWS_IO_TLS_CIPHER_PREF_SYSTEM_DEFAULT = 0,
    AWS_IO_TLS_CIPHER_PREF_KMS_PQ_TLSv1_0_2019_06 = 1,
    AWS_IO_TLS_CIPHER_PREF_KMS_PQ_SIKE_TLSv1_0_2019_11 = 2,
    AWS_IO_TLS_CIPHER_PREF_KMS_PQ_TLSv1_0_2020_02 = 3,
    AWS_IO_TLS_CIPHER_PREF_KMS_PQ_SIKE_TLSv1_0_2020_02 = 4,
    AWS_IO_TLS_CIPHER_PREF_KMS_PQ_TLSv1_0_2020_07 = 5,
    AWS_IO_TLS_CIPHER_PREF_PQ_TLSv1_0_2021_05 = 6,
    AWS_IO_TLS_CIPHER_PREF_END_RANGE = 65535,
}
#[repr(u32)]
#[doc = " The hash algorithm of a TLS private key operation. Any custom private key operation handlers are expected to perform\n operations on the input TLS data using the correct hash algorithm or fail the operation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_tls_hash_algorithm {
    AWS_TLS_HASH_UNKNOWN = 0,
    AWS_TLS_HASH_SHA1 = 1,
    AWS_TLS_HASH_SHA224 = 2,
    AWS_TLS_HASH_SHA256 = 3,
    AWS_TLS_HASH_SHA384 = 4,
    AWS_TLS_HASH_SHA512 = 5,
}
#[repr(u32)]
#[doc = " The signature of a TLS private key operation. Any custom private key operation handlers are expected to perform\n operations on the input TLS data using the correct signature algorithm or fail the operation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_tls_signature_algorithm {
    AWS_TLS_SIGNATURE_UNKNOWN = 0,
    AWS_TLS_SIGNATURE_RSA = 1,
    AWS_TLS_SIGNATURE_ECDSA = 2,
}
#[repr(u32)]
#[doc = " The TLS private key operation that needs to be performed by a custom private key operation handler when making\n a connection using mutual TLS."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_tls_key_operation_type {
    AWS_TLS_KEY_OPERATION_UNKNOWN = 0,
    AWS_TLS_KEY_OPERATION_SIGN = 1,
    AWS_TLS_KEY_OPERATION_DECRYPT = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_ctx {
    pub alloc: *mut aws_allocator,
    pub impl_: *mut ::std::os::raw::c_void,
    pub ref_count: aws_ref_count,
}
#[test]
fn bindgen_test_layout_aws_tls_ctx() {
    const UNINIT: ::std::mem::MaybeUninit<aws_tls_ctx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_tls_ctx>(),
        40usize,
        concat!("Size of: ", stringify!(aws_tls_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_tls_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_tls_ctx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx),
            "::",
            stringify!(ref_count)
        )
    );
}
#[doc = " Invoked upon completion of the TLS handshake. If successful error_code will be AWS_OP_SUCCESS, otherwise\n the negotiation failed and immediately after this function is invoked, the channel will be shutting down."]
pub type aws_tls_on_negotiation_result_fn = ::std::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        error_code: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Only used if the TLS handler is the last handler in the channel. This allows you to read any data that\n was read and decrypted by the handler. If you have application protocol channel handlers, this function\n is not necessary and certainly not recommended."]
pub type aws_tls_on_data_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        buffer: *mut aws_byte_buf,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Invoked when an error occurs in the TLS state machine AFTER the handshake has completed. This function should only\n be used in conjunction with the rules of aws_tls_on_data_read_fn."]
pub type aws_tls_on_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        handler: *mut aws_channel_handler,
        slot: *mut aws_channel_slot,
        err: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_connection_options {
    #[doc = " semi-colon delimited list of protocols. Example:\n  h2;http/1.1"]
    pub alpn_list: *mut aws_string,
    #[doc = " Serves two purposes. If SNI is supported (hint... it is),\n this sets the SNI extension.\n\n For X.509 validation this also sets the name that will be used\n for verifying the subj alt name and common name of the peer's certificate."]
    pub server_name: *mut aws_string,
    pub on_negotiation_result: aws_tls_on_negotiation_result_fn,
    pub on_data_read: aws_tls_on_data_read_fn,
    pub on_error: aws_tls_on_error_fn,
    pub user_data: *mut ::std::os::raw::c_void,
    pub ctx: *mut aws_tls_ctx,
    pub advertise_alpn_message: bool,
    pub timeout_ms: u32,
}
#[test]
fn bindgen_test_layout_aws_tls_connection_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_tls_connection_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_tls_connection_options>(),
        64usize,
        concat!("Size of: ", stringify!(aws_tls_connection_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_tls_connection_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_tls_connection_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpn_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(alpn_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(server_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_negotiation_result) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(on_negotiation_result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_data_read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(on_data_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(on_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advertise_alpn_message) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(advertise_alpn_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_ms) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_connection_options),
            "::",
            stringify!(timeout_ms)
        )
    );
}
#[doc = " A struct containing all of the data needed for a private key operation when\n making a mutual TLS connection. This struct contains the data that needs\n to be operated on, like performing a sign operation or a decrypt operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_key_operation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_ctx_options {
    pub allocator: *mut aws_allocator,
    #[doc = "  minimum tls version to use. If you just want us to use the\n  system defaults, you can set: AWS_IO_TLS_VER_SYS_DEFAULTS. This\n  has the added benefit of automatically picking up new TLS versions\n  as your OS or distribution adds support."]
    pub minimum_tls_version: aws_tls_versions,
    #[doc = " The Cipher Preference List to use"]
    pub cipher_pref: aws_tls_cipher_pref,
    #[doc = " A PEM armored PKCS#7 collection of CAs you want to trust as a string.\n Only use this if it's a CA not currently installed on your system."]
    pub ca_file: aws_byte_buf,
    #[doc = " Only used on Unix systems using an openssl style trust API.\n this is typically something like /etc/pki/tls/certs/\""]
    pub ca_path: *mut aws_string,
    #[doc = " Sets ctx wide alpn string. This is most useful for servers.\n This is a semi-colon delimited list. example:\n h2;http/1.1"]
    pub alpn_list: *mut aws_string,
    #[doc = " A PEM armored PKCS#7 certificate as a string.\n It is supported on every operating system."]
    pub certificate: aws_byte_buf,
    #[doc = " A PEM armored PKCS#7 private key as a string.\n\n On windows, this field should be NULL only if you are\n using a system installed certficate."]
    pub private_key: aws_byte_buf,
    #[doc = " Apple Only!\n\n On Apple OS you can also use a pkcs#12 for your certificate\n and private key. This is the contents the certificate."]
    pub pkcs12: aws_byte_buf,
    #[doc = " Password for the pkcs12 data in pkcs12."]
    pub pkcs12_password: aws_byte_buf,
    #[doc = " On Apple OS you can also use a custom keychain instead of\n the default keychain of the account."]
    pub keychain_path: *mut aws_string,
    #[doc = " max tls fragment size. Default is the value of g_aws_channel_max_fragment_size."]
    pub max_fragment_size: usize,
    #[doc = " default is true for clients and false for servers.\n You should not change this default for clients unless\n you're testing and don't want to fool around with CA trust stores.\n Before you release to production, you'll want to turn this back on\n and add your custom CA to the aws_tls_ctx_options.\n\n If you set this in server mode, it enforces client authentication."]
    pub verify_peer: bool,
    #[doc = " For use when adding BYO_CRYPTO implementations. You can set extra data in here for use with your TLS\n implementation."]
    pub ctx_options_extension: *mut ::std::os::raw::c_void,
    #[doc = " Set if using custom private key operations.\n See aws_custom_key_op_handler for more details\n\n Note: Custom key operations (and PKCS#11 integration) hasn't been tested with TLS 1.3, so don't use\n cipher preferences that allow TLS 1.3. If this is set, we will always use non TLS 1.3 preferences."]
    pub custom_key_op_handler: *mut aws_custom_key_op_handler,
}
#[test]
fn bindgen_test_layout_aws_tls_ctx_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_tls_ctx_options> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_tls_ctx_options>(),
        232usize,
        concat!("Size of: ", stringify!(aws_tls_ctx_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_tls_ctx_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_tls_ctx_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum_tls_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(minimum_tls_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cipher_pref) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(cipher_pref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ca_file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(ca_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ca_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(ca_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpn_list) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(alpn_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).certificate) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_key) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(private_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkcs12) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(pkcs12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkcs12_password) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(pkcs12_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keychain_path) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(keychain_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_fragment_size) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(max_fragment_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_peer) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(verify_peer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx_options_extension) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(ctx_options_extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).custom_key_op_handler) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_options),
            "::",
            stringify!(custom_key_op_handler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_negotiated_protocol_message {
    pub protocol: aws_byte_buf,
}
#[test]
fn bindgen_test_layout_aws_tls_negotiated_protocol_message() {
    const UNINIT: ::std::mem::MaybeUninit<aws_tls_negotiated_protocol_message> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_tls_negotiated_protocol_message>(),
        32usize,
        concat!("Size of: ", stringify!(aws_tls_negotiated_protocol_message))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_tls_negotiated_protocol_message>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_tls_negotiated_protocol_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_negotiated_protocol_message),
            "::",
            stringify!(protocol)
        )
    );
}
pub type aws_tls_on_protocol_negotiated = ::std::option::Option<
    unsafe extern "C" fn(
        new_slot: *mut aws_channel_slot,
        protocol: *mut aws_byte_buf,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut aws_channel_handler,
>;
#[repr(u32)]
#[doc = " An enum for the current state of tls negotiation within a tls channel handler"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_tls_negotiation_status {
    AWS_TLS_NEGOTIATION_STATUS_NONE = 0,
    AWS_TLS_NEGOTIATION_STATUS_ONGOING = 1,
    AWS_TLS_NEGOTIATION_STATUS_SUCCESS = 2,
    AWS_TLS_NEGOTIATION_STATUS_FAILURE = 3,
}
extern "C" {
    #[doc = " tls options init stuff ***********************/\n/**\n Initializes options with default client options"]
    pub fn aws_tls_ctx_options_init_default_client(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
    );
}
extern "C" {
    #[doc = " Cleans up resources allocated by init_* functions"]
    pub fn aws_tls_ctx_options_clean_up(options: *mut aws_tls_ctx_options);
}
extern "C" {
    #[doc = " Initializes options for use with mutual tls in client mode.\n cert_path and pkey_path are paths to files on disk. cert_path\n and pkey_path are treated as PKCS#7 PEM armored. They are loaded\n from disk and stored in buffers internally.\n\n NOTE: This is unsupported on iOS."]
    pub fn aws_tls_ctx_options_init_client_mtls_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_path: *const ::std::os::raw::c_char,
        pkey_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with mutual tls in client mode.\n cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM\n armored.\n\n NOTE: This is unsupported on iOS."]
    pub fn aws_tls_ctx_options_init_client_mtls(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert: *const aws_byte_cursor,
        pkey: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
#[doc = " vtable for aws_custom_key_op_handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_custom_key_op_handler_vtable {
    #[doc = " Called when the a TLS handshake has an operation it needs the custom key operation handler to perform.\n NOTE: You must call aws_tls_key_operation_complete() or aws_tls_key_operation_complete_with_error()\n otherwise the TLS handshake will stall the TLS connection indefinitely and leak memory."]
    pub on_key_operation: ::std::option::Option<
        unsafe extern "C" fn(
            key_op_handler: *mut aws_custom_key_op_handler,
            operation: *mut aws_tls_key_operation,
        ),
    >,
}
#[test]
fn bindgen_test_layout_aws_custom_key_op_handler_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_custom_key_op_handler_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_custom_key_op_handler_vtable>(),
        8usize,
        concat!("Size of: ", stringify!(aws_custom_key_op_handler_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_custom_key_op_handler_vtable>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(aws_custom_key_op_handler_vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).on_key_operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_custom_key_op_handler_vtable),
            "::",
            stringify!(on_key_operation)
        )
    );
}
#[doc = " The custom key operation that is used when performing a mutual TLS handshake. This can\n be extended to provide custom private key operations, like PKCS11 or similar."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_custom_key_op_handler {
    #[doc = " A void* intended to be populated with a reference to whatever class is extending this class. For example,\n if you have extended aws_custom_key_op_handler with a custom struct, you would put a pointer to this struct\n to *impl so you can retrieve it back in the vtable functions."]
    pub impl_: *mut ::std::os::raw::c_void,
    #[doc = " A vtable containing all of the functions the aws_custom_key_op_handler implements. Is intended to be extended.\n NOTE: Use \"aws_custom_key_op_handler_<func>\" to access vtable functions."]
    pub vtable: *const aws_custom_key_op_handler_vtable,
    #[doc = " A reference count for handling memory usage.\n Use aws_custom_key_op_handler_acquire and aws_custom_key_op_handler_release to increase/decrease count."]
    pub ref_count: aws_ref_count,
}
#[test]
fn bindgen_test_layout_aws_custom_key_op_handler() {
    const UNINIT: ::std::mem::MaybeUninit<aws_custom_key_op_handler> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_custom_key_op_handler>(),
        40usize,
        concat!("Size of: ", stringify!(aws_custom_key_op_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_custom_key_op_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_custom_key_op_handler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_custom_key_op_handler),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_custom_key_op_handler),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_custom_key_op_handler),
            "::",
            stringify!(ref_count)
        )
    );
}
extern "C" {
    #[doc = " Increases the reference count for the passed-in aws_custom_key_op_handler and returns it."]
    pub fn aws_custom_key_op_handler_acquire(
        key_op_handler: *mut aws_custom_key_op_handler,
    ) -> *mut aws_custom_key_op_handler;
}
extern "C" {
    #[doc = " Decreases the reference count for the passed-in aws_custom_key_op_handler and returns NULL."]
    pub fn aws_custom_key_op_handler_release(
        key_op_handler: *mut aws_custom_key_op_handler,
    ) -> *mut aws_custom_key_op_handler;
}
extern "C" {
    #[doc = " Calls the on_key_operation vtable function. See aws_custom_key_op_handler_vtable for function details."]
    pub fn aws_custom_key_op_handler_perform_operation(
        key_op_handler: *mut aws_custom_key_op_handler,
        operation: *mut aws_tls_key_operation,
    );
}
extern "C" {
    #[doc = " Initializes options for use with mutual TLS in client mode,\n where private key operations are handled by custom code.\n\n Note: cert_file_contents will be copied into a new buffer after this\n function is called, so you do not need to keep that data alive\n after calling this function.\n\n @param options               aws_tls_ctx_options to be initialized.\n @param allocator             Allocator to use.\n @param custom                Options for custom key operations.\n @param cert_file_contents    The contents of a certificate file."]
    pub fn aws_tls_ctx_options_init_client_mtls_with_custom_key_operations(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        custom: *mut aws_custom_key_op_handler,
        cert_file_contents: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This struct exists as a graceful way to pass many arguments when\n calling init-with-pkcs11 functions on aws_tls_ctx_options (this also makes\n it easy to introduce optional arguments in the future).\n Instances of this struct should only exist briefly on the stack.\n\n Instructions for binding this to high-level languages:\n - Python: The members of this struct should be the keyword args to the init-with-pkcs11 functions.\n - JavaScript: This should be an options map passed to init-with-pkcs11 functions.\n - Java: This should be an options class passed to init-with-pkcs11 functions.\n - C++: Same as Java\n\n Notes on integer types:\n PKCS#11 uses `unsigned long` for IDs, handles, etc but we expose them as `uint64_t` in public APIs.\n We do this because sizeof(long) is inconsistent across platform/arch/language\n (ex: always 64bit in Java, always 32bit in C on Windows, matches CPU in C on Linux and Apple).\n By using uint64_t in our public API, we can keep the careful bounds-checking all in one\n place, instead of expecting each high-level language binding to get it just right."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_tls_ctx_pkcs11_options {
    #[doc = " The PKCS#11 library to use.\n This field is required."]
    pub pkcs11_lib: *mut aws_pkcs11_lib,
    #[doc = " User PIN, for logging into the PKCS#11 token (UTF-8).\n Zero out to log into a token with a \"protected authentication path\"."]
    pub user_pin: aws_byte_cursor,
    #[doc = " ID of slot containing PKCS#11 token.\n If set to NULL, the token will be chosen based on other criteria\n (such as token label)."]
    pub slot_id: *const u64,
    #[doc = " Label of PKCS#11 token to use.\n If zeroed out, the token will be chosen based on other criteria\n (such as slot ID)."]
    pub token_label: aws_byte_cursor,
    #[doc = " Label of private key object on PKCS#11 token (UTF-8).\n If zeroed out, the private key will be chosen based on other criteria\n (such as being the only available private key on the token)."]
    pub private_key_object_label: aws_byte_cursor,
    #[doc = " Certificate's file path on disk (UTF-8).\n The certificate must be PEM formatted and UTF-8 encoded.\n Zero out if passing in certificate by some other means (such as file contents)."]
    pub cert_file_path: aws_byte_cursor,
    #[doc = " Certificate's file contents (UTF-8).\n The certificate must be PEM formatted and UTF-8 encoded.\n Zero out if passing in certificate by some other means (such as file path)."]
    pub cert_file_contents: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_tls_ctx_pkcs11_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_tls_ctx_pkcs11_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_tls_ctx_pkcs11_options>(),
        96usize,
        concat!("Size of: ", stringify!(aws_tls_ctx_pkcs11_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_tls_ctx_pkcs11_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_tls_ctx_pkcs11_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkcs11_lib) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(pkcs11_lib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_pin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(user_pin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slot_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(slot_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token_label) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(token_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_key_object_label) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(private_key_object_label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cert_file_path) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(cert_file_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cert_file_contents) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_tls_ctx_pkcs11_options),
            "::",
            stringify!(cert_file_contents)
        )
    );
}
extern "C" {
    #[doc = " Initializes options for use with mutual TLS in client mode,\n where a PKCS#11 library provides access to the private key.\n\n NOTE: This only works on Unix devices.\n\n @param options           aws_tls_ctx_options to be initialized.\n @param allocator         Allocator to use.\n @param pkcs11_options    Options for using PKCS#11 (contents are copied)"]
    pub fn aws_tls_ctx_options_init_client_mtls_with_pkcs11(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs11_options: *const aws_tls_ctx_pkcs11_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @Deprecated\n\n Sets a custom keychain path for storing the cert and pkey with mutual tls in client mode.\n\n NOTE: This only works on MacOS."]
    pub fn aws_tls_ctx_options_set_keychain_path(
        options: *mut aws_tls_ctx_options,
        keychain_path_cursor: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with in server mode.\n cert_path and pkey_path are paths to files on disk. cert_path\n and pkey_path are treated as PKCS#7 PEM armored. They are loaded\n from disk and stored in buffers internally."]
    pub fn aws_tls_ctx_options_init_default_server_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_path: *const ::std::os::raw::c_char,
        pkey_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with in server mode.\n cert and pkey are copied. cert and pkey are treated as PKCS#7 PEM\n armored."]
    pub fn aws_tls_ctx_options_init_default_server(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert: *mut aws_byte_cursor,
        pkey: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with mutual tls in client mode.\n cert_reg_path is the path to a system\n installed certficate/private key pair. Example:\n CurrentUser\\\\MY\\\\<thumprint>\n\n NOTE: This only works on Windows."]
    pub fn aws_tls_ctx_options_init_client_mtls_from_system_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_reg_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with server mode.\n cert_reg_path is the path to a system\n installed certficate/private key pair. Example:\n CurrentUser\\\\MY\\\\<thumprint>\n\n NOTE: This only works on Windows."]
    pub fn aws_tls_ctx_options_init_default_server_from_system_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        cert_reg_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with mutual tls in client mode.\n pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded\n into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_client_mtls_pkcs12_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12_path: *const ::std::os::raw::c_char,
        pkcs_pwd: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use with mutual tls in client mode.\n pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied.\n pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_client_mtls_pkcs12(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12: *mut aws_byte_cursor,
        pkcs_pwd: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use in server mode.\n pkcs12_path is a path to a file on disk containing a pkcs#12 file. The file is loaded\n into an internal buffer. pkcs_pwd is the corresponding password for the pkcs#12 file; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_server_pkcs12_from_path(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12_path: *const ::std::os::raw::c_char,
        pkcs_password: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes options for use in server mode.\n pkcs12 is a buffer containing a pkcs#12 certificate and private key; it is copied.\n pkcs_pwd is the corresponding password for the pkcs#12 buffer; it is copied.\n\n NOTE: This only works on Apple devices."]
    pub fn aws_tls_ctx_options_init_server_pkcs12(
        options: *mut aws_tls_ctx_options,
        allocator: *mut aws_allocator,
        pkcs12: *mut aws_byte_cursor,
        pkcs_password: *mut aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported.\n alpn_list is copied."]
    pub fn aws_tls_ctx_options_set_alpn_list(
        options: *mut aws_tls_ctx_options,
        alpn_list: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enables or disables x.509 validation. Disable this only for testing. To enable mutual TLS in server mode,\n set verify_peer to true."]
    pub fn aws_tls_ctx_options_set_verify_peer(
        options: *mut aws_tls_ctx_options,
        verify_peer: bool,
    );
}
extern "C" {
    #[doc = " Sets preferred TLS Cipher List"]
    pub fn aws_tls_ctx_options_set_tls_cipher_preference(
        options: *mut aws_tls_ctx_options,
        cipher_pref: aws_tls_cipher_pref,
    );
}
extern "C" {
    #[doc = " Sets the minimum TLS version to allow."]
    pub fn aws_tls_ctx_options_set_minimum_tls_version(
        options: *mut aws_tls_ctx_options,
        minimum_tls_version: aws_tls_versions,
    );
}
extern "C" {
    #[doc = " Override the default trust store. ca_file is a buffer containing a PEM armored chain of trusted CA certificates.\n ca_file is copied."]
    pub fn aws_tls_ctx_options_override_default_trust_store(
        options: *mut aws_tls_ctx_options,
        ca_file: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Override the default trust store. ca_path is a path to a directory on disk containing trusted certificates. This is\n only supported on Unix systems (otherwise this parameter is ignored). ca_file is a path to a file on disk containing\n trusted certificates. ca_file is loaded from disk and stored in an internal buffer."]
    pub fn aws_tls_ctx_options_override_default_trust_store_from_path(
        options: *mut aws_tls_ctx_options,
        ca_path: *const ::std::os::raw::c_char,
        ca_file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " When implementing BYO_CRYPTO, if you need extra data to pass to your tls implementation, set it here. The lifetime of\n extension_data must outlive the options object and be cleaned up after options is cleaned up."]
    pub fn aws_tls_ctx_options_set_extension_data(
        options: *mut aws_tls_ctx_options,
        extension_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Initializes default connection options from an instance ot aws_tls_ctx."]
    pub fn aws_tls_connection_options_init_from_ctx(
        conn_options: *mut aws_tls_connection_options,
        ctx: *mut aws_tls_ctx,
    );
}
extern "C" {
    #[doc = " Cleans up resources in aws_tls_connection_options. This can be called immediately after initializing\n a tls handler, or if using the bootstrap api, immediately after asking for a channel."]
    pub fn aws_tls_connection_options_clean_up(connection_options: *mut aws_tls_connection_options);
}
extern "C" {
    #[doc = " Cleans up 'to' and copies 'from' to 'to'.\n 'to' must be initialized."]
    pub fn aws_tls_connection_options_copy(
        to: *mut aws_tls_connection_options,
        from: *const aws_tls_connection_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets callbacks for use with a tls connection."]
    pub fn aws_tls_connection_options_set_callbacks(
        conn_options: *mut aws_tls_connection_options,
        on_negotiation_result: aws_tls_on_negotiation_result_fn,
        on_data_read: aws_tls_on_data_read_fn,
        on_error: aws_tls_on_error_fn,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Sets server name to use for the SNI extension (supported everywhere), as well as x.509 validation. If you don't\n set this, your x.509 validation will likely fail."]
    pub fn aws_tls_connection_options_set_server_name(
        conn_options: *mut aws_tls_connection_options,
        allocator: *mut aws_allocator,
        server_name: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets alpn list in the form <protocol1;protocol2;...>. A maximum of 4 protocols are supported.\n alpn_list is copied. This value is already inherited from aws_tls_ctx, but the aws_tls_ctx is expensive,\n and should be used across as many connections as possible. If you want to set this per connection, set it here."]
    pub fn aws_tls_connection_options_set_alpn_list(
        conn_options: *mut aws_tls_connection_options,
        allocator: *mut aws_allocator,
        alpn_list: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns true if alpn is available in the underlying tls implementation.\n This function should always be called before setting an alpn list."]
    pub fn aws_tls_is_alpn_available() -> bool;
}
extern "C" {
    #[doc = " Returns true if this Cipher Preference is available in the underlying TLS implementation.\n This function should always be called before setting a Cipher Preference"]
    pub fn aws_tls_is_cipher_pref_supported(cipher_pref: aws_tls_cipher_pref) -> bool;
}
extern "C" {
    #[doc = " Creates a new tls channel handler in client mode. Options will be copied.\n You must call aws_tls_client_handler_start_negotiation and wait on the\n aws_tls_on_negotiation_result_fn callback before the handler can begin processing\n application data."]
    pub fn aws_tls_client_handler_new(
        allocator: *mut aws_allocator,
        options: *mut aws_tls_connection_options,
        slot: *mut aws_channel_slot,
    ) -> *mut aws_channel_handler;
}
extern "C" {
    #[doc = " Creates a new tls channel handler in server mode. Options will be copied.\n You must wait on the aws_tls_on_negotiation_result_fn callback before the handler can begin processing\n application data."]
    pub fn aws_tls_server_handler_new(
        allocator: *mut aws_allocator,
        options: *mut aws_tls_connection_options,
        slot: *mut aws_channel_slot,
    ) -> *mut aws_channel_handler;
}
extern "C" {
    #[doc = " Creates a channel handler, for client or server mode, that handles alpn. This isn't necessarily required\n since you can always call aws_tls_handler_protocol in the aws_tls_on_negotiation_result_fn callback, but\n this makes channel bootstrap easier to handle."]
    pub fn aws_tls_alpn_handler_new(
        allocator: *mut aws_allocator,
        on_protocol_negotiated: aws_tls_on_protocol_negotiated,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut aws_channel_handler;
}
extern "C" {
    #[doc = " Kicks off the negotiation process. This function must be called when in client mode to initiate the\n TLS handshake. Once the handshake has completed the aws_tls_on_negotiation_result_fn will be invoked."]
    pub fn aws_tls_client_handler_start_negotiation(
        handler: *mut aws_channel_handler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates a new server ctx. This ctx can be used for the lifetime of the application assuming you want the same\n options for every incoming connection. Options will be copied."]
    pub fn aws_tls_server_ctx_new(
        alloc: *mut aws_allocator,
        options: *const aws_tls_ctx_options,
    ) -> *mut aws_tls_ctx;
}
extern "C" {
    #[doc = " Creates a new client ctx. This ctx can be used for the lifetime of the application assuming you want the same\n options for every outgoing connection. Options will be copied."]
    pub fn aws_tls_client_ctx_new(
        alloc: *mut aws_allocator,
        options: *const aws_tls_ctx_options,
    ) -> *mut aws_tls_ctx;
}
extern "C" {
    #[doc = " Increments the reference count on the tls context, allowing the caller to take a reference to it.\n\n Returns the same tls context passed in."]
    pub fn aws_tls_ctx_acquire(ctx: *mut aws_tls_ctx) -> *mut aws_tls_ctx;
}
extern "C" {
    #[doc = " Decrements a tls context's ref count.  When the ref count drops to zero, the object will be destroyed."]
    pub fn aws_tls_ctx_release(ctx: *mut aws_tls_ctx);
}
extern "C" {
    #[doc = " Returns a byte buffer by copy of the negotiated protocols. If there is no agreed upon protocol, len will be 0 and\n buffer will be NULL."]
    pub fn aws_tls_handler_protocol(handler: *mut aws_channel_handler) -> aws_byte_buf;
}
extern "C" {
    #[doc = " Client mode only. This is the server name that was used for SNI and host name validation."]
    pub fn aws_tls_handler_server_name(handler: *mut aws_channel_handler) -> aws_byte_buf;
}
extern "C" {
    #[doc = " Complete a successful TLS private key operation by providing its output.\n The output is copied into the TLS connection.\n The operation is freed by this call.\n\n You MUST call this or aws_tls_key_operation_complete_with_error().\n Failure to do so will stall the TLS connection indefinitely and leak memory."]
    pub fn aws_tls_key_operation_complete(
        operation: *mut aws_tls_key_operation,
        output: aws_byte_cursor,
    );
}
extern "C" {
    #[doc = " Complete an failed TLS private key operation.\n The TLS connection will fail.\n The operation is freed by this call.\n\n You MUST call this or aws_tls_key_operation_complete().\n Failure to do so will stall the TLS connection indefinitely and leak memory."]
    pub fn aws_tls_key_operation_complete_with_error(
        operation: *mut aws_tls_key_operation,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns the input data that needs to be operated on by the custom key operation."]
    pub fn aws_tls_key_operation_get_input(
        operation: *const aws_tls_key_operation,
    ) -> aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the type of operation that needs to be performed by the custom key operation.\n If the implementation cannot perform the operation,\n use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection."]
    pub fn aws_tls_key_operation_get_type(
        operation: *const aws_tls_key_operation,
    ) -> aws_tls_key_operation_type;
}
extern "C" {
    #[doc = " Returns the algorithm the operation is expected to be operated with.\n If the implementation does not support the signature algorithm,\n use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection."]
    pub fn aws_tls_key_operation_get_signature_algorithm(
        operation: *const aws_tls_key_operation,
    ) -> aws_tls_signature_algorithm;
}
extern "C" {
    #[doc = " Returns the algorithm the operation digest is signed with.\n If the implementation does not support the digest algorithm,\n use aws_tls_key_operation_complete_with_error() to preventing stalling the TLS connection."]
    pub fn aws_tls_key_operation_get_digest_algorithm(
        operation: *const aws_tls_key_operation,
    ) -> aws_tls_hash_algorithm;
}
extern "C" {
    #[doc = " Misc TLS related"]
    pub fn aws_channel_setup_client_tls(
        right_of_slot: *mut aws_channel_slot,
        tls_options: *mut aws_tls_connection_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given enum, return string like: AWS_TLS_HASH_SHA256 -> \"SHA256\""]
    pub fn aws_tls_hash_algorithm_str(
        hash: aws_tls_hash_algorithm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\""]
    pub fn aws_tls_signature_algorithm_str(
        signature: aws_tls_signature_algorithm,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given enum, return string like: AWS_TLS_SIGNATURE_RSA -> \"RSA\""]
    pub fn aws_tls_key_operation_type_str(
        operation_type: aws_tls_key_operation_type,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_crt_io_statistics_category {
    AWSCRT_STAT_CAT_SOCKET = 256,
    AWSCRT_STAT_CAT_TLS = 257,
}
#[doc = " Socket channel handler statistics record"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_socket {
    pub category: aws_crt_statistics_category_t,
    pub bytes_read: u64,
    pub bytes_written: u64,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_socket() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_socket> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_socket>(),
        24usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_socket))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_socket>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_crt_statistics_socket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_socket),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_socket),
            "::",
            stringify!(bytes_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_written) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_socket),
            "::",
            stringify!(bytes_written)
        )
    );
}
#[doc = " Tls channel handler statistics record"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_crt_statistics_tls {
    pub category: aws_crt_statistics_category_t,
    pub handshake_start_ns: u64,
    pub handshake_end_ns: u64,
    pub handshake_status: aws_tls_negotiation_status,
}
#[test]
fn bindgen_test_layout_aws_crt_statistics_tls() {
    const UNINIT: ::std::mem::MaybeUninit<aws_crt_statistics_tls> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_crt_statistics_tls>(),
        32usize,
        concat!("Size of: ", stringify!(aws_crt_statistics_tls))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_crt_statistics_tls>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_crt_statistics_tls))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_tls),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_start_ns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_tls),
            "::",
            stringify!(handshake_start_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_end_ns) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_tls),
            "::",
            stringify!(handshake_end_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_status) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_crt_statistics_tls),
            "::",
            stringify!(handshake_status)
        )
    );
}
extern "C" {
    #[doc = " Initializes socket channel handler statistics"]
    pub fn aws_crt_statistics_socket_init(
        stats: *mut aws_crt_statistics_socket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up socket channel handler statistics"]
    pub fn aws_crt_statistics_socket_cleanup(stats: *mut aws_crt_statistics_socket);
}
extern "C" {
    #[doc = " Resets socket channel handler statistics for the next gather interval.  Calculate-once results are left alone."]
    pub fn aws_crt_statistics_socket_reset(stats: *mut aws_crt_statistics_socket);
}
extern "C" {
    #[doc = " Initializes tls channel handler statistics"]
    pub fn aws_crt_statistics_tls_init(stats: *mut aws_crt_statistics_tls)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up tls channel handler statistics"]
    pub fn aws_crt_statistics_tls_cleanup(stats: *mut aws_crt_statistics_tls);
}
extern "C" {
    #[doc = " Resets tls channel handler statistics for the next gather interval.  Calculate-once results are left alone."]
    pub fn aws_crt_statistics_tls_reset(stats: *mut aws_crt_statistics_tls);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum aws_stream_seek_basis {
    AWS_SSB_BEGIN = 0,
    AWS_SSB_END = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_stream_status {
    pub is_end_of_stream: bool,
    pub is_valid: bool,
}
#[test]
fn bindgen_test_layout_aws_stream_status() {
    const UNINIT: ::std::mem::MaybeUninit<aws_stream_status> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_stream_status>(),
        2usize,
        concat!("Size of: ", stringify!(aws_stream_status))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_stream_status>(),
        1usize,
        concat!("Alignment of ", stringify!(aws_stream_status))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_end_of_stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_stream_status),
            "::",
            stringify!(is_end_of_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_stream_status),
            "::",
            stringify!(is_valid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_input_stream_vtable {
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            offset: i64,
            basis: aws_stream_seek_basis,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Stream as much data as will fit into the destination buffer and update its length.\n The destination buffer's capacity MUST NOT be changed.\n\n Return AWS_OP_SUCCESS if the read is successful.\n If AWS_OP_ERR is returned, the stream is assumed to be invalid and any data written to the buffer is ignored.\n\n If no more data is currently available, or the end of the stream has been reached, simply return AWS_OP_SUCCESS\n without touching the destination buffer."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            dest: *mut aws_byte_buf,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_status: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            status: *mut aws_stream_status,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_length: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut aws_input_stream,
            out_length: *mut i64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Optional.\n If not set, the default aws_ref_count_acquire/release will be used.\n Set for high level language binding that has its own refcounting implementation and needs to be kept alive from\n C.\n If set, ref_count member will not be used."]
    pub acquire: ::std::option::Option<unsafe extern "C" fn(stream: *mut aws_input_stream)>,
    pub release: ::std::option::Option<unsafe extern "C" fn(stream: *mut aws_input_stream)>,
}
#[test]
fn bindgen_test_layout_aws_input_stream_vtable() {
    const UNINIT: ::std::mem::MaybeUninit<aws_input_stream_vtable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_input_stream_vtable>(),
        48usize,
        concat!("Size of: ", stringify!(aws_input_stream_vtable))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_input_stream_vtable>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_input_stream_vtable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream_vtable),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream_vtable),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream_vtable),
            "::",
            stringify!(get_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream_vtable),
            "::",
            stringify!(get_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream_vtable),
            "::",
            stringify!(acquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream_vtable),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " Base class for input streams.\n Note: when you implement one input stream, the ref_count needs to be initialized to clean up the resource when\n reaches to zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_input_stream {
    pub impl_: *mut ::std::os::raw::c_void,
    pub vtable: *const aws_input_stream_vtable,
    pub ref_count: aws_ref_count,
}
#[test]
fn bindgen_test_layout_aws_input_stream() {
    const UNINIT: ::std::mem::MaybeUninit<aws_input_stream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_input_stream>(),
        40usize,
        concat!("Size of: ", stringify!(aws_input_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_input_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_input_stream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_input_stream),
            "::",
            stringify!(ref_count)
        )
    );
}
extern "C" {
    #[doc = " Increments the reference count on the input stream, allowing the caller to take a reference to it.\n\n Returns the same input stream passed in."]
    pub fn aws_input_stream_acquire(stream: *mut aws_input_stream) -> *mut aws_input_stream;
}
extern "C" {
    #[doc = " Decrements a input stream's ref count.  When the ref count drops to zero, the input stream will be destroyed.\n\n Returns NULL always."]
    pub fn aws_input_stream_release(stream: *mut aws_input_stream) -> *mut aws_input_stream;
}
extern "C" {
    pub fn aws_input_stream_seek(
        stream: *mut aws_input_stream,
        offset: i64,
        basis: aws_stream_seek_basis,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_input_stream_read(
        stream: *mut aws_input_stream,
        dest: *mut aws_byte_buf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_input_stream_get_status(
        stream: *mut aws_input_stream,
        status: *mut aws_stream_status,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_input_stream_get_length(
        stream: *mut aws_input_stream,
        out_length: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_input_stream_destroy(stream: *mut aws_input_stream);
}
extern "C" {
    pub fn aws_input_stream_new_from_cursor(
        allocator: *mut aws_allocator,
        cursor: *const aws_byte_cursor,
    ) -> *mut aws_input_stream;
}
extern "C" {
    pub fn aws_input_stream_new_from_file(
        allocator: *mut aws_allocator,
        file_name: *const ::std::os::raw::c_char,
    ) -> *mut aws_input_stream;
}
extern "C" {
    pub fn aws_input_stream_new_from_open_file(
        allocator: *mut aws_allocator,
        file: *mut FILE,
    ) -> *mut aws_input_stream;
}
#[doc = " Data representing a URI. uri_str is always allocated and filled in.\n The other portions are merely storing offsets into uri_str."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri {
    pub self_size: usize,
    pub allocator: *mut aws_allocator,
    pub uri_str: aws_byte_buf,
    pub scheme: aws_byte_cursor,
    pub authority: aws_byte_cursor,
    pub userinfo: aws_byte_cursor,
    pub user: aws_byte_cursor,
    pub password: aws_byte_cursor,
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub path: aws_byte_cursor,
    pub query_string: aws_byte_cursor,
    pub path_and_query: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_uri() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uri> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uri>(),
        200usize,
        concat!("Size of: ", stringify!(aws_uri))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uri>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_uri))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).self_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(self_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uri_str) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(uri_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authority) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(authority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userinfo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(userinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_string) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(query_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_and_query) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri),
            "::",
            stringify!(path_and_query)
        )
    );
}
#[doc = " key/value pairs for a query string. If the query fragment was not in format key=value, the fragment value\n will be stored in key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri_param {
    pub key: aws_byte_cursor,
    pub value: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_uri_param() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uri_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uri_param>(),
        32usize,
        concat!("Size of: ", stringify!(aws_uri_param))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uri_param>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_uri_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_param),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_param),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Arguments for building a URI instance. All members must\n be initialized before passing them to aws_uri_init().\n\n query_string and query_params are exclusive to each other. If you set\n query_string, do not prepend it with '?'"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aws_uri_builder_options {
    pub scheme: aws_byte_cursor,
    pub path: aws_byte_cursor,
    pub host_name: aws_byte_cursor,
    pub port: u32,
    pub query_params: *mut aws_array_list,
    pub query_string: aws_byte_cursor,
}
#[test]
fn bindgen_test_layout_aws_uri_builder_options() {
    const UNINIT: ::std::mem::MaybeUninit<aws_uri_builder_options> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<aws_uri_builder_options>(),
        80usize,
        concat!("Size of: ", stringify!(aws_uri_builder_options))
    );
    assert_eq!(
        ::std::mem::align_of::<aws_uri_builder_options>(),
        8usize,
        concat!("Alignment of ", stringify!(aws_uri_builder_options))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(host_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_params) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(query_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_string) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(aws_uri_builder_options),
            "::",
            stringify!(query_string)
        )
    );
}
extern "C" {
    #[doc = " Parses 'uri_str' and initializes uri. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure.\n After calling this function, the parts can be accessed."]
    pub fn aws_uri_init_parse(
        uri: *mut aws_uri,
        allocator: *mut aws_allocator,
        uri_str: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initializes uri to values specified in options. Returns AWS_OP_SUCCESS, on success, AWS_OP_ERR on failure.\n After calling this function, the parts can be accessed."]
    pub fn aws_uri_init_from_builder_options(
        uri: *mut aws_uri,
        allocator: *mut aws_allocator,
        options: *mut aws_uri_builder_options,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aws_uri_clean_up(uri: *mut aws_uri);
}
extern "C" {
    #[doc = " Returns the scheme portion of the uri (e.g. http, https, ftp, ftps, etc...). If the scheme was not present\n in the uri, the returned value will be empty. It is the users job to determine the appropriate defaults\n if this field is empty, based on protocol, port, etc..."]
    pub fn aws_uri_scheme(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the authority portion of the uri (host[:port]). If it was not present, this was a request uri. In that\n case, the value will be empty."]
    pub fn aws_uri_authority(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the path portion of the uri, including any leading '/'. If not present, this value will be empty."]
    pub fn aws_uri_path(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the query string portion of the uri, minus the '?'. If not present, this value will be empty."]
    pub fn aws_uri_query_string(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the 'host_name' portion of the authority. If no authority was present, this value will be empty."]
    pub fn aws_uri_host_name(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " Returns the port portion of the authority if it was present, otherwise, returns 0.\n If this is 0, it is the users job to determine the correct port based on scheme and protocol."]
    pub fn aws_uri_port(uri: *const aws_uri) -> u32;
}
extern "C" {
    #[doc = " Returns the path and query portion of the uri (i.e., the thing you send across the wire)."]
    pub fn aws_uri_path_and_query(uri: *const aws_uri) -> *const aws_byte_cursor;
}
extern "C" {
    #[doc = " For iterating over the params in the query string.\n `param` is an in/out argument used to track progress, it MUST be zeroed out to start.\n If true is returned, `param` contains the value of the next param.\n If false is returned, there are no further params.\n\n Edge cases:\n 1) Entries without '=' sign are treated as having a key and no value.\n    Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\n 2) Blank entries are skipped.\n    Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\""]
    pub fn aws_query_string_next_param(
        query_string: aws_byte_cursor,
        param: *mut aws_uri_param,
    ) -> bool;
}
extern "C" {
    #[doc = " Parses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and\n AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param.\n The user is also responsible for cleaning up out_params when finished."]
    pub fn aws_query_string_params(
        query_string: aws_byte_cursor,
        out_params: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " For iterating over the params in the uri query string.\n `param` is an in/out argument used to track progress, it MUST be zeroed out to start.\n If true is returned, `param` contains the value of the next param.\n If false is returned, there are no further params.\n\n Edge cases:\n 1) Entries without '=' sign are treated as having a key and no value.\n    Example: First param in query string \"a&b=c\" has key=\"a\" value=\"\"\n\n 2) Blank entries are skipped.\n    Example: The only param in query string \"&&a=b\" is key=\"a\" value=\"b\""]
    pub fn aws_uri_query_string_next_param(uri: *const aws_uri, param: *mut aws_uri_param) -> bool;
}
extern "C" {
    #[doc = " Parses query string and stores the parameters in 'out_params'. Returns AWS_OP_SUCCESS on success and\n AWS_OP_ERR on failure. The user is responsible for initializing out_params with item size of struct aws_query_param.\n The user is also responsible for cleaning up out_params when finished."]
    pub fn aws_uri_query_string_params(
        uri: *const aws_uri,
        out_params: *mut aws_array_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the uri path encoding of a cursor to a buffer.  This is the modified version of rfc3986 used by\n sigv4 signing."]
    pub fn aws_byte_buf_append_encoding_uri_path(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the uri query param encoding (passthrough alnum + '-' '_' '~' '.') of a UTF-8 cursor to a buffer\n For example, reading \"a b_c\" would write \"a%20b_c\"."]
    pub fn aws_byte_buf_append_encoding_uri_param(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes the uri decoding of a UTF-8 cursor to a buffer,\n replacing %xx escapes by their single byte equivalent.\n For example, reading \"a%20b_c\" would write \"a b_c\"."]
    pub fn aws_byte_buf_append_decoding_uri(
        buffer: *mut aws_byte_buf,
        cursor: *const aws_byte_cursor,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
